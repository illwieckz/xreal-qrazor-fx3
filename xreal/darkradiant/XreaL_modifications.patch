Index: libs/picomodel/picointernal.c
===================================================================
--- libs/picomodel/picointernal.c	(revision 3603)
+++ libs/picomodel/picointernal.c	(working copy)
@@ -1,1393 +1,1393 @@
-/* -----------------------------------------------------------------------------
-
-PicoModel Library
-
-Copyright (c) 2002, Randy Reddig & seaw0lf
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-Redistributions of source code must retain the above copyright notice, this list
-of conditions and the following disclaimer.
-
-Redistributions in binary form must reproduce the above copyright notice, this
-list of conditions and the following disclaimer in the documentation and/or
-other materials provided with the distribution.
-
-Neither the names of the copyright holders nor the names of its contributors may
-be used to endorse or promote products derived from this software without
-specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
------------------------------------------------------------------------------ */
-
-
-
-/* marker */
-#define PICOINTERNAL_C
-
-
-
-/* todo:
- * - fix p->curLine for parser routines. increased twice
- */
-
-/* dependencies */
-#include <string.h>
-#include <stdlib.h>
-#include "picointernal.h"
-
-
-
-/* function pointers */
-void *(*_pico_ptr_malloc	)( size_t ) = malloc;
-void  (*_pico_ptr_free		)( void* ) = free;
-void  (*_pico_ptr_load_file	)( char*, unsigned char**, int* ) = NULL;
-void  (*_pico_ptr_free_file	)( void* ) = NULL;
-void  (*_pico_ptr_print		)( int, const char* ) = NULL;
-
-typedef union
-{
-	float	f;
-	char	c[4];
-}
-floatSwapUnion;
-
-/* _pico_alloc:
- *  kludged memory allocation wrapper
- */
-void *_pico_alloc( size_t size )
-{
-	void *ptr;
-
-	/* some sanity checks */
-	if( size == 0 )
-		return NULL;
-	if (_pico_ptr_malloc == NULL)
-		return NULL;
-
-	/* allocate memory */
-	ptr = _pico_ptr_malloc(size);
-	if (ptr == NULL)
-		return NULL;
-
-	/* zero out allocated memory */
-	memset(ptr,0,size);
-
-	/* return pointer to allocated memory */
-	return ptr;
-}
-
-/* _pico_calloc:
- *  _pico_calloc wrapper
- */
-void *_pico_calloc( size_t num, size_t size )
-{
-	void *ptr;
-
-	/* some sanity checks */
-	if( num == 0 || size == 0 )
-		return NULL;
-	if (_pico_ptr_malloc == NULL)
-		return NULL;
-
-	/* allocate memory */
-	ptr = _pico_ptr_malloc(num*size);
-	if (ptr == NULL)
-		return NULL;
-
-	/* zero out allocated memory */
-	memset(ptr,0,num*size);
-
-	/* return pointer to allocated memory */
-	return ptr;
-}
-
-/* _pico_realloc:
- *  memory reallocation wrapper (note: only grows,
- *  but never shrinks or frees)
- */
-void *_pico_realloc( void **ptr, size_t oldSize, size_t newSize )
-{
-	void *ptr2;
-	
-	/* sanity checks */
-	if( ptr == NULL )
-		return NULL;
-	if( newSize < oldSize )
-		return *ptr;
-	if (_pico_ptr_malloc == NULL)
-		return NULL;
-
-	/* allocate new pointer */
-	ptr2 = _pico_alloc( newSize );
-	if( ptr2 == NULL )
-		return NULL;
-
-	/* copy */
-	if( *ptr != NULL )
-	{
-		memcpy( ptr2, *ptr, oldSize );
-		_pico_free( *ptr );
-	}
-	
-	/* fix up and return */
-	*ptr = ptr2;
-	return *ptr;
-}
-
-/* _pico_clone_alloc:
- *  handy function for quick string allocation/copy. it clones
- *  the given string and returns a pointer to the new allocated
- *  clone (which must be freed by caller of course) or returns
- *  NULL on memory alloc or param errors. if 'size' is -1 the
- *  length of the input string is used, otherwise 'size' is used
- *  as custom clone size (the string is cropped to fit into mem
- *  if needed). -sea
- */
-char *_pico_clone_alloc( const char *str )
-{
-  char* cloned;
-
-	/* sanity check */
-	if (str == NULL)
-    return NULL;
-
-	/* allocate memory */
-	cloned = _pico_alloc( strlen(str) + 1 );
-	if (cloned == NULL)
-		return NULL;
-
-	/* copy input string to cloned string */
-	strcpy( cloned, str );
-
-	/* return ptr to cloned string */
-	return cloned;
-}
-
-/* _pico_free:
- * wrapper around the free function pointer
- */
-void _pico_free( void *ptr )
-{
-	/* sanity checks */
-	if( ptr == NULL )
-		return;
-	if (_pico_ptr_free == NULL)
-		return;
-
-	/* free the allocated memory */
-		_pico_ptr_free( ptr );
-}
-
-/* _pico_load_file:
- * wrapper around the loadfile function pointer
- */
-void _pico_load_file( char *name, unsigned char **buffer, int *bufSize )
-{
-	/* sanity checks */
-	if( name == NULL )
-	{
-		*bufSize = -1;
-		return;
-	}
-	if (_pico_ptr_load_file == NULL)
-	{
-		*bufSize = -1;
-		return;
-	}
-	/* do the actual call to read in the file; */
-	/* BUFFER IS ALLOCATED BY THE EXTERNAL LOADFILE FUNC */
-	_pico_ptr_load_file( name,buffer,bufSize );
-}
-
-/* _pico_free_file:
- * wrapper around the file free function pointer
- */
-void _pico_free_file( void *buffer )
-{
-	/* sanity checks */
-	if( buffer == NULL )
-		return;
-
-	/* use default free */
-	if( _pico_ptr_free_file == NULL )
-	{
-		free( buffer );
-		return;
-	}
-	/* free the allocated file */
-	_pico_ptr_free_file( buffer );
-}
-
-/* _pico_printf:
- * wrapper around the print function pointer -sea
- */
-void _pico_printf( int level, const char *format, ...)
-{
-	char	str[4096];
-	va_list	argptr;
-
-	/* sanity checks */
-	if( format == NULL )
-		return;
-	if (_pico_ptr_print == NULL)
-		return;
-
-	/* format string */
-	va_start( argptr,format );
-	vsprintf( str,format,argptr );
-	va_end( argptr );
-
-	/* remove linefeeds */
-	if (str[ strlen(str)-1 ] == '\n')
-		str[ strlen(str)-1 ] = '\0';
-
-	/* do the actual call */
-	_pico_ptr_print( level,str );
-}
-
-/* _pico_first_token:
- * trims everything after the first whitespace-delimited token
- */
-
-void _pico_first_token( char *str )
-{
-	if( !str || !*str )
-		return;
-	while( *str && !isspace( *str ) )
-		*str++;
-	*str = '\0';
-}
-
-/* _pico_strltrim:
- * left trims the given string -sea
- */
-char *_pico_strltrim( char *str )
-{
-	char *str1 = str, *str2 = str;
-
-	while (isspace(*str2)) str2++;
-	if( str2 != str )
-		while( *str2 != '\0' ) /* fix: ydnar */
-			*str1++ = *str2++;
-	return str;
-}
-
-/* _pico_strrtrim:
- * right trims the given string -sea
- */
-char *_pico_strrtrim( char *str )
-{
-	if (str && *str)
-	{
-		char *str1 = str;
-		int allspace = 1;
-
-		while (*str1)
-		{
-			if (allspace && !isspace(*str1)) allspace = 0;
-			str1++;
-		}
-		if (allspace) *str = '\0';
-		else {
-			str1--;
-			while ((isspace(*str1)) && (str1 >= str))
-				*str1-- = '\0';
-		}
-	}
-    return str;
-}
-
-/* _pico_strlwr:
- *  pico internal string-to-lower routine.
- */
-char *_pico_strlwr( char *str )
-{
-	char *cp;
-	for (cp=str; *cp; ++cp)
-	{
-		if ('A' <= *cp && *cp <= 'Z')
-		{
-			*cp += ('a' - 'A');
-		}
-	}
-	return str;
-}
-
-/* _pico_strchcount:
- *  counts how often the given char appears in str. -sea
- */
-int _pico_strchcount( char *str, int ch )
-{
-	int count = 0;
-	while (*str++) if (*str == ch) count++;
-	return count;
-}
-
-void _pico_zero_bounds( picoVec3_t mins, picoVec3_t maxs )
-{
-	int i;
-	for (i=0; i<3; i++)
-	{
-		mins[i] = +999999;
-		maxs[i] = -999999;
-	}
-}
-
-void _pico_expand_bounds( picoVec3_t p, picoVec3_t mins, picoVec3_t maxs )
-{
-	int i;
-	for (i=0; i<3; i++)
-	{
-		float value = p[i];
-		if (value < mins[i]) mins[i] = value;
-		if (value > maxs[i]) maxs[i] = value;
-	}
-}
-
-void _pico_zero_vec( picoVec3_t vec )
-{
-	vec[ 0 ] = vec[ 1 ] = vec[ 2 ] = 0;
-}
-
-void _pico_zero_vec2( picoVec2_t vec )
-{
-	vec[ 0 ] = vec[ 1 ] = 0;
-}
-
-void _pico_zero_vec4( picoVec4_t vec )
-{
-	vec[ 0 ] = vec[ 1 ] = vec[ 2 ] = vec[ 3 ] = 0;
-}
-
-void _pico_set_vec( picoVec3_t v, float a, float b, float c )
-{
-	v[ 0 ] = a;
-	v[ 1 ] = b;
-	v[ 2 ] = c;
-}
-
-void _pico_set_vec4( picoVec4_t v, float a, float b, float c, float d )
-{
-	v[ 0 ] = a;
-	v[ 1 ] = b;
-	v[ 2 ] = c;
-	v[ 3 ] = d;
-}
-
-void _pico_copy_vec( picoVec3_t src, picoVec3_t dest )
-{
-	dest[ 0 ] = src[ 0 ];
-	dest[ 1 ] = src[ 1 ];
-	dest[ 2 ] = src[ 2 ];
-}
-
-void _pico_copy_vec2( picoVec2_t src, picoVec2_t dest )
-{
-	dest[ 0 ] = src[ 0 ];
-	dest[ 1 ] = src[ 1 ];
-}
-
-void _pico_copy_vec4( picoVec4_t src, picoVec4_t dest )
-{
-	dest[ 0 ] = src[ 0 ];
-	dest[ 1 ] = src[ 1 ];
-	dest[ 2 ] = src[ 2 ];
-	dest[ 3 ] = src[ 3 ];
-}
-
-/* ydnar */
-picoVec_t _pico_normalize_vec( picoVec3_t vec )
-{
-	double	len, ilen;
-	
-	len = sqrt( vec[ 0 ] * vec[ 0 ] + vec[ 1 ] * vec[ 1 ] + vec[ 2 ] * vec[ 2 ] );
-	if( len == 0.0 ) return 0.0;
-	ilen = 1.0 / len;
-	vec[ 0 ] *= (picoVec_t) ilen;
-	vec[ 1 ] *= (picoVec_t) ilen;
-	vec[ 2 ] *= (picoVec_t) ilen;
-	return (picoVec_t) len;
-}
-
-void _pico_add_vec( picoVec3_t a, picoVec3_t b, picoVec3_t dest )
-{
-	dest[ 0 ] = a[ 0 ] + b[ 0 ];
-	dest[ 1 ] = a[ 1 ] + b[ 1 ];
-	dest[ 2 ] = a[ 2 ] + b[ 2 ];
-}
-
-void _pico_subtract_vec( picoVec3_t a, picoVec3_t b, picoVec3_t dest )
-{
-	dest[ 0 ] = a[ 0 ] - b[ 0 ];
-	dest[ 1 ] = a[ 1 ] - b[ 1 ];
-	dest[ 2 ] = a[ 2 ] - b[ 2 ];
-}
-
-void _pico_scale_vec( picoVec3_t v, float scale, picoVec3_t dest )
-{
-	dest[ 0 ] = v[ 0 ] * scale;
-	dest[ 1 ] = v[ 1 ] * scale;
-	dest[ 2 ] = v[ 2 ] * scale;
-}
-
-void _pico_scale_vec4( picoVec4_t v, float scale, picoVec4_t dest )
-{
-	dest[ 0 ] = v[ 0 ] * scale;
-	dest[ 1 ] = v[ 1 ] * scale;
-	dest[ 2 ] = v[ 2 ] * scale;
-	dest[ 3 ] = v[ 3 ] * scale;
-}
-
-picoVec_t _pico_dot_vec( picoVec3_t a, picoVec3_t b )
-{
-	return a[ 0 ] * b[ 0 ] + a[ 1 ] * b[ 1 ] + a[ 2 ] * b[ 2 ];
-}
-
-void _pico_cross_vec( picoVec3_t a, picoVec3_t b, picoVec3_t dest )
-{
-	dest[ 0 ] = a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ];
-	dest[ 1 ] = a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ];
-	dest[ 2 ] = a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ];
-}
-
-picoVec_t _pico_calc_plane( picoVec4_t plane, picoVec3_t a, picoVec3_t b, picoVec3_t c )
-{
-	picoVec3_t	ba, ca;
-
-	_pico_subtract_vec( b, a, ba );
-	_pico_subtract_vec( c, a, ca );
-	_pico_cross_vec( ca, ba, plane );
-	plane[ 3 ] = _pico_dot_vec( a, plane );
-	return _pico_normalize_vec( plane );
-}
-
-/* separate from _pico_set_vec4 */
-void _pico_set_color( picoColor_t c, int r, int g, int b, int a )
-{
-	c[ 0 ] = r;
-	c[ 1 ] = g;
-	c[ 2 ] = b;
-	c[ 3 ] = a;
-}
-
-void _pico_copy_color( picoColor_t src, picoColor_t dest )
-{
-	dest[ 0 ] = src[ 0 ];
-	dest[ 1 ] = src[ 1 ];
-	dest[ 2 ] = src[ 2 ];
-	dest[ 3 ] = src[ 3 ];
-}
-
-#ifdef __BIG_ENDIAN__
-
-int   _pico_big_long ( int   src ) { return src; }
-short _pico_big_short( short src ) { return src; }
-float _pico_big_float( float src ) { return src; }
-
-int _pico_little_long( int src )
-{
-	return ((src & 0xFF000000) >> 24) |
-		   ((src & 0x00FF0000) >> 8) |
-		   ((src & 0x0000FF00) << 8) |
-		   ((src & 0x000000FF) << 24);
-}
-
-short _pico_little_short( short src )
-{
-	return ((src & 0xFF00) >> 8) |
-		   ((src & 0x00FF) << 8);
-}
-
-float _pico_little_float( float src )
-{
-	floatSwapUnion in,out;
-	in.f = src;
-	out.c[ 0 ] = in.c[ 3 ];
-	out.c[ 1 ] = in.c[ 2 ];
-	out.c[ 2 ] = in.c[ 1 ];
-	out.c[ 3 ] = in.c[ 0 ];
-	return out.f;
-}
-#else /*__BIG_ENDIAN__*/
-
-int   _pico_little_long ( int   src ) { return src; }
-short _pico_little_short( short src ) { return src; }
-float _pico_little_float( float src ) { return src; }
-	
-int _pico_big_long( int src )
-{
-	return ((src & 0xFF000000) >> 24) |
-		   ((src & 0x00FF0000) >> 8) |
-		   ((src & 0x0000FF00) << 8) |
-		   ((src & 0x000000FF) << 24);
-}
-	
-short _pico_big_short( short src )
-{
-	return ((src & 0xFF00) >> 8) |
-		   ((src & 0x00FF) << 8);
-}
-	
-float _pico_big_float( float src )
-{
-	floatSwapUnion in,out;
-	in.f = src;
-	out.c[ 0 ] = in.c[ 3 ];
-	out.c[ 1 ] = in.c[ 2 ];
-	out.c[ 2 ] = in.c[ 1 ];
-	out.c[ 3 ] = in.c[ 0 ];
-	return out.f;
-}
-#endif /*__BIG_ENDIAN__*/
-
-/* _pico_stristr:
- *  case-insensitive strstr. -sea
- */
-char *_pico_stristr( char *str, const char *substr )
-{
-	const size_t sublen = strlen(substr);
-	while (*str)
-	{
-		if (!_pico_strnicmp(str,substr,sublen)) break;
-		str++;
-	}
-	if (!(*str)) str = NULL;
-	return str;
-}
-
-/*
-_pico_unixify()
-changes dos \ style path separators to /
-*/
-
-void _pico_unixify( char *path )
-{
-	if( path == NULL )
-		return;
-	while( *path )
-	{
-		if( *path == '\\' )
-			*path = '/';
-		path++;
-	}
-}
-
-/* _pico_nofname:
- *  removes file name portion from given file path and converts
- *  the directory separators to un*x style. returns 1 on success
- *  or 0 when 'destSize' was exceeded. -sea
- */
-int _pico_nofname( const char *path, char *dest, int destSize )
-{
-	int   left  = destSize;
-	char *temp  = dest;
-
-	while ((*dest = *path) != '\0')
-	{
-		if (*dest == '/' || *dest == '\\')
-		{
-			temp = (dest + 1);
-			*dest = '/';
-		}
-		dest++; path++;
-
-		if (--left < 1)
-		{
-			*temp = '\0';
-			return 0;
-		}
-	}
-	*temp = '\0';
-	return 1;
-}
-
-/* _pico_nopath:
- *  returns ptr to filename portion in given path or an empty
- *  string otherwise. given 'path' is not altered. -sea
- */
-const char *_pico_nopath( const char *path )
-{
-	const char *src;
-	src = path + (strlen(path) - 1);
-
-	if (path == NULL) return "";
-	if (!strchr(path,'/') && !strchr(path,'\\'))
-		return (path);
-
-	while ((src--) != path)
-	{
-		if (*src == '/' || *src == '\\')
-			return (++src);
-	}
-	return "";
-}
-
-/* _pico_setfext:
- *  sets/changes the file extension for the given filename
- *  or filepath's filename portion. the given 'path' *is*
- *  altered. leave 'ext' empty to remove extension. -sea
- */
-char *_pico_setfext( char *path, const char *ext )
-{
-	char *src;
-	int   remfext = 0;
-
-	src = path + (strlen(path) - 1);
-
-	if (ext == NULL) ext = "";
-	if (strlen(ext ) < 1) remfext = 1;
-	if (strlen(path) < 1)
-		return path;
-
-	while ((src--) != path)
-	{
-		if (*src == '/' || *src == '\\')
-			return path;
-
-		if (*src == '.')
-		{
-			if (remfext)
-			{
-				*src = '\0';
-				return path;
-			}
-			*(++src) = '\0';
-			break;
-		}
-	}
-	strcat(path,ext);
-	return path;
-}
-
-/* _pico_getline:
- *  extracts one line from the given buffer and stores it in dest.
- *  returns -1 on error or the length of the line on success. i've
- *  removed string trimming here. this can be done manually by the
- *  calling func.
- */
-int _pico_getline( char *buf, int bufsize, char *dest, int destsize )
-{
-	int pos;
-
-	/* check output */
-	if (dest == NULL || destsize < 1) return -1;
-	memset( dest,0,destsize );
-
-	/* check input */
-	if (buf == NULL || bufsize < 1)
-		return -1;
-
-	/* get next line */
-	for (pos=0; pos<bufsize && pos<destsize; pos++)
-	{
-		if (buf[pos] == '\n') { pos++; break; }
-		dest[pos] = buf[pos];
-	}
-	/* terminate dest and return */
-	dest[pos] = '\0';
-	return pos;
-}
-
-/* _pico_parse_skip_white:
- *  skips white spaces in current pico parser, sets *hasLFs
- *  to 1 if linefeeds were skipped, and either returns the
- *  parser's cursor pointer or NULL on error. -sea
- */
-void _pico_parse_skip_white( picoParser_t *p, int *hasLFs )
-{
-	/* sanity checks */
-	if (p == NULL || p->cursor == NULL)
-		return;
-
-	/* skin white spaces */
-	while( 1 )
-	{
-		/* sanity checks */
-		if (p->cursor <  p->buffer ||
-			p->cursor >= p->max)
-		{
-			return;
-		}
-		/* break for chars other than white spaces */
-		if (*p->cursor >  0x20) break;
-		if (*p->cursor == 0x00) return;
-
-		/* a bit of linefeed handling */
-		if (*p->cursor == '\n')
-		{
-			*hasLFs = 1;
-			p->curLine++;
-		}
-		/* go to next character */
-		p->cursor++;
-	}
-}
-
-/* _pico_new_parser:
- *  allocates a new ascii parser object.
- */
-picoParser_t *_pico_new_parser( picoByte_t *buffer, int bufSize )
-{
-	picoParser_t *p;
-	
-	/* sanity check */
-	if( buffer == NULL || bufSize <= 0 )
-		return NULL;
-	
-	/* allocate reader */
-	p = _pico_alloc( sizeof(picoParser_t) );
-	if (p == NULL) return NULL;
-	memset( p,0,sizeof(picoParser_t) );
-
-	/* allocate token space */
-	p->tokenSize = 0;
-	p->tokenMax = 1024;
-	p->token = _pico_alloc( p->tokenMax );
-	if( p->token == NULL )
-	{
-		_pico_free( p );
-		return NULL;
-	}
-	/* setup */
-	p->buffer 	= buffer;
-	p->cursor 	= buffer;
-	p->bufSize	= bufSize;
-	p->max    	= p->buffer + bufSize;
-	p->curLine = 1; /* sea: new */
-
-	/* return ptr to parser */
-	return p;
-}
-
-/* _pico_free_parser:
- *  frees an existing pico parser object.
- */
-void _pico_free_parser( picoParser_t *p )
-{
-	/* sanity check */
-	if (p == NULL) return;
-
-	/* free the parser */
-	if (p->token != NULL)
-	{
-		_pico_free( p->token );
-	}
-	_pico_free( p );
-}
-
-/* _pico_parse_ex:
- *  reads the next token from given pico parser object. if param
- * 'allowLFs' is 1 it will read beyond linefeeds and return 0 when
- *  the EOF is reached. if 'allowLFs' is 0 it will return 0 when
- *  the EOL is reached. if 'handleQuoted' is 1 the parser function
- *  will handle "quoted" strings and return the data between the
- *  quotes as token. returns 0 on end/error or 1 on success. -sea
- */
-int _pico_parse_ex( picoParser_t *p, int allowLFs, int handleQuoted )
-{
-	int hasLFs = 0;
-	char *old;
-
-	/* sanity checks */
-	if( p == NULL || p->buffer == NULL ||
-		p->cursor <  p->buffer ||
-		p->cursor >= p->max )
-	{
-		return 0;
-	}
-	/* clear parser token */
-	p->tokenSize = 0;
-	p->token[ 0 ] = '\0';
-	old = p->cursor;
-
-	/* skip whitespaces */
-	while( p->cursor < p->max && *p->cursor <= 32 )
-	{
-		if (*p->cursor == '\n')
-		{
-			p->curLine++;
-			hasLFs++;
-		}
-		p->cursor++;
-	}
-	/* return if we're not allowed to go beyond lfs */
-	if ((hasLFs > 0) && !allowLFs)
-	{
-		p->cursor = old;
-		return 0;
-	}
-	/* get next quoted string */
-	if (*p->cursor == '\"' && handleQuoted)
-	{
-		p->cursor++;
-		while (p->cursor < p->max && *p->cursor)
-		{
-			if (*p->cursor == '\\')
-			{
-				if (*(p->cursor+1) == '"')
-				{
-					p->cursor++;
-				}
-				p->token[ p->tokenSize++ ] = *p->cursor++;
-				continue;
-			}
-			else if (*p->cursor == '\"')
-			{
-				p->cursor++;
-				break;
-			}
-			else if (*p->cursor == '\n')
-			{
-				p->curLine++;
-			}
-			p->token[ p->tokenSize++ ] = *p->cursor++;
-		}
-		/* terminate token */
-		p->token[ p->tokenSize ] = '\0';
-		return 1;
-	}
-	/* otherwise get next word */
-	while( p->cursor < p->max && *p->cursor > 32 )
-	{
-		if (*p->cursor == '\n')
-		{
-			p->curLine++;
-		}
-		p->token[ p->tokenSize++ ] = *p->cursor++;
-	}
-	/* terminate token */
-	p->token[ p->tokenSize ] = '\0';
-	return 1;
-}
-
-/* _pico_parse_first:
- *  reads the first token from the next line and returns
- *  a pointer to it. returns NULL on EOL or EOF. -sea
- */
-char *_pico_parse_first( picoParser_t *p )
-{
-	/* sanity check */
-	if (p == NULL) return NULL;
-
-	/* try to read next token (with lfs & quots) */
-	if (!_pico_parse_ex( p,1,1 ))
-		return NULL;
-
-	/* return ptr to the token string */
-	return p->token;
-}
-
-/* _pico_parse:
- *  reads the next token from the parser and returns a pointer
- *  to it. quoted strings are handled as usual. returns NULL
- *  on EOL or EOF. -sea
- */
-char *_pico_parse( picoParser_t *p, int allowLFs )
-{
-	/* sanity check */
-	if (p == NULL) return NULL;
-
-	/* try to read next token (with quots) */
-	if (!_pico_parse_ex( p,allowLFs,1 ))
-		return NULL;
-
-	/* return ptr to the token string */
-	return p->token;
-}
-
-/* _pico_parse_skip_rest:
- *  skips the rest of the current line in parser.
- */
-void _pico_parse_skip_rest( picoParser_t *p )
-{
-	while( _pico_parse_ex( p,0,0 ) ) ;
-}
-
-/* _pico_parse_skip_braced:
- *  parses/skips over a braced section. returns 1 on success
- *  or 0 on error (when there was no closing bracket and the
- *  end of buffer was reached or when the opening bracket was
- *  missing).
- */
-int _pico_parse_skip_braced( picoParser_t *p )
-{
-	int firstToken = 1;
-	int level;
-
-	/* sanity check */
-	if (p == NULL) return 0;
-
-	/* set the initial level for parsing */
-	level = 0;
-
-	/* skip braced section */
-	while( 1 )
-	{
-		/* read next token (lfs allowed) */
-		if (!_pico_parse_ex( p,1,1 ))
-		{
-			/* end of parser buffer reached */
-			return 0;
-		}
-		/* first token must be an opening bracket */
-		if (firstToken && p->token[0] != '{')
-		{
-			/* opening bracket missing */
-			return 0;
-		}
-		/* we only check this once */
-		firstToken = 0;
-
-		/* update level */
-		if (p->token[1] == '\0')
-		{
-			if (p->token[0] == '{') level++;
-			if (p->token[0] == '}') level--;
-		}
-		/* break if we're back at our starting level */
-		if (level == 0) break;
-	}
-	/* successfully skipped braced section */
-	return 1;
-}
-
-int _pico_parse_check( picoParser_t *p, int allowLFs, char *str )
-{
-	if (!_pico_parse_ex( p,allowLFs,1 ))
-		return 0;
-	if (!strcmp(p->token,str))
-		return 1;
-		return 0;
-}
-
-int _pico_parse_checki( picoParser_t *p, int allowLFs, char *str )
-{
-	if (!_pico_parse_ex( p,allowLFs,1 ))
-		return 0;
-	if (!_pico_stricmp(p->token,str))
-		return 1;
-		return 0;
-}
-
-int _pico_parse_int( picoParser_t *p, int *out )
-{
-	char *token;
-
-	/* sanity checks */
-	if (p == NULL || out == NULL)
-		return 0;
-
-	/* get token and turn it into an integer */
-	*out = 0;
-	token = _pico_parse( p,0 );
-	if (token == NULL) return 0;
-	*out = atoi( token );
-
-	/* success */
-	return 1;
-}
-
-int _pico_parse_int_def( picoParser_t *p, int *out, int def )
-{
-	char *token;
-
-	/* sanity checks */
-	if (p == NULL || out == NULL)
-		return 0;
-
-	/* get token and turn it into an integer */
-	*out = def;
-	token = _pico_parse( p,0 );
-	if (token == NULL) return 0;
-	*out = atoi( token );
-
-	/* success */
-	return 1;
-}
-
-int _pico_parse_float( picoParser_t *p, float *out )
-{
-	char *token;
-
-	/* sanity checks */
-	if (p == NULL || out == NULL)
-		return 0;
-
-	/* get token and turn it into a float */
-	*out = 0.0f;
-	token = _pico_parse( p,0 );
-	if (token == NULL) return 0;
-	*out = (float) atof( token );
-
-	/* success */
-	return 1;
-}
-
-int _pico_parse_float_def( picoParser_t *p, float *out, float def )
-{
-	char *token;
-
-	/* sanity checks */
-	if (p == NULL || out == NULL)
-		return 0;
-
-	/* get token and turn it into a float */
-	*out = def;
-	token = _pico_parse( p,0 );
-	if (token == NULL) return 0;
-	*out = (float) atof( token );
-
-	/* success */
-	return 1;
-}
-
-int _pico_parse_double( picoParser_t *p, double *out )
-{
-	char *token;
-
-	/* sanity checks */
-	if (p == NULL || out == NULL)
-		return 0;
-
-	/* get token and turn it into a double */
-	*out = 0;
-	token = _pico_parse( p,0 );
-	if (token == NULL) return 0;
-	*out = (double) strtod( token, NULL );
-
-	/* success */
-	return 1;
-}
-
-int _pico_parse_double_def( picoParser_t *p, double *out, double def )
-{
-	char *token;
-
-	/* sanity checks */
-	if (p == NULL || out == NULL)
-		return 0;
-
-	/* get token and turn it into a double */
-	*out = def;
-	token = _pico_parse( p,0 );
-	if (token == NULL) return 0;
-	*out = (double) strtod( token, NULL );
-
-	/* success */
-	return 1;
-}
-
-int _pico_parse_vec( picoParser_t *p, picoVec3_t out )
-{
-	char *token;
-	int	  i;
-
-	/* sanity checks */
-	if (p == NULL || out == NULL)
-		return 0;
-
-	/* zero out outination vector */
-	_pico_zero_vec( out );
-
-	/* parse three vector components */
-	for (i=0; i<3; i++)
-	{
-		token = _pico_parse( p,0 );
-		if (token == NULL)
-		{
-			_pico_zero_vec( out );
-			return 0;
-		}
-		out[ i ] = (double) strtod( token, NULL );
-	}
-	/* success */
-	return 1;
-}
-
-int _pico_parse_vec_def( picoParser_t *p, picoVec3_t out, picoVec3_t def )
-{
-	char *token;
-	int	  i;
-
-	/* sanity checks */
-	if (p == NULL || out == NULL)
-		return 0;
-
-	/* assign default vector value */
-	_pico_copy_vec( def,out );
-
-	/* parse three vector components */
-	for (i=0; i<3; i++)
-	{
-		token = _pico_parse( p,0 );
-		if (token == NULL)
-		{
-			_pico_copy_vec( def,out );
-			return 0;
-		}
-		out[ i ] = (double) strtod( token, NULL );
-	}
-	/* success */
-	return 1;
-}
-
-int _pico_parse_vec2( picoParser_t *p, picoVec2_t out )
-{
-	char *token;
-	int	  i;
-
-	/* sanity checks */
-	if (p == NULL || out == NULL)
-		return 0;
-
-	/* zero out outination vector */
-	_pico_zero_vec2( out );
-
-	/* parse two vector components */
-	for (i=0; i<2; i++)
-	{
-		token = _pico_parse( p,0 );
-		if (token == NULL)
-		{
-			_pico_zero_vec2( out );
-			return 0;
-		}
-		out[ i ] = (double) strtod( token, NULL );
-	}
-	/* success */
-	return 1;
-}
-
-int _pico_parse_vec2_def( picoParser_t *p, picoVec2_t out, picoVec2_t def )
-{
-	char *token;
-	int	  i;
-
-	/* sanity checks */
-	if (p == NULL || out == NULL)
-		return 0;
-
-	/* assign default vector value */
-	_pico_copy_vec2( def,out );
-
-	/* parse two vector components */
-	for (i=0; i<2; i++)
-	{
-		token = _pico_parse( p,0 );
-		if (token == NULL)
-		{
-			_pico_copy_vec2( def,out );
-			return 0;
-		}
-		out[ i ] = (double) strtod( token, NULL );
-	}
-	/* success */
-	return 1;
-}
-
-int _pico_parse_vec4( picoParser_t *p, picoVec4_t out )
-{
-	char *token;
-	int	  i;
-
-	/* sanity checks */
-	if (p == NULL || out == NULL)
-		return 0;
-
-	/* zero out outination vector */
-	_pico_zero_vec4( out );
-
-	/* parse four vector components */
-	for (i=0; i<4; i++)
-	{
-		token = _pico_parse( p,0 );
-		if (token == NULL)
-		{
-			_pico_zero_vec4( out );
-			return 0;
-		}
-		out[ i ] = (double) strtod( token, NULL );
-	}
-	/* success */
-	return 1;
-}
-
-int _pico_parse_vec4_def( picoParser_t *p, picoVec4_t out, picoVec4_t def )
-{
-	char *token;
-	int	  i;
-
-	/* sanity checks */
-	if (p == NULL || out == NULL)
-		return 0;
-
-	/* assign default vector value */
-	_pico_copy_vec4( def,out );
-
-	/* parse four vector components */
-	for (i=0; i<4; i++)
-	{
-		token = _pico_parse( p,0 );
-		if (token == NULL)
-		{
-			_pico_copy_vec4( def,out );
-			return 0;
-		}
-		out[ i ] = (double) strtod( token, NULL );
-	}
-	/* success */
-	return 1;
-}
-
-/* _pico_new_memstream:
- *  allocates a new memorystream object.
- */
-picoMemStream_t *_pico_new_memstream( picoByte_t *buffer, int bufSize )
-{
-	picoMemStream_t *s;
-	
-	/* sanity check */
-	if( buffer == NULL || bufSize <= 0 )
-		return NULL;
-	
-	/* allocate stream */
-	s = _pico_alloc( sizeof(picoMemStream_t) );
-	if (s == NULL) return NULL;
-	memset( s,0,sizeof(picoMemStream_t) );
-
-	/* setup */
-	s->buffer 	= buffer;
-	s->curPos 	= buffer;
-	s->bufSize	= bufSize;
-	s->flag		= 0;
-
-	/* return ptr to stream */
-	return s;
-}
-
-/* _pico_free_memstream:
- *  frees an existing pico memorystream object.
- */
-void _pico_free_memstream( picoMemStream_t *s )
-{
-	/* sanity check */
-	if (s == NULL) return;
-
-	/* free the stream */
-	_pico_free( s );
-}
-
-/* _pico_memstream_read:
- *  reads data from a pico memorystream into a buffer.
- */
-int _pico_memstream_read( picoMemStream_t *s, void *buffer, int len )
-{
-	int ret = 1;
-
-	/* sanity checks */
-	if (s == NULL || buffer == NULL)
-		return 0;
-
-	if (s->curPos + len > s->buffer + s->bufSize)
-	{
-		s->flag |= PICO_IOEOF;
-		len = s->buffer + s->bufSize - s->curPos;
-		ret = 0;
-	}
-
-	/* read the data */
-	memcpy( buffer, s->curPos, len );
-	s->curPos += len;
-	return ret;
-}
-
-/* _pico_memstream_read:
- *  reads a character from a pico memorystream
- */
-int _pico_memstream_getc( picoMemStream_t *s )
-{
-	int c = 0;
-
-	/* sanity check */
-	if (s == NULL)
-		return -1;
-
-	/* read the character */
-	if (_pico_memstream_read( s, &c, 1) == 0)
-		return -1;
-
-	return c;
-}
-
-/* _pico_memstream_seek:
- *  sets the current read position to a different location
- */
-int _pico_memstream_seek( picoMemStream_t *s, long offset, int origin )
-{
-	int overflow;
-
-	/* sanity check */
-	if (s == NULL)
-		return -1;
-
-	if (origin == PICO_SEEK_SET)
-	{
-		s->curPos = s->buffer + offset;
-		overflow = s->curPos - ( s->buffer + s->bufSize );
-		if (overflow > 0)
-		{
-			s->curPos = s->buffer + s->bufSize;
-			return offset - overflow;
-		}
-		return 0;
-	}
-	else if (origin == PICO_SEEK_CUR)
-	{
-		s->curPos += offset;
-		overflow = s->curPos - ( s->buffer + s->bufSize );
-		if (overflow > 0)
-		{
-			s->curPos = s->buffer + s->bufSize;
-			return offset - overflow;
-		}
-		return 0;
-	}
-	else if (origin == PICO_SEEK_END)
-	{
-		s->curPos = ( s->buffer + s->bufSize ) - offset;
-		overflow = s->buffer - s->curPos;
-		if (overflow > 0)
-		{
-			s->curPos = s->buffer;
-			return offset - overflow;
-		}
-		return 0;
-	}
-
-	return -1;
-}
-
-/* _pico_memstream_tell:
- *  returns the current read position in the pico memorystream
- */
-long _pico_memstream_tell( picoMemStream_t *s )
-{
-	/* sanity check */
-	if (s == NULL)
-		return -1;
-
-	return s->curPos - s->buffer;
-}
+/* -----------------------------------------------------------------------------
+
+PicoModel Library
+
+Copyright (c) 2002, Randy Reddig & seaw0lf
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+Redistributions of source code must retain the above copyright notice, this list
+of conditions and the following disclaimer.
+
+Redistributions in binary form must reproduce the above copyright notice, this
+list of conditions and the following disclaimer in the documentation and/or
+other materials provided with the distribution.
+
+Neither the names of the copyright holders nor the names of its contributors may
+be used to endorse or promote products derived from this software without
+specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+----------------------------------------------------------------------------- */
+
+
+
+/* marker */
+#define PICOINTERNAL_C
+
+
+
+/* todo:
+ * - fix p->curLine for parser routines. increased twice
+ */
+
+/* dependencies */
+#include <string.h>
+#include <stdlib.h>
+#include "picointernal.h"
+
+
+
+/* function pointers */
+void *(*_pico_ptr_malloc	)( size_t ) = malloc;
+void  (*_pico_ptr_free		)( void* ) = free;
+void  (*_pico_ptr_load_file	)( char*, unsigned char**, int* ) = NULL;
+void  (*_pico_ptr_free_file	)( void* ) = NULL;
+void  (*_pico_ptr_print		)( int, const char* ) = NULL;
+
+typedef union
+{
+	float	f;
+	char	c[4];
+}
+floatSwapUnion;
+
+/* _pico_alloc:
+ *  kludged memory allocation wrapper
+ */
+void *_pico_alloc( size_t size )
+{
+	void *ptr;
+
+	/* some sanity checks */
+	if( size == 0 )
+		return NULL;
+	if (_pico_ptr_malloc == NULL)
+		return NULL;
+
+	/* allocate memory */
+	ptr = _pico_ptr_malloc(size);
+	if (ptr == NULL)
+		return NULL;
+
+	/* zero out allocated memory */
+	memset(ptr,0,size);
+
+	/* return pointer to allocated memory */
+	return ptr;
+}
+
+/* _pico_calloc:
+ *  _pico_calloc wrapper
+ */
+void *_pico_calloc( size_t num, size_t size )
+{
+	void *ptr;
+
+	/* some sanity checks */
+	if( num == 0 || size == 0 )
+		return NULL;
+	if (_pico_ptr_malloc == NULL)
+		return NULL;
+
+	/* allocate memory */
+	ptr = _pico_ptr_malloc(num*size);
+	if (ptr == NULL)
+		return NULL;
+
+	/* zero out allocated memory */
+	memset(ptr,0,num*size);
+
+	/* return pointer to allocated memory */
+	return ptr;
+}
+
+/* _pico_realloc:
+ *  memory reallocation wrapper (note: only grows,
+ *  but never shrinks or frees)
+ */
+void *_pico_realloc( void **ptr, size_t oldSize, size_t newSize )
+{
+	void *ptr2;
+	
+	/* sanity checks */
+	if( ptr == NULL )
+		return NULL;
+	if( newSize < oldSize )
+		return *ptr;
+	if (_pico_ptr_malloc == NULL)
+		return NULL;
+
+	/* allocate new pointer */
+	ptr2 = _pico_alloc( newSize );
+	if( ptr2 == NULL )
+		return NULL;
+
+	/* copy */
+	if( *ptr != NULL )
+	{
+		memcpy( ptr2, *ptr, oldSize );
+		_pico_free( *ptr );
+	}
+	
+	/* fix up and return */
+	*ptr = ptr2;
+	return *ptr;
+}
+
+/* _pico_clone_alloc:
+ *  handy function for quick string allocation/copy. it clones
+ *  the given string and returns a pointer to the new allocated
+ *  clone (which must be freed by caller of course) or returns
+ *  NULL on memory alloc or param errors. if 'size' is -1 the
+ *  length of the input string is used, otherwise 'size' is used
+ *  as custom clone size (the string is cropped to fit into mem
+ *  if needed). -sea
+ */
+char *_pico_clone_alloc( const char *str )
+{
+  char* cloned;
+
+	/* sanity check */
+	if (str == NULL)
+    return NULL;
+
+	/* allocate memory */
+	cloned = _pico_alloc( strlen(str) + 1 );
+	if (cloned == NULL)
+		return NULL;
+
+	/* copy input string to cloned string */
+	strcpy( cloned, str );
+
+	/* return ptr to cloned string */
+	return cloned;
+}
+
+/* _pico_free:
+ * wrapper around the free function pointer
+ */
+void _pico_free( void *ptr )
+{
+	/* sanity checks */
+	if( ptr == NULL )
+		return;
+	if (_pico_ptr_free == NULL)
+		return;
+
+	/* free the allocated memory */
+		_pico_ptr_free( ptr );
+}
+
+/* _pico_load_file:
+ * wrapper around the loadfile function pointer
+ */
+void _pico_load_file( char *name, unsigned char **buffer, int *bufSize )
+{
+	/* sanity checks */
+	if( name == NULL )
+	{
+		*bufSize = -1;
+		return;
+	}
+	if (_pico_ptr_load_file == NULL)
+	{
+		*bufSize = -1;
+		return;
+	}
+	/* do the actual call to read in the file; */
+	/* BUFFER IS ALLOCATED BY THE EXTERNAL LOADFILE FUNC */
+	_pico_ptr_load_file( name,buffer,bufSize );
+}
+
+/* _pico_free_file:
+ * wrapper around the file free function pointer
+ */
+void _pico_free_file( void *buffer )
+{
+	/* sanity checks */
+	if( buffer == NULL )
+		return;
+
+	/* use default free */
+	if( _pico_ptr_free_file == NULL )
+	{
+		free( buffer );
+		return;
+	}
+	/* free the allocated file */
+	_pico_ptr_free_file( buffer );
+}
+
+/* _pico_printf:
+ * wrapper around the print function pointer -sea
+ */
+void _pico_printf( int level, const char *format, ...)
+{
+	char	str[4096];
+	va_list	argptr;
+
+	/* sanity checks */
+	if( format == NULL )
+		return;
+	if (_pico_ptr_print == NULL)
+		return;
+
+	/* format string */
+	va_start( argptr,format );
+	vsprintf( str,format,argptr );
+	va_end( argptr );
+
+	/* remove linefeeds */
+	if (str[ strlen(str)-1 ] == '\n')
+		str[ strlen(str)-1 ] = '\0';
+
+	/* do the actual call */
+	_pico_ptr_print( level,str );
+}
+
+/* _pico_first_token:
+ * trims everything after the first whitespace-delimited token
+ */
+
+void _pico_first_token( char *str )
+{
+	if( !str || !*str )
+		return;
+	while( *str && !isspace( *str ) )
+		*str++;
+	*str = '\0';
+}
+
+/* _pico_strltrim:
+ * left trims the given string -sea
+ */
+char *_pico_strltrim( char *str )
+{
+	char *str1 = str, *str2 = str;
+
+	while (isspace(*str2)) str2++;
+	if( str2 != str )
+		while( *str2 != '\0' ) /* fix: ydnar */
+			*str1++ = *str2++;
+	return str;
+}
+
+/* _pico_strrtrim:
+ * right trims the given string -sea
+ */
+char *_pico_strrtrim( char *str )
+{
+	if (str && *str)
+	{
+		char *str1 = str;
+		int allspace = 1;
+
+		while (*str1)
+		{
+			if (allspace && !isspace(*str1)) allspace = 0;
+			str1++;
+		}
+		if (allspace) *str = '\0';
+		else {
+			str1--;
+			while ((isspace(*str1)) && (str1 >= str))
+				*str1-- = '\0';
+		}
+	}
+    return str;
+}
+
+/* _pico_strlwr:
+ *  pico internal string-to-lower routine.
+ */
+char *_pico_strlwr( char *str )
+{
+	char *cp;
+	for (cp=str; *cp; ++cp)
+	{
+		if ('A' <= *cp && *cp <= 'Z')
+		{
+			*cp += ('a' - 'A');
+		}
+	}
+	return str;
+}
+
+/* _pico_strchcount:
+ *  counts how often the given char appears in str. -sea
+ */
+int _pico_strchcount( char *str, int ch )
+{
+	int count = 0;
+	while (*str++) if (*str == ch) count++;
+	return count;
+}
+
+void _pico_zero_bounds( picoVec3_t mins, picoVec3_t maxs )
+{
+	int i;
+	for (i=0; i<3; i++)
+	{
+		mins[i] = +999999;
+		maxs[i] = -999999;
+	}
+}
+
+void _pico_expand_bounds( picoVec3_t p, picoVec3_t mins, picoVec3_t maxs )
+{
+	int i;
+	for (i=0; i<3; i++)
+	{
+		float value = p[i];
+		if (value < mins[i]) mins[i] = value;
+		if (value > maxs[i]) maxs[i] = value;
+	}
+}
+
+void _pico_zero_vec( picoVec3_t vec )
+{
+	vec[ 0 ] = vec[ 1 ] = vec[ 2 ] = 0;
+}
+
+void _pico_zero_vec2( picoVec2_t vec )
+{
+	vec[ 0 ] = vec[ 1 ] = 0;
+}
+
+void _pico_zero_vec4( picoVec4_t vec )
+{
+	vec[ 0 ] = vec[ 1 ] = vec[ 2 ] = vec[ 3 ] = 0;
+}
+
+void _pico_set_vec( picoVec3_t v, float a, float b, float c )
+{
+	v[ 0 ] = a;
+	v[ 1 ] = b;
+	v[ 2 ] = c;
+}
+
+void _pico_set_vec4( picoVec4_t v, float a, float b, float c, float d )
+{
+	v[ 0 ] = a;
+	v[ 1 ] = b;
+	v[ 2 ] = c;
+	v[ 3 ] = d;
+}
+
+void _pico_copy_vec( picoVec3_t src, picoVec3_t dest )
+{
+	dest[ 0 ] = src[ 0 ];
+	dest[ 1 ] = src[ 1 ];
+	dest[ 2 ] = src[ 2 ];
+}
+
+void _pico_copy_vec2( picoVec2_t src, picoVec2_t dest )
+{
+	dest[ 0 ] = src[ 0 ];
+	dest[ 1 ] = src[ 1 ];
+}
+
+void _pico_copy_vec4( picoVec4_t src, picoVec4_t dest )
+{
+	dest[ 0 ] = src[ 0 ];
+	dest[ 1 ] = src[ 1 ];
+	dest[ 2 ] = src[ 2 ];
+	dest[ 3 ] = src[ 3 ];
+}
+
+/* ydnar */
+picoVec_t _pico_normalize_vec( picoVec3_t vec )
+{
+	double	len, ilen;
+	
+	len = sqrt( vec[ 0 ] * vec[ 0 ] + vec[ 1 ] * vec[ 1 ] + vec[ 2 ] * vec[ 2 ] );
+	if( len == 0.0 ) return 0.0;
+	ilen = 1.0 / len;
+	vec[ 0 ] *= (picoVec_t) ilen;
+	vec[ 1 ] *= (picoVec_t) ilen;
+	vec[ 2 ] *= (picoVec_t) ilen;
+	return (picoVec_t) len;
+}
+
+void _pico_add_vec( picoVec3_t a, picoVec3_t b, picoVec3_t dest )
+{
+	dest[ 0 ] = a[ 0 ] + b[ 0 ];
+	dest[ 1 ] = a[ 1 ] + b[ 1 ];
+	dest[ 2 ] = a[ 2 ] + b[ 2 ];
+}
+
+void _pico_subtract_vec( picoVec3_t a, picoVec3_t b, picoVec3_t dest )
+{
+	dest[ 0 ] = a[ 0 ] - b[ 0 ];
+	dest[ 1 ] = a[ 1 ] - b[ 1 ];
+	dest[ 2 ] = a[ 2 ] - b[ 2 ];
+}
+
+void _pico_scale_vec( picoVec3_t v, float scale, picoVec3_t dest )
+{
+	dest[ 0 ] = v[ 0 ] * scale;
+	dest[ 1 ] = v[ 1 ] * scale;
+	dest[ 2 ] = v[ 2 ] * scale;
+}
+
+void _pico_scale_vec4( picoVec4_t v, float scale, picoVec4_t dest )
+{
+	dest[ 0 ] = v[ 0 ] * scale;
+	dest[ 1 ] = v[ 1 ] * scale;
+	dest[ 2 ] = v[ 2 ] * scale;
+	dest[ 3 ] = v[ 3 ] * scale;
+}
+
+picoVec_t _pico_dot_vec( picoVec3_t a, picoVec3_t b )
+{
+	return a[ 0 ] * b[ 0 ] + a[ 1 ] * b[ 1 ] + a[ 2 ] * b[ 2 ];
+}
+
+void _pico_cross_vec( picoVec3_t a, picoVec3_t b, picoVec3_t dest )
+{
+	dest[ 0 ] = a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ];
+	dest[ 1 ] = a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ];
+	dest[ 2 ] = a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ];
+}
+
+picoVec_t _pico_calc_plane( picoVec4_t plane, picoVec3_t a, picoVec3_t b, picoVec3_t c )
+{
+	picoVec3_t	ba, ca;
+
+	_pico_subtract_vec( b, a, ba );
+	_pico_subtract_vec( c, a, ca );
+	_pico_cross_vec( ca, ba, plane );
+	plane[ 3 ] = _pico_dot_vec( a, plane );
+	return _pico_normalize_vec( plane );
+}
+
+/* separate from _pico_set_vec4 */
+void _pico_set_color( picoColor_t c, int r, int g, int b, int a )
+{
+	c[ 0 ] = r;
+	c[ 1 ] = g;
+	c[ 2 ] = b;
+	c[ 3 ] = a;
+}
+
+void _pico_copy_color( picoColor_t src, picoColor_t dest )
+{
+	dest[ 0 ] = src[ 0 ];
+	dest[ 1 ] = src[ 1 ];
+	dest[ 2 ] = src[ 2 ];
+	dest[ 3 ] = src[ 3 ];
+}
+
+#ifdef __BIG_ENDIAN__
+
+int   _pico_big_long ( int   src ) { return src; }
+short _pico_big_short( short src ) { return src; }
+float _pico_big_float( float src ) { return src; }
+
+int _pico_little_long( int src )
+{
+	return ((src & 0xFF000000) >> 24) |
+		   ((src & 0x00FF0000) >> 8) |
+		   ((src & 0x0000FF00) << 8) |
+		   ((src & 0x000000FF) << 24);
+}
+
+short _pico_little_short( short src )
+{
+	return ((src & 0xFF00) >> 8) |
+		   ((src & 0x00FF) << 8);
+}
+
+float _pico_little_float( float src )
+{
+	floatSwapUnion in,out;
+	in.f = src;
+	out.c[ 0 ] = in.c[ 3 ];
+	out.c[ 1 ] = in.c[ 2 ];
+	out.c[ 2 ] = in.c[ 1 ];
+	out.c[ 3 ] = in.c[ 0 ];
+	return out.f;
+}
+#else /*__BIG_ENDIAN__*/
+
+int   _pico_little_long ( int   src ) { return src; }
+short _pico_little_short( short src ) { return src; }
+float _pico_little_float( float src ) { return src; }
+	
+int _pico_big_long( int src )
+{
+	return ((src & 0xFF000000) >> 24) |
+		   ((src & 0x00FF0000) >> 8) |
+		   ((src & 0x0000FF00) << 8) |
+		   ((src & 0x000000FF) << 24);
+}
+	
+short _pico_big_short( short src )
+{
+	return ((src & 0xFF00) >> 8) |
+		   ((src & 0x00FF) << 8);
+}
+	
+float _pico_big_float( float src )
+{
+	floatSwapUnion in,out;
+	in.f = src;
+	out.c[ 0 ] = in.c[ 3 ];
+	out.c[ 1 ] = in.c[ 2 ];
+	out.c[ 2 ] = in.c[ 1 ];
+	out.c[ 3 ] = in.c[ 0 ];
+	return out.f;
+}
+#endif /*__BIG_ENDIAN__*/
+
+/* _pico_stristr:
+ *  case-insensitive strstr. -sea
+ */
+char *_pico_stristr( char *str, const char *substr )
+{
+	const size_t sublen = strlen(substr);
+	while (*str)
+	{
+		if (!_pico_strnicmp(str,substr,sublen)) break;
+		str++;
+	}
+	if (!(*str)) str = NULL;
+	return str;
+}
+
+/*
+_pico_unixify()
+changes dos \ style path separators to /
+*/
+
+void _pico_unixify( char *path )
+{
+	if( path == NULL )
+		return;
+	while( *path )
+	{
+		if( *path == '\\' )
+			*path = '/';
+		path++;
+	}
+}
+
+/* _pico_nofname:
+ *  removes file name portion from given file path and converts
+ *  the directory separators to un*x style. returns 1 on success
+ *  or 0 when 'destSize' was exceeded. -sea
+ */
+int _pico_nofname( const char *path, char *dest, int destSize )
+{
+	int   left  = destSize;
+	char *temp  = dest;
+
+	while ((*dest = *path) != '\0')
+	{
+		if (*dest == '/' || *dest == '\\')
+		{
+			temp = (dest + 1);
+			*dest = '/';
+		}
+		dest++; path++;
+
+		if (--left < 1)
+		{
+			*temp = '\0';
+			return 0;
+		}
+	}
+	*temp = '\0';
+	return 1;
+}
+
+/* _pico_nopath:
+ *  returns ptr to filename portion in given path or an empty
+ *  string otherwise. given 'path' is not altered. -sea
+ */
+const char *_pico_nopath( const char *path )
+{
+	const char *src;
+	src = path + (strlen(path) - 1);
+
+	if (path == NULL) return "";
+	if (!strchr(path,'/') && !strchr(path,'\\'))
+		return (path);
+
+	while ((src--) != path)
+	{
+		if (*src == '/' || *src == '\\')
+			return (++src);
+	}
+	return "";
+}
+
+/* _pico_setfext:
+ *  sets/changes the file extension for the given filename
+ *  or filepath's filename portion. the given 'path' *is*
+ *  altered. leave 'ext' empty to remove extension. -sea
+ */
+char *_pico_setfext( char *path, const char *ext )
+{
+	char *src;
+	int   remfext = 0;
+
+	src = path + (strlen(path) - 1);
+
+	if (ext == NULL) ext = "";
+	if (strlen(ext ) < 1) remfext = 1;
+	if (strlen(path) < 1)
+		return path;
+
+	while ((src--) != path)
+	{
+		if (*src == '/' || *src == '\\')
+			return path;
+
+		if (*src == '.')
+		{
+			if (remfext)
+			{
+				*src = '\0';
+				return path;
+			}
+			*(++src) = '\0';
+			break;
+		}
+	}
+	strcat(path,ext);
+	return path;
+}
+
+/* _pico_getline:
+ *  extracts one line from the given buffer and stores it in dest.
+ *  returns -1 on error or the length of the line on success. i've
+ *  removed string trimming here. this can be done manually by the
+ *  calling func.
+ */
+int _pico_getline( char *buf, int bufsize, char *dest, int destsize )
+{
+	int pos;
+
+	/* check output */
+	if (dest == NULL || destsize < 1) return -1;
+	memset( dest,0,destsize );
+
+	/* check input */
+	if (buf == NULL || bufsize < 1)
+		return -1;
+
+	/* get next line */
+	for (pos=0; pos<bufsize && pos<destsize; pos++)
+	{
+		if (buf[pos] == '\n') { pos++; break; }
+		dest[pos] = buf[pos];
+	}
+	/* terminate dest and return */
+	dest[pos] = '\0';
+	return pos;
+}
+
+/* _pico_parse_skip_white:
+ *  skips white spaces in current pico parser, sets *hasLFs
+ *  to 1 if linefeeds were skipped, and either returns the
+ *  parser's cursor pointer or NULL on error. -sea
+ */
+void _pico_parse_skip_white( picoParser_t *p, int *hasLFs )
+{
+	/* sanity checks */
+	if (p == NULL || p->cursor == NULL)
+		return;
+
+	/* skin white spaces */
+	while( 1 )
+	{
+		/* sanity checks */
+		if (p->cursor <  p->buffer ||
+			p->cursor >= p->max)
+		{
+			return;
+		}
+		/* break for chars other than white spaces */
+		if (*p->cursor >  0x20) break;
+		if (*p->cursor == 0x00) return;
+
+		/* a bit of linefeed handling */
+		if (*p->cursor == '\n')
+		{
+			*hasLFs = 1;
+			p->curLine++;
+		}
+		/* go to next character */
+		p->cursor++;
+	}
+}
+
+/* _pico_new_parser:
+ *  allocates a new ascii parser object.
+ */
+picoParser_t *_pico_new_parser( picoByte_t *buffer, int bufSize )
+{
+	picoParser_t *p;
+	
+	/* sanity check */
+	if( buffer == NULL || bufSize <= 0 )
+		return NULL;
+	
+	/* allocate reader */
+	p = _pico_alloc( sizeof(picoParser_t) );
+	if (p == NULL) return NULL;
+	memset( p,0,sizeof(picoParser_t) );
+
+	/* allocate token space */
+	p->tokenSize = 0;
+	p->tokenMax = 1024;
+	p->token = _pico_alloc( p->tokenMax );
+	if( p->token == NULL )
+	{
+		_pico_free( p );
+		return NULL;
+	}
+	/* setup */
+	p->buffer 	= buffer;
+	p->cursor 	= buffer;
+	p->bufSize	= bufSize;
+	p->max    	= p->buffer + bufSize;
+	p->curLine = 1; /* sea: new */
+
+	/* return ptr to parser */
+	return p;
+}
+
+/* _pico_free_parser:
+ *  frees an existing pico parser object.
+ */
+void _pico_free_parser( picoParser_t *p )
+{
+	/* sanity check */
+	if (p == NULL) return;
+
+	/* free the parser */
+	if (p->token != NULL)
+	{
+		_pico_free( p->token );
+	}
+	_pico_free( p );
+}
+
+/* _pico_parse_ex:
+ *  reads the next token from given pico parser object. if param
+ * 'allowLFs' is 1 it will read beyond linefeeds and return 0 when
+ *  the EOF is reached. if 'allowLFs' is 0 it will return 0 when
+ *  the EOL is reached. if 'handleQuoted' is 1 the parser function
+ *  will handle "quoted" strings and return the data between the
+ *  quotes as token. returns 0 on end/error or 1 on success. -sea
+ */
+int _pico_parse_ex( picoParser_t *p, int allowLFs, int handleQuoted )
+{
+	int hasLFs = 0;
+	char *old;
+
+	/* sanity checks */
+	if( p == NULL || p->buffer == NULL ||
+		p->cursor <  p->buffer ||
+		p->cursor >= p->max )
+	{
+		return 0;
+	}
+	/* clear parser token */
+	p->tokenSize = 0;
+	p->token[ 0 ] = '\0';
+	old = p->cursor;
+
+	/* skip whitespaces */
+	while( p->cursor < p->max && *p->cursor <= 32 )
+	{
+		if (*p->cursor == '\n')
+		{
+			p->curLine++;
+			hasLFs++;
+		}
+		p->cursor++;
+	}
+	/* return if we're not allowed to go beyond lfs */
+	if ((hasLFs > 0) && !allowLFs)
+	{
+		p->cursor = old;
+		return 0;
+	}
+	/* get next quoted string */
+	if (*p->cursor == '\"' && handleQuoted)
+	{
+		p->cursor++;
+		while (p->cursor < p->max && *p->cursor)
+		{
+			if (*p->cursor == '\\')
+			{
+				if (*(p->cursor+1) == '"')
+				{
+					p->cursor++;
+				}
+				p->token[ p->tokenSize++ ] = *p->cursor++;
+				continue;
+			}
+			else if (*p->cursor == '\"')
+			{
+				p->cursor++;
+				break;
+			}
+			else if (*p->cursor == '\n')
+			{
+				p->curLine++;
+			}
+			p->token[ p->tokenSize++ ] = *p->cursor++;
+		}
+		/* terminate token */
+		p->token[ p->tokenSize ] = '\0';
+		return 1;
+	}
+	/* otherwise get next word */
+	while( p->cursor < p->max && *p->cursor > 32 )
+	{
+		if (*p->cursor == '\n')
+		{
+			p->curLine++;
+		}
+		p->token[ p->tokenSize++ ] = *p->cursor++;
+	}
+	/* terminate token */
+	p->token[ p->tokenSize ] = '\0';
+	return 1;
+}
+
+/* _pico_parse_first:
+ *  reads the first token from the next line and returns
+ *  a pointer to it. returns NULL on EOL or EOF. -sea
+ */
+char *_pico_parse_first( picoParser_t *p )
+{
+	/* sanity check */
+	if (p == NULL) return NULL;
+
+	/* try to read next token (with lfs & quots) */
+	if (!_pico_parse_ex( p,1,1 ))
+		return NULL;
+
+	/* return ptr to the token string */
+	return p->token;
+}
+
+/* _pico_parse:
+ *  reads the next token from the parser and returns a pointer
+ *  to it. quoted strings are handled as usual. returns NULL
+ *  on EOL or EOF. -sea
+ */
+char *_pico_parse( picoParser_t *p, int allowLFs )
+{
+	/* sanity check */
+	if (p == NULL) return NULL;
+
+	/* try to read next token (with quots) */
+	if (!_pico_parse_ex( p,allowLFs,1 ))
+		return NULL;
+
+	/* return ptr to the token string */
+	return p->token;
+}
+
+/* _pico_parse_skip_rest:
+ *  skips the rest of the current line in parser.
+ */
+void _pico_parse_skip_rest( picoParser_t *p )
+{
+	while( _pico_parse_ex( p,0,0 ) ) ;
+}
+
+/* _pico_parse_skip_braced:
+ *  parses/skips over a braced section. returns 1 on success
+ *  or 0 on error (when there was no closing bracket and the
+ *  end of buffer was reached or when the opening bracket was
+ *  missing).
+ */
+int _pico_parse_skip_braced( picoParser_t *p )
+{
+	int firstToken = 1;
+	int level;
+
+	/* sanity check */
+	if (p == NULL) return 0;
+
+	/* set the initial level for parsing */
+	level = 0;
+
+	/* skip braced section */
+	while( 1 )
+	{
+		/* read next token (lfs allowed) */
+		if (!_pico_parse_ex( p,1,1 ))
+		{
+			/* end of parser buffer reached */
+			return 0;
+		}
+		/* first token must be an opening bracket */
+		if (firstToken && p->token[0] != '{')
+		{
+			/* opening bracket missing */
+			return 0;
+		}
+		/* we only check this once */
+		firstToken = 0;
+
+		/* update level */
+		if (p->token[1] == '\0')
+		{
+			if (p->token[0] == '{') level++;
+			if (p->token[0] == '}') level--;
+		}
+		/* break if we're back at our starting level */
+		if (level == 0) break;
+	}
+	/* successfully skipped braced section */
+	return 1;
+}
+
+int _pico_parse_check( picoParser_t *p, int allowLFs, char *str )
+{
+	if (!_pico_parse_ex( p,allowLFs,1 ))
+		return 0;
+	if (!strcmp(p->token,str))
+		return 1;
+		return 0;
+}
+
+int _pico_parse_checki( picoParser_t *p, int allowLFs, char *str )
+{
+	if (!_pico_parse_ex( p,allowLFs,1 ))
+		return 0;
+	if (!_pico_stricmp(p->token,str))
+		return 1;
+		return 0;
+}
+
+int _pico_parse_int( picoParser_t *p, int *out )
+{
+	char *token;
+
+	/* sanity checks */
+	if (p == NULL || out == NULL)
+		return 0;
+
+	/* get token and turn it into an integer */
+	*out = 0;
+	token = _pico_parse( p,0 );
+	if (token == NULL) return 0;
+	*out = atoi( token );
+
+	/* success */
+	return 1;
+}
+
+int _pico_parse_int_def( picoParser_t *p, int *out, int def )
+{
+	char *token;
+
+	/* sanity checks */
+	if (p == NULL || out == NULL)
+		return 0;
+
+	/* get token and turn it into an integer */
+	*out = def;
+	token = _pico_parse( p,0 );
+	if (token == NULL) return 0;
+	*out = atoi( token );
+
+	/* success */
+	return 1;
+}
+
+int _pico_parse_float( picoParser_t *p, float *out )
+{
+	char *token;
+
+	/* sanity checks */
+	if (p == NULL || out == NULL)
+		return 0;
+
+	/* get token and turn it into a float */
+	*out = 0.0f;
+	token = _pico_parse( p,0 );
+	if (token == NULL) return 0;
+	*out = (float) atof( token );
+
+	/* success */
+	return 1;
+}
+
+int _pico_parse_float_def( picoParser_t *p, float *out, float def )
+{
+	char *token;
+
+	/* sanity checks */
+	if (p == NULL || out == NULL)
+		return 0;
+
+	/* get token and turn it into a float */
+	*out = def;
+	token = _pico_parse( p,0 );
+	if (token == NULL) return 0;
+	*out = (float) atof( token );
+
+	/* success */
+	return 1;
+}
+
+int _pico_parse_double( picoParser_t *p, double *out )
+{
+	char *token;
+
+	/* sanity checks */
+	if (p == NULL || out == NULL)
+		return 0;
+
+	/* get token and turn it into a double */
+	*out = 0;
+	token = _pico_parse( p,0 );
+	if (token == NULL) return 0;
+	*out = (double) strtod( token, NULL );
+
+	/* success */
+	return 1;
+}
+
+int _pico_parse_double_def( picoParser_t *p, double *out, double def )
+{
+	char *token;
+
+	/* sanity checks */
+	if (p == NULL || out == NULL)
+		return 0;
+
+	/* get token and turn it into a double */
+	*out = def;
+	token = _pico_parse( p,0 );
+	if (token == NULL) return 0;
+	*out = (double) strtod( token, NULL );
+
+	/* success */
+	return 1;
+}
+
+int _pico_parse_vec( picoParser_t *p, picoVec3_t out )
+{
+	char *token;
+	int	  i;
+
+	/* sanity checks */
+	if (p == NULL || out == NULL)
+		return 0;
+
+	/* zero out outination vector */
+	_pico_zero_vec( out );
+
+	/* parse three vector components */
+	for (i=0; i<3; i++)
+	{
+		token = _pico_parse( p,0 );
+		if (token == NULL)
+		{
+			_pico_zero_vec( out );
+			return 0;
+		}
+		out[ i ] = (double) strtod( token, NULL );
+	}
+	/* success */
+	return 1;
+}
+
+int _pico_parse_vec_def( picoParser_t *p, picoVec3_t out, picoVec3_t def )
+{
+	char *token;
+	int	  i;
+
+	/* sanity checks */
+	if (p == NULL || out == NULL)
+		return 0;
+
+	/* assign default vector value */
+	_pico_copy_vec( def,out );
+
+	/* parse three vector components */
+	for (i=0; i<3; i++)
+	{
+		token = _pico_parse( p,0 );
+		if (token == NULL)
+		{
+			_pico_copy_vec( def,out );
+			return 0;
+		}
+		out[ i ] = (double) strtod( token, NULL );
+	}
+	/* success */
+	return 1;
+}
+
+int _pico_parse_vec2( picoParser_t *p, picoVec2_t out )
+{
+	char *token;
+	int	  i;
+
+	/* sanity checks */
+	if (p == NULL || out == NULL)
+		return 0;
+
+	/* zero out outination vector */
+	_pico_zero_vec2( out );
+
+	/* parse two vector components */
+	for (i=0; i<2; i++)
+	{
+		token = _pico_parse( p,0 );
+		if (token == NULL)
+		{
+			_pico_zero_vec2( out );
+			return 0;
+		}
+		out[ i ] = (double) strtod( token, NULL );
+	}
+	/* success */
+	return 1;
+}
+
+int _pico_parse_vec2_def( picoParser_t *p, picoVec2_t out, picoVec2_t def )
+{
+	char *token;
+	int	  i;
+
+	/* sanity checks */
+	if (p == NULL || out == NULL)
+		return 0;
+
+	/* assign default vector value */
+	_pico_copy_vec2( def,out );
+
+	/* parse two vector components */
+	for (i=0; i<2; i++)
+	{
+		token = _pico_parse( p,0 );
+		if (token == NULL)
+		{
+			_pico_copy_vec2( def,out );
+			return 0;
+		}
+		out[ i ] = (double) strtod( token, NULL );
+	}
+	/* success */
+	return 1;
+}
+
+int _pico_parse_vec4( picoParser_t *p, picoVec4_t out )
+{
+	char *token;
+	int	  i;
+
+	/* sanity checks */
+	if (p == NULL || out == NULL)
+		return 0;
+
+	/* zero out outination vector */
+	_pico_zero_vec4( out );
+
+	/* parse four vector components */
+	for (i=0; i<4; i++)
+	{
+		token = _pico_parse( p,0 );
+		if (token == NULL)
+		{
+			_pico_zero_vec4( out );
+			return 0;
+		}
+		out[ i ] = (double) strtod( token, NULL );
+	}
+	/* success */
+	return 1;
+}
+
+int _pico_parse_vec4_def( picoParser_t *p, picoVec4_t out, picoVec4_t def )
+{
+	char *token;
+	int	  i;
+
+	/* sanity checks */
+	if (p == NULL || out == NULL)
+		return 0;
+
+	/* assign default vector value */
+	_pico_copy_vec4( def,out );
+
+	/* parse four vector components */
+	for (i=0; i<4; i++)
+	{
+		token = _pico_parse( p,0 );
+		if (token == NULL)
+		{
+			_pico_copy_vec4( def,out );
+			return 0;
+		}
+		out[ i ] = (double) strtod( token, NULL );
+	}
+	/* success */
+	return 1;
+}
+
+/* _pico_new_memstream:
+ *  allocates a new memorystream object.
+ */
+picoMemStream_t *_pico_new_memstream( picoByte_t *buffer, int bufSize )
+{
+	picoMemStream_t *s;
+	
+	/* sanity check */
+	if( buffer == NULL || bufSize <= 0 )
+		return NULL;
+	
+	/* allocate stream */
+	s = _pico_alloc( sizeof(picoMemStream_t) );
+	if (s == NULL) return NULL;
+	memset( s,0,sizeof(picoMemStream_t) );
+
+	/* setup */
+	s->buffer 	= buffer;
+	s->curPos 	= buffer;
+	s->bufSize	= bufSize;
+	s->flag		= 0;
+
+	/* return ptr to stream */
+	return s;
+}
+
+/* _pico_free_memstream:
+ *  frees an existing pico memorystream object.
+ */
+void _pico_free_memstream( picoMemStream_t *s )
+{
+	/* sanity check */
+	if (s == NULL) return;
+
+	/* free the stream */
+	_pico_free( s );
+}
+
+/* _pico_memstream_read:
+ *  reads data from a pico memorystream into a buffer.
+ */
+int _pico_memstream_read( picoMemStream_t *s, void *buffer, int len )
+{
+	int ret = 1;
+
+	/* sanity checks */
+	if (s == NULL || buffer == NULL)
+		return 0;
+
+	if (s->curPos + len > s->buffer + s->bufSize)
+	{
+		s->flag |= PICO_IOEOF;
+		len = s->buffer + s->bufSize - s->curPos;
+		ret = 0;
+	}
+
+	/* read the data */
+	memcpy( buffer, s->curPos, len );
+	s->curPos += len;
+	return ret;
+}
+
+/* _pico_memstream_read:
+ *  reads a character from a pico memorystream
+ */
+int _pico_memstream_getc( picoMemStream_t *s )
+{
+	int c = 0;
+
+	/* sanity check */
+	if (s == NULL)
+		return -1;
+
+	/* read the character */
+	if (_pico_memstream_read( s, &c, 1) == 0)
+		return -1;
+
+	return c;
+}
+
+/* _pico_memstream_seek:
+ *  sets the current read position to a different location
+ */
+int _pico_memstream_seek( picoMemStream_t *s, long offset, int origin )
+{
+	int overflow;
+
+	/* sanity check */
+	if (s == NULL)
+		return -1;
+
+	if (origin == PICO_SEEK_SET)
+	{
+		s->curPos = s->buffer + offset;
+		overflow = s->curPos - ( s->buffer + s->bufSize );
+		if (overflow > 0)
+		{
+			s->curPos = s->buffer + s->bufSize;
+			return offset - overflow;
+		}
+		return 0;
+	}
+	else if (origin == PICO_SEEK_CUR)
+	{
+		s->curPos += offset;
+		overflow = s->curPos - ( s->buffer + s->bufSize );
+		if (overflow > 0)
+		{
+			s->curPos = s->buffer + s->bufSize;
+			return offset - overflow;
+		}
+		return 0;
+	}
+	else if (origin == PICO_SEEK_END)
+	{
+		s->curPos = ( s->buffer + s->bufSize ) - offset;
+		overflow = s->buffer - s->curPos;
+		if (overflow > 0)
+		{
+			s->curPos = s->buffer;
+			return offset - overflow;
+		}
+		return 0;
+	}
+
+	return -1;
+}
+
+/* _pico_memstream_tell:
+ *  returns the current read position in the pico memorystream
+ */
+long _pico_memstream_tell( picoMemStream_t *s )
+{
+	/* sanity check */
+	if (s == NULL)
+		return -1;
+
+	return s->curPos - s->buffer;
+}
Index: libs/picomodel/picointernal.h
===================================================================
--- libs/picomodel/picointernal.h	(revision 3603)
+++ libs/picomodel/picointernal.h	(working copy)
@@ -1,208 +1,208 @@
-/* -----------------------------------------------------------------------------
-
-PicoModel Library
-
-Copyright (c) 2002, Randy Reddig & seaw0lf
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-Redistributions of source code must retain the above copyright notice, this list
-of conditions and the following disclaimer.
-
-Redistributions in binary form must reproduce the above copyright notice, this
-list of conditions and the following disclaimer in the documentation and/or
-other materials provided with the distribution.
-
-Neither the names of the copyright holders nor the names of its contributors may
-be used to endorse or promote products derived from this software without
-specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
------------------------------------------------------------------------------ */
-
-
-
-/* marker */
-#ifndef PICOINTERNAL_H
-#define PICOINTERNAL_H
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-
-/* dependencies */
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <ctype.h>
-#include <math.h>
-
-#include "picomodel.h"
-
-
-/* os dependent replacements */
-#if WIN32 || _WIN32
-	#define _pico_stricmp stricmp
-	#define _pico_strnicmp strnicmp
-#else
-	#define _pico_stricmp strcasecmp
-	#define _pico_strnicmp strncasecmp
-#endif
-
-
-/* constants */
-#define	PICO_PI	3.14159265358979323846
-
-#define PICO_SEEK_SET    0
-#define PICO_SEEK_CUR    1
-#define PICO_SEEK_END    2
-
-#define PICO_IOEOF	1
-#define PICO_IOERR	2
-
-/* types */
-typedef struct picoParser_s
-{
-	char	*buffer;
-	int		 bufSize;
-	char	*token;
-	int		 tokenSize;
-	int		 tokenMax;
-	char	*cursor;
-	char	*max;
-	int		 curLine;
-}
-picoParser_t;
-
-typedef struct picoMemStream_s
-{
-	picoByte_t	*buffer;
-	int			bufSize;
-	picoByte_t	*curPos;
-	int			flag;
-}
-picoMemStream_t;
-
-
-/* variables */
-extern const picoModule_t	*picoModules[];
-
-extern void					*(*_pico_ptr_malloc)( size_t );
-extern void					(*_pico_ptr_free)( void* );
-extern void					(*_pico_ptr_load_file)( char*, unsigned char**, int* );
-extern void					(*_pico_ptr_free_file)( void* );
-extern void					(*_pico_ptr_print)( int, const char* );
-
-
-
-/* prototypes */
-
-/* memory */
-void			*_pico_alloc( size_t size );
-void			*_pico_calloc( size_t num, size_t size );
-void			*_pico_realloc( void **ptr, size_t oldSize, size_t newSize );
-char 			*_pico_clone_alloc( const char *str );
-void			_pico_free( void *ptr );
-
-/* files */
-void			_pico_load_file( char *name, unsigned char **buffer, int *bufSize );
-void			_pico_free_file( void *buffer );
-
-/* strings */
-void			_pico_first_token( char *str );
-char			*_pico_strltrim( char *str );
-char			*_pico_strrtrim( char *str );
-int				_pico_strchcount( char *str, int ch );
-void 			_pico_printf( int level, const char *format, ... );
-char			*_pico_stristr( char *str, const char *substr );
-void			_pico_unixify( char *path );
-int				_pico_nofname( const char *path, char *dest, int destSize );
-const char *_pico_nopath( const char *path );
-char			*_pico_setfext( char *path, const char *ext );
-int				_pico_getline( char *buf, int bufsize, char *dest, int destsize );
-char			*_pico_strlwr( char *str );
-
-/* vectors */
-void 			_pico_zero_bounds( picoVec3_t mins, picoVec3_t maxs );
-void 			_pico_expand_bounds( picoVec3_t p, picoVec3_t mins, picoVec3_t maxs );
-void 			_pico_zero_vec( picoVec3_t vec );
-void 			_pico_zero_vec2( picoVec2_t vec );
-void 			_pico_zero_vec4( picoVec4_t vec );
-void 			_pico_set_vec( picoVec3_t v, float a, float b, float c );
-void 			_pico_set_vec4( picoVec4_t v, float a, float b, float c, float d );
-void			_pico_set_color( picoColor_t c, int r, int g, int b, int a );
-void 			_pico_copy_color( picoColor_t src, picoColor_t dest );
-void 			_pico_copy_vec( picoVec3_t src, picoVec3_t dest );
-void 			_pico_copy_vec2( picoVec2_t src, picoVec2_t dest );
-picoVec_t		_pico_normalize_vec( picoVec3_t vec );
-void			_pico_add_vec( picoVec3_t a, picoVec3_t b, picoVec3_t dest );
-void			_pico_subtract_vec( picoVec3_t a, picoVec3_t b, picoVec3_t dest );
-picoVec_t		_pico_dot_vec( picoVec3_t a, picoVec3_t b );
-void			_pico_cross_vec( picoVec3_t a, picoVec3_t b, picoVec3_t dest );
-picoVec_t		_pico_calc_plane( picoVec4_t plane, picoVec3_t a, picoVec3_t b, picoVec3_t c );
-void 			_pico_scale_vec( picoVec3_t v, float scale, picoVec3_t dest );
-void 			_pico_scale_vec4( picoVec4_t v, float scale, picoVec4_t dest );
-
-/* endian */
-int 			_pico_big_long( int src );
-short 			_pico_big_short( short src );
-float			_pico_big_float( float src );
-
-int 			_pico_little_long( int src );
-short 			_pico_little_short( short src );
-float 			_pico_little_float( float src );
-
-/* pico ascii parser */
-picoParser_t 	*_pico_new_parser( picoByte_t *buffer, int bufSize );
-void 			_pico_free_parser( picoParser_t *p );
-int				_pico_parse_ex( picoParser_t *p, int allowLFs, int handleQuoted );
-char 			*_pico_parse_first( picoParser_t *p );
-char 			*_pico_parse( picoParser_t *p, int allowLFs );
-void 			_pico_parse_skip_rest( picoParser_t *p );
-int				_pico_parse_skip_braced( picoParser_t *p );
-int 			_pico_parse_check( picoParser_t *p, int allowLFs, char *str );
-int 			_pico_parse_checki( picoParser_t *p, int allowLFs, char *str );
-int 			_pico_parse_int( picoParser_t *p, int *out );
-int 			_pico_parse_int_def( picoParser_t *p, int *out, int def );
-int 			_pico_parse_float( picoParser_t *p, float *out );
-int 			_pico_parse_float_def( picoParser_t *p, float *out, float def );
-int 			_pico_parse_double( picoParser_t *p, double *out );
-int 			_pico_parse_double_def( picoParser_t *p, double *out, double def );
-int 			_pico_parse_vec( picoParser_t *p, picoVec3_t out);
-int 			_pico_parse_vec_def( picoParser_t *p, picoVec3_t out, picoVec3_t def);
-int 			_pico_parse_vec2( picoParser_t *p, picoVec2_t out );
-int 			_pico_parse_vec2_def( picoParser_t *p, picoVec2_t out, picoVec2_t def );
-int 			_pico_parse_vec4( picoParser_t *p, picoVec4_t out);
-int 			_pico_parse_vec4_def( picoParser_t *p, picoVec4_t out, picoVec4_t def);
-
-/* pico memory stream */
-picoMemStream_t	*_pico_new_memstream( picoByte_t *buffer, int bufSize );
-void 			_pico_free_memstream( picoMemStream_t *s );
-int				_pico_memstream_read( picoMemStream_t *s, void *buffer, int len );
-int				_pico_memstream_getc( picoMemStream_t *s );
-int				_pico_memstream_seek( picoMemStream_t *s, long offset, int origin );
-long			_pico_memstream_tell( picoMemStream_t *s );
-#define			_pico_memstream_eof( _pico_memstream )		((_pico_memstream)->flag & PICO_IOEOF)
-#define			_pico_memstream_error( _pico_memstream )	((_pico_memstream)->flag & PICO_IOERR)
-
-/* end marker */
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/* -----------------------------------------------------------------------------
+
+PicoModel Library
+
+Copyright (c) 2002, Randy Reddig & seaw0lf
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+Redistributions of source code must retain the above copyright notice, this list
+of conditions and the following disclaimer.
+
+Redistributions in binary form must reproduce the above copyright notice, this
+list of conditions and the following disclaimer in the documentation and/or
+other materials provided with the distribution.
+
+Neither the names of the copyright holders nor the names of its contributors may
+be used to endorse or promote products derived from this software without
+specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+----------------------------------------------------------------------------- */
+
+
+
+/* marker */
+#ifndef PICOINTERNAL_H
+#define PICOINTERNAL_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+/* dependencies */
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <ctype.h>
+#include <math.h>
+
+#include "picomodel.h"
+
+
+/* os dependent replacements */
+#if WIN32 || _WIN32
+	#define _pico_stricmp stricmp
+	#define _pico_strnicmp strnicmp
+#else
+	#define _pico_stricmp strcasecmp
+	#define _pico_strnicmp strncasecmp
+#endif
+
+
+/* constants */
+#define	PICO_PI	3.14159265358979323846
+
+#define PICO_SEEK_SET    0
+#define PICO_SEEK_CUR    1
+#define PICO_SEEK_END    2
+
+#define PICO_IOEOF	1
+#define PICO_IOERR	2
+
+/* types */
+typedef struct picoParser_s
+{
+	char	*buffer;
+	int		 bufSize;
+	char	*token;
+	int		 tokenSize;
+	int		 tokenMax;
+	char	*cursor;
+	char	*max;
+	int		 curLine;
+}
+picoParser_t;
+
+typedef struct picoMemStream_s
+{
+	picoByte_t	*buffer;
+	int			bufSize;
+	picoByte_t	*curPos;
+	int			flag;
+}
+picoMemStream_t;
+
+
+/* variables */
+extern const picoModule_t	*picoModules[];
+
+extern void					*(*_pico_ptr_malloc)( size_t );
+extern void					(*_pico_ptr_free)( void* );
+extern void					(*_pico_ptr_load_file)( char*, unsigned char**, int* );
+extern void					(*_pico_ptr_free_file)( void* );
+extern void					(*_pico_ptr_print)( int, const char* );
+
+
+
+/* prototypes */
+
+/* memory */
+void			*_pico_alloc( size_t size );
+void			*_pico_calloc( size_t num, size_t size );
+void			*_pico_realloc( void **ptr, size_t oldSize, size_t newSize );
+char 			*_pico_clone_alloc( const char *str );
+void			_pico_free( void *ptr );
+
+/* files */
+void			_pico_load_file( char *name, unsigned char **buffer, int *bufSize );
+void			_pico_free_file( void *buffer );
+
+/* strings */
+void			_pico_first_token( char *str );
+char			*_pico_strltrim( char *str );
+char			*_pico_strrtrim( char *str );
+int				_pico_strchcount( char *str, int ch );
+void 			_pico_printf( int level, const char *format, ... );
+char			*_pico_stristr( char *str, const char *substr );
+void			_pico_unixify( char *path );
+int				_pico_nofname( const char *path, char *dest, int destSize );
+const char *_pico_nopath( const char *path );
+char			*_pico_setfext( char *path, const char *ext );
+int				_pico_getline( char *buf, int bufsize, char *dest, int destsize );
+char			*_pico_strlwr( char *str );
+
+/* vectors */
+void 			_pico_zero_bounds( picoVec3_t mins, picoVec3_t maxs );
+void 			_pico_expand_bounds( picoVec3_t p, picoVec3_t mins, picoVec3_t maxs );
+void 			_pico_zero_vec( picoVec3_t vec );
+void 			_pico_zero_vec2( picoVec2_t vec );
+void 			_pico_zero_vec4( picoVec4_t vec );
+void 			_pico_set_vec( picoVec3_t v, float a, float b, float c );
+void 			_pico_set_vec4( picoVec4_t v, float a, float b, float c, float d );
+void			_pico_set_color( picoColor_t c, int r, int g, int b, int a );
+void 			_pico_copy_color( picoColor_t src, picoColor_t dest );
+void 			_pico_copy_vec( picoVec3_t src, picoVec3_t dest );
+void 			_pico_copy_vec2( picoVec2_t src, picoVec2_t dest );
+picoVec_t		_pico_normalize_vec( picoVec3_t vec );
+void			_pico_add_vec( picoVec3_t a, picoVec3_t b, picoVec3_t dest );
+void			_pico_subtract_vec( picoVec3_t a, picoVec3_t b, picoVec3_t dest );
+picoVec_t		_pico_dot_vec( picoVec3_t a, picoVec3_t b );
+void			_pico_cross_vec( picoVec3_t a, picoVec3_t b, picoVec3_t dest );
+picoVec_t		_pico_calc_plane( picoVec4_t plane, picoVec3_t a, picoVec3_t b, picoVec3_t c );
+void 			_pico_scale_vec( picoVec3_t v, float scale, picoVec3_t dest );
+void 			_pico_scale_vec4( picoVec4_t v, float scale, picoVec4_t dest );
+
+/* endian */
+int 			_pico_big_long( int src );
+short 			_pico_big_short( short src );
+float			_pico_big_float( float src );
+
+int 			_pico_little_long( int src );
+short 			_pico_little_short( short src );
+float 			_pico_little_float( float src );
+
+/* pico ascii parser */
+picoParser_t 	*_pico_new_parser( picoByte_t *buffer, int bufSize );
+void 			_pico_free_parser( picoParser_t *p );
+int				_pico_parse_ex( picoParser_t *p, int allowLFs, int handleQuoted );
+char 			*_pico_parse_first( picoParser_t *p );
+char 			*_pico_parse( picoParser_t *p, int allowLFs );
+void 			_pico_parse_skip_rest( picoParser_t *p );
+int				_pico_parse_skip_braced( picoParser_t *p );
+int 			_pico_parse_check( picoParser_t *p, int allowLFs, char *str );
+int 			_pico_parse_checki( picoParser_t *p, int allowLFs, char *str );
+int 			_pico_parse_int( picoParser_t *p, int *out );
+int 			_pico_parse_int_def( picoParser_t *p, int *out, int def );
+int 			_pico_parse_float( picoParser_t *p, float *out );
+int 			_pico_parse_float_def( picoParser_t *p, float *out, float def );
+int 			_pico_parse_double( picoParser_t *p, double *out );
+int 			_pico_parse_double_def( picoParser_t *p, double *out, double def );
+int 			_pico_parse_vec( picoParser_t *p, picoVec3_t out);
+int 			_pico_parse_vec_def( picoParser_t *p, picoVec3_t out, picoVec3_t def);
+int 			_pico_parse_vec2( picoParser_t *p, picoVec2_t out );
+int 			_pico_parse_vec2_def( picoParser_t *p, picoVec2_t out, picoVec2_t def );
+int 			_pico_parse_vec4( picoParser_t *p, picoVec4_t out);
+int 			_pico_parse_vec4_def( picoParser_t *p, picoVec4_t out, picoVec4_t def);
+
+/* pico memory stream */
+picoMemStream_t	*_pico_new_memstream( picoByte_t *buffer, int bufSize );
+void 			_pico_free_memstream( picoMemStream_t *s );
+int				_pico_memstream_read( picoMemStream_t *s, void *buffer, int len );
+int				_pico_memstream_getc( picoMemStream_t *s );
+int				_pico_memstream_seek( picoMemStream_t *s, long offset, int origin );
+long			_pico_memstream_tell( picoMemStream_t *s );
+#define			_pico_memstream_eof( _pico_memstream )		((_pico_memstream)->flag & PICO_IOEOF)
+#define			_pico_memstream_error( _pico_memstream )	((_pico_memstream)->flag & PICO_IOERR)
+
+/* end marker */
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: libs/picomodel/picomodel.c
===================================================================
--- libs/picomodel/picomodel.c	(revision 3603)
+++ libs/picomodel/picomodel.c	(working copy)
@@ -1,2292 +1,2292 @@
-/* -----------------------------------------------------------------------------
-
-PicoModel Library
-
-Copyright (c) 2002, Randy Reddig & seaw0lf
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-Redistributions of source code must retain the above copyright notice, this list
-of conditions and the following disclaimer.
-
-Redistributions in binary form must reproduce the above copyright notice, this
-list of conditions and the following disclaimer in the documentation and/or
-other materials provided with the distribution.
-
-Neither the names of the copyright holders nor the names of its contributors may
-be used to endorse or promote products derived from this software without
-specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
------------------------------------------------------------------------------ */
-
-
-
-/* marker */
-#define PICOMODEL_C
-
-
-
-/* dependencies */
-#include "picointernal.h"
-
-
-
-/*
-PicoInit()
-initializes the picomodel library
-*/
-
-int PicoInit( void )
-{
-	/* successfully initialized -sea */
-	return 1;
-}
-
-
-
-/*
-PicoShutdown()
-shuts the pico model library down
-*/
-
-void PicoShutdown( void )
-{
-	/* do something interesting here in the future */
-	return;
-}
-
-
-
-/*
-PicoError()
-returns last picomodel error code (see PME_* defines)
-*/
-
-int PicoError( void )
-{
-	/* todo: do something here */
-	return 0;
-}
-
-
-
-/*
-PicoSetMallocFunc()
-sets the ptr to the malloc function
-*/
-
-void PicoSetMallocFunc( void *(*func)( size_t ) )
-{
-	if( func != NULL )
-		_pico_ptr_malloc = func;
-}
-
-
-
-/*
-PicoSetFreeFunc()
-sets the ptr to the free function
-*/
-
-void PicoSetFreeFunc( void (*func)( void* ) )
-{
-	if( func != NULL )
-		_pico_ptr_free = func;
-}
-
-
-
-/*
-PicoSetLoadFileFunc()
-sets the ptr to the file load function
-*/
-
-void PicoSetLoadFileFunc( void (*func)( char*, unsigned char**, int* ) )
-{
-	if( func != NULL )
-		_pico_ptr_load_file = func;
-}
-
-
-
-/*
-PicoSetFreeFileFunc()
-sets the ptr to the free function
-*/
-
-void PicoSetFreeFileFunc( void (*func)( void* ) )
-{
-	if( func != NULL )
-		_pico_ptr_free_file = func;
-}
-
-
-
-/*
-PicoSetPrintFunc()
-sets the ptr to the print function
-*/
-
-void PicoSetPrintFunc( void (*func)( int, const char* ) )
-{
-	if( func != NULL )
-		_pico_ptr_print = func;
-}
-
-
-
-picoModel_t	*PicoModuleLoadModel( const picoModule_t* pm, char* fileName, picoByte_t* buffer, int bufSize, int frameNum )
-{
-	char				*modelFileName, *remapFileName;
-
-	/* see whether this module can load the model file or not */
-	if( pm->canload( fileName, buffer, bufSize ) == PICO_PMV_OK )
-	{
-		/* use loader provided by module to read the model data */
-		picoModel_t* model = pm->load( fileName, frameNum, buffer, bufSize );
-		if( model == NULL )
-		{
-			_pico_free_file( buffer );
-			return NULL;
-		}
-		
-		/* assign pointer to file format module */
-		model->module = pm;
-		
-		/* get model file name */
-		modelFileName = PicoGetModelFileName( model );
-		
-		/* apply model remappings from <model>.remap */
-		if( strlen( modelFileName ) )
-		{
-			/* alloc copy of model file name */
-			remapFileName = _pico_alloc( strlen( modelFileName ) + 20 );
-			if( remapFileName != NULL )
-			{
-				/* copy model file name and change extension */
-				strcpy( remapFileName, modelFileName );
-				_pico_setfext( remapFileName, "remap" );
-
-				/* try to remap model; we don't handle the result */
-				PicoRemapModel( model, remapFileName );
-
-				/* free the remap file name string */
-				_pico_free( remapFileName );
-			}
-		}
-
-		return model;
-	}
-
-	return NULL;
-}
-
-/*
-PicoLoadModel()
-the meat and potatoes function
-*/
-
-picoModel_t	*PicoLoadModel( char *fileName, int frameNum )
-{
-	const picoModule_t	**modules, *pm;
-	picoModel_t			*model;
-	picoByte_t			*buffer;
-	int					bufSize;
-
-	
-	/* init */
-	model = NULL;
-	
-	/* make sure we've got a file name */
-	if( fileName == NULL )
-	{
-		_pico_printf( PICO_ERROR, "PicoLoadModel: No filename given (fileName == NULL)" );
-		return NULL;
-	}
-	
-	/* load file data (buffer is allocated by host app) */
-	_pico_load_file( fileName, &buffer, &bufSize );
-	if( bufSize < 0 )
-	{
-		_pico_printf( PICO_ERROR, "PicoLoadModel: Failed loading model %s", fileName );
-		return NULL;
-	}
-
-	/* get ptr to list of supported modules */
-	modules = PicoModuleList( NULL );
-	
-	/* run it through the various loader functions and try */
-	/* to find a loader that fits the given file data */
-	for( ; *modules != NULL; modules++ )
-	{
-		/* get module */
-		pm = *modules;
-		
-		/* sanity check */
-		if( pm == NULL)
-			break;
-
-		/* module must be able to load */
-		if( pm->canload == NULL || pm->load == NULL )
-			continue;
-	
-		model = PicoModuleLoadModel(pm, fileName, buffer, bufSize, frameNum);
-		if(model != NULL)
-		{
-			/* model was loaded, so break out of loop */
-			break;
-		}
-	}
-	
-	/* free memory used by file buffer */
-	if( buffer)
-		_pico_free_file( buffer );
-
-	/* return */
-	return model;
-}
-
-picoModel_t	*PicoModuleLoadModelStream( const picoModule_t* module, void* inputStream, PicoInputStreamReadFunc inputStreamRead, size_t streamLength, int frameNum )
-{
-	picoModel_t			*model;
-	picoByte_t			*buffer;
-	int					bufSize;
-
-	
-	/* init */
-	model = NULL;
-	
-	if( inputStream == NULL )
-	{
-		_pico_printf( PICO_ERROR, "PicoLoadModel: invalid input stream (inputStream == NULL)" );
-		return NULL;
-	}
-	
-	if( inputStreamRead == NULL )
-	{
-		_pico_printf( PICO_ERROR, "PicoLoadModel: invalid input stream (inputStreamRead == NULL)" );
-		return NULL;
-	}
-	
-	buffer = _pico_alloc(streamLength + 1);
-
-	bufSize = (int)inputStreamRead(inputStream, buffer, streamLength);
-	buffer[bufSize] = '\0';
-
-	{
-		// dummy filename
-		char fileName[128];
-		fileName[0] = '.';
-		strncpy(fileName + 1, module->defaultExts[0], 126);
-		fileName[127] = '\0';
-		model = PicoModuleLoadModel(module, fileName, buffer, bufSize, frameNum);
-	}
-	
-  if(model != 0)
-  {
-	  _pico_free(buffer);
-  }
-
-	/* return */
-	return model;
-}
-
-
-/* ----------------------------------------------------------------------------
-models
----------------------------------------------------------------------------- */
-
-/*
-PicoNewModel()
-creates a new pico model
-*/
-
-picoModel_t *PicoNewModel( void )
-{
-	picoModel_t	*model;
-	
-	/* allocate */
-	model = _pico_alloc( sizeof(picoModel_t) );
-	if( model == NULL )
-		return NULL;
-
-	/* clear */
-	memset( model,0,sizeof(picoModel_t) );
-	
-	/* model set up */
-	_pico_zero_bounds( model->mins,model->maxs );
-
-	/* set initial frame count to 1 -sea */
-	model->numFrames = 1;
-
-	/* return ptr to new model */
-	return model;
-}
-
-
-
-/*
-PicoFreeModel()
-frees a model and all associated data
-*/
-
-void PicoFreeModel( picoModel_t *model )
-{
-	int				i;
-	
-
-	/* sanity check */
-	if( model == NULL )
-		return;
-	
-	/* free bits */
-	if( model->name )
-		_pico_free( model->name );
-	
-	if( model->fileName )
-		_pico_free( model->fileName );
-	
-	/* free shaders */
-	for( i = 0; i < model->numShaders; i++ )
-		PicoFreeShader( model->shader[ i ] );
-	free( model->shader );
-	
-	/* free surfaces */
-	for( i = 0; i < model->numSurfaces; i++ )
-		PicoFreeSurface( model->surface[ i ] );
-	free( model->surface );
-	
-	/* free the model */
-	_pico_free( model );
-}
-
-
-
-/*
-PicoAdjustModel()
-adjusts a models's memory allocations to handle the requested sizes.
-will always grow, never shrink
-*/
-
-int PicoAdjustModel( picoModel_t *model, int numShaders, int numSurfaces )
-{
-	/* dummy check */
-	if( model == NULL )
-		return 0;
-	
-	/* bare minimums */
-	/* sea: null surface/shader fix (1s=>0s) */
-	if( numShaders < 0 )
-		numShaders = 0;
-	if( numSurfaces < 0 )
-		numSurfaces = 0;
-
-	/* additional shaders? */
-	while( numShaders > model->maxShaders )
-	{
-		model->maxShaders += PICO_GROW_SHADERS;
-		if( !_pico_realloc( (void *) &model->shader, model->numShaders * sizeof( *model->shader ), model->maxShaders * sizeof( *model->shader ) ) )
-			return 0;
-	}
-	
-	/* set shader count to higher */
-	if( numShaders > model->numShaders )
-		model->numShaders = numShaders;
-	
-	/* additional surfaces? */
-	while( numSurfaces > model->maxSurfaces )
-	{
-		model->maxSurfaces += PICO_GROW_SURFACES;
-		if( !_pico_realloc( (void *) &model->surface, model->numSurfaces * sizeof( *model->surface ), model->maxSurfaces * sizeof( *model->surface ) ) )
-			return 0;
-	}
-	
-	/* set shader count to higher */
-	if( numSurfaces > model->numSurfaces )
-		model->numSurfaces = numSurfaces;
-	
-	/* return ok */
-	return 1;
-}
-
-
-
-/* ----------------------------------------------------------------------------
-shaders
----------------------------------------------------------------------------- */
-
-/*
-PicoNewShader()
-creates a new pico shader and returns its index. -sea
-*/
-
-picoShader_t *PicoNewShader( picoModel_t *model )
-{
-	picoShader_t	*shader;
-	
-	
-	/* allocate and clear */
-	shader = _pico_alloc( sizeof(picoShader_t) );
-	if( shader == NULL )
-		return NULL;
-	memset( shader, 0, sizeof(picoShader_t) );
-	
-	/* attach it to the model */
-	if( model != NULL )
-	{
-		/* adjust model */
-		if( !PicoAdjustModel( model, model->numShaders + 1, 0 ) )
-		{
-			_pico_free( shader );
-			return NULL;
-		}
-		
-		/* attach */
-		model->shader[ model->numShaders - 1 ] = shader;
-		shader->model = model;
-	}
-	
-	/* setup default shader colors */
-	_pico_set_color( shader->ambientColor,0,0,0,0 );
-	_pico_set_color( shader->diffuseColor,255,255,255,1 );
-	_pico_set_color( shader->specularColor,0,0,0,0 );
-	
-	/* no need to do this, but i do it anyway */
-	shader->transparency = 0;
-	shader->shininess = 0;
-	
-	/* return the newly created shader */
-	return shader;
-}
-
-
-
-/*
-PicoFreeShader()
-frees a shader and all associated data -sea
-*/
-
-void PicoFreeShader( picoShader_t *shader )
-{
-	/* dummy check */
-	if( shader == NULL )
-		return;
-	
-	/* free bits */
-	if( shader->name )
-		_pico_free( shader->name );
-	if( shader->mapName )
-		_pico_free( shader->mapName );
-	
-	/* free the shader */
-	_pico_free( shader );
-}
-
-
-
-/*
-PicoFindShader()
-finds a named shader in a model
-*/
-
-picoShader_t *PicoFindShader( picoModel_t *model, char *name, int caseSensitive )
-{
-	int		i;
-	
-	
-	/* sanity checks */
-	if( model == NULL || name == NULL )	/* sea: null name fix */
-		return NULL;
-	
-	/* walk list */
-	for( i = 0; i < model->numShaders; i++ )
-	{
-		/* skip null shaders or shaders with null names */
-		if( model->shader[ i ] == NULL ||
-			model->shader[ i ]->name == NULL )
-			continue;
-
-		/* compare the shader name with name we're looking for */
-		if( caseSensitive )
-		{
-			if( !strcmp( name, model->shader[ i ]->name ) )
-				return model->shader[ i ];
-		}
-		else if( !_pico_stricmp( name, model->shader[ i ]->name ) )
-				return model->shader[ i ];
-	}
-	
-	/* named shader not found */
-	return NULL;
-}
-
-
-
-/* ----------------------------------------------------------------------------
-surfaces
----------------------------------------------------------------------------- */
-
-/*
-PicoNewSurface()
-creates a new pico surface
-*/
-
-picoSurface_t *PicoNewSurface( picoModel_t *model )
-{
-	picoSurface_t	*surface;
-	char surfaceName[64];
-	
-	/* allocate and clear */
-	surface = _pico_alloc( sizeof( *surface ) );
-	if( surface == NULL )
-		return NULL;
-	memset( surface, 0, sizeof( *surface ) );
-	
-	/* attach it to the model */
-	if( model != NULL )
-	{
-		/* adjust model */
-		if( !PicoAdjustModel( model, 0, model->numSurfaces + 1 ) )
-		{
-			_pico_free( surface );
-			return NULL;
-		}
-		
-		/* attach */
-		model->surface[ model->numSurfaces - 1 ] = surface;
-		surface->model = model;
-		
-		/* set default name */
-		sprintf( surfaceName, "Unnamed_%d", model->numSurfaces );
-		PicoSetSurfaceName( surface, surfaceName );
-	}
-	
-	/* return */
-	return surface;
-}
-
-
-
-/*
-PicoFreeSurface()
-frees a surface and all associated data
-*/
-void PicoFreeSurface( picoSurface_t *surface )
-{
-	int		i;
-	
-	
-	/* dummy check */
-	if( surface == NULL )
-		return;
-	
-	/* free bits */
-	_pico_free( surface->xyz );
-	_pico_free( surface->normal );
-	_pico_free( surface->smoothingGroup );
-	_pico_free( surface->index );
-	_pico_free( surface->faceNormal );
-
-  if( surface->name )
-    _pico_free( surface->name );
-	
-	/* free arrays */
-	for( i = 0; i < surface->numSTArrays; i++ )
-		_pico_free( surface->st[ i ] );
-	free( surface->st );
-	for( i = 0; i < surface->numColorArrays; i++ )
-		_pico_free( surface->color[ i ] );
-	free( surface->color );
-	
-	/* free the surface */
-	_pico_free( surface );
-}
-
-
-
-/*
-PicoAdjustSurface()
-adjusts a surface's memory allocations to handle the requested sizes.
-will always grow, never shrink
-*/
-
-int PicoAdjustSurface( picoSurface_t *surface, int numVertexes, int numSTArrays, int numColorArrays, int numIndexes, int numFaceNormals )
-{
-	int		i;
-	
-	
-	/* dummy check */
-	if( surface == NULL )
-		return 0;
-	
-	/* bare minimums */
-	if( numVertexes < 1 )
-		numVertexes = 1;
-	if( numSTArrays < 1 )
-		numSTArrays = 1;
-	if( numColorArrays < 1 )
-		numColorArrays = 1;
-	if( numIndexes < 1 )
-		numIndexes = 1;
-	
-	/* additional vertexes? */
-	while( numVertexes > surface->maxVertexes ) /* fix */
-	{
-		surface->maxVertexes += PICO_GROW_VERTEXES;
-		if( !_pico_realloc( (void *) &surface->xyz, surface->numVertexes * sizeof( *surface->xyz ), surface->maxVertexes * sizeof( *surface->xyz ) ) )
-			return 0;
-		if( !_pico_realloc( (void *) &surface->normal, surface->numVertexes * sizeof( *surface->normal ), surface->maxVertexes * sizeof( *surface->normal ) ) )
-			return 0;
-		if( !_pico_realloc( (void *) &surface->smoothingGroup, surface->numVertexes * sizeof( *surface->smoothingGroup ), surface->maxVertexes * sizeof( *surface->smoothingGroup ) ) )
-			return 0;
-		for( i = 0; i < surface->numSTArrays; i++ )
-			if( !_pico_realloc( (void*) &surface->st[ i ], surface->numVertexes * sizeof( *surface->st[ i ] ), surface->maxVertexes * sizeof( *surface->st[ i ] ) ) )
-			return 0;
-		for( i = 0; i < surface->numColorArrays; i++ )
-			if( !_pico_realloc( (void*) &surface->color[ i ], surface->numVertexes * sizeof( *surface->color[ i ] ), surface->maxVertexes * sizeof( *surface->color[ i ] ) ) )
-			return 0;
-	}
-	
-	/* set vertex count to higher */
-	if( numVertexes > surface->numVertexes )
-		surface->numVertexes = numVertexes;
-	
-	/* additional st arrays? */
-	while( numSTArrays > surface->maxSTArrays ) /* fix */
-	{
-		surface->maxSTArrays += PICO_GROW_ARRAYS;
-		if( !_pico_realloc( (void*) &surface->st, surface->numSTArrays * sizeof( *surface->st ), surface->maxSTArrays * sizeof( *surface->st ) ) )
-			return 0;
-		while( surface->numSTArrays < numSTArrays )
-		{
-			surface->st[ surface->numSTArrays ] = _pico_alloc( surface->maxVertexes * sizeof( *surface->st[ 0 ] ) );
-			memset( surface->st[ surface->numSTArrays ], 0, surface->maxVertexes * sizeof( *surface->st[ 0 ] ) );
-			surface->numSTArrays++;
-		}
-	}
-	
-	/* additional color arrays? */
-	while( numColorArrays > surface->maxColorArrays ) /* fix */
-	{
-		surface->maxColorArrays += PICO_GROW_ARRAYS;
-		if( !_pico_realloc( (void*) &surface->color, surface->numColorArrays * sizeof( *surface->color ), surface->maxColorArrays * sizeof( *surface->color ) ) )
-			return 0;
-		while( surface->numColorArrays < numColorArrays )
-		{
-			surface->color[ surface->numColorArrays ] = _pico_alloc( surface->maxVertexes * sizeof( *surface->color[ 0 ] ) );
-			memset( surface->color[ surface->numColorArrays ], 0, surface->maxVertexes * sizeof( *surface->color[ 0 ] ) );
-			surface->numColorArrays++;
-		}
-	}
-	
-	/* additional indexes? */
-	while( numIndexes > surface->maxIndexes ) /* fix */
-	{
-		surface->maxIndexes += PICO_GROW_INDEXES;
-		if( !_pico_realloc( (void*) &surface->index, surface->numIndexes * sizeof( *surface->index ), surface->maxIndexes * sizeof( *surface->index ) ) )
-			return 0;
-	}
-	
-	/* set index count to higher */
-	if( numIndexes > surface->numIndexes )
-		surface->numIndexes = numIndexes;
-
-	/* additional face normals? */
-	while( numFaceNormals > surface->maxFaceNormals ) /* fix */
-	{
-		surface->maxFaceNormals += PICO_GROW_FACES;
-		if( !_pico_realloc( (void *) &surface->faceNormal, surface->numFaceNormals * sizeof( *surface->faceNormal ), surface->maxFaceNormals * sizeof( *surface->faceNormal ) ) )
-			return 0;
-	}
-
-	/* set face normal count to higher */
-	if( numFaceNormals > surface->numFaceNormals )
-		surface->numFaceNormals = numFaceNormals;
-
-	/* return ok */
-	return 1;
-}
-
-
-/* PicoFindSurface:
- *   Finds first matching named surface in a model.
- */
-picoSurface_t *PicoFindSurface(
-	picoModel_t *model, char *name, int caseSensitive )
-{
-	int		i;
-
-	/* sanity check */
-	if( model == NULL || name == NULL )
-		return NULL;
-	
-	/* walk list */
-	for( i = 0; i < model->numSurfaces; i++ )
-	{
-		/* skip null surfaces or surfaces with null names */
-		if( model->surface[ i ] == NULL ||
-			model->surface[ i ]->name == NULL )
-			continue;
-
-		/* compare the surface name with name we're looking for */
-		if (caseSensitive) {
-			if( !strcmp(name,model->surface[ i ]->name) )
-				return model->surface[ i ];
-		} else {
-			if( !_pico_stricmp(name,model->surface[ i ]->name) )
-				return model->surface[ i ];
-		}
-	}
-	/* named surface not found */
-	return NULL;
-}
-
-
-
-/*----------------------------------------------------------------------------
-  PicoSet*() Setter Functions
-----------------------------------------------------------------------------*/
-
-void PicoSetModelName( picoModel_t *model, char *name )
-{
-	if( model == NULL || name == NULL )
-		return;
-	if( model->name != NULL )
-		_pico_free( model->name );
-
-	model->name = _pico_clone_alloc( name );
-}
-
-
-
-void PicoSetModelFileName( picoModel_t *model, char *fileName )
-{
-	if( model == NULL || fileName == NULL )
-		return;
-	if( model->fileName != NULL )
-		_pico_free( model->fileName );
-
-	model->fileName = _pico_clone_alloc( fileName );
-}
-
-
-
-void PicoSetModelFrameNum( picoModel_t *model, int frameNum )
-{
-	if( model == NULL )
-		return;
-	model->frameNum = frameNum;
-}
-
-
-
-void PicoSetModelNumFrames( picoModel_t *model, int numFrames )
-{
-	if( model == NULL )
-		return;
-	model->numFrames = numFrames;
-}
-
-
-
-void PicoSetModelData( picoModel_t *model, void *data )
-{
-	if( model == NULL )
-		return;
-	model->data = data;
-}
-
-
-
-void PicoSetShaderName( picoShader_t *shader, char *name )
-{
-	if( shader == NULL || name == NULL )
-		return;
-	if( shader->name != NULL )
-		_pico_free( shader->name );
-
-	shader->name = _pico_clone_alloc( name );
-}
-
-
-
-void PicoSetShaderMapName( picoShader_t *shader, char *mapName )
-{
-	if( shader == NULL || mapName == NULL )
-		return;
-	if( shader->mapName != NULL )
-		_pico_free( shader->mapName );
-
-	shader->mapName = _pico_clone_alloc( mapName );
-}
-
-
-
-void PicoSetShaderAmbientColor( picoShader_t *shader, picoColor_t color )
-{
-	if( shader == NULL || color == NULL )
-		return;
-	shader->ambientColor[ 0 ] = color[ 0 ];
-	shader->ambientColor[ 1 ] = color[ 1 ];
-	shader->ambientColor[ 2 ] = color[ 2 ];
-	shader->ambientColor[ 3 ] = color[ 3 ];
-}
-
-
-
-void PicoSetShaderDiffuseColor( picoShader_t *shader, picoColor_t color )
-{
-	if( shader == NULL || color == NULL )
-		return;
-	shader->diffuseColor[ 0 ] = color[ 0 ];
-	shader->diffuseColor[ 1 ] = color[ 1 ];
-	shader->diffuseColor[ 2 ] = color[ 2 ];
-	shader->diffuseColor[ 3 ] = color[ 3 ];
-}
-
-
-
-void PicoSetShaderSpecularColor( picoShader_t *shader, picoColor_t color )
-{
-	if( shader == NULL || color == NULL )
-		return;
-	shader->specularColor[ 0 ] = color[ 0 ];
-	shader->specularColor[ 1 ] = color[ 1 ];
-	shader->specularColor[ 2 ] = color[ 2 ];
-	shader->specularColor[ 3 ] = color[ 3 ];
-}
-
-
-
-void PicoSetShaderTransparency( picoShader_t *shader, float value )
-{
-	if( shader == NULL )
-		return;
-	shader->transparency = value;
-
-	/* cap to 0..1 range */
-	if (shader->transparency < 0.0)
-		shader->transparency = 0.0;
-	if (shader->transparency > 1.0)
-		shader->transparency = 1.0;
-}
-
-
-
-void PicoSetShaderShininess( picoShader_t *shader, float value )
-{
-	if( shader == NULL )
-		return;
-	shader->shininess = value;
-
-	/* cap to 0..127 range */
-	if (shader->shininess < 0.0)
-		shader->shininess = 0.0;
-	if (shader->shininess > 127.0)
-		shader->shininess = 127.0;
-}
-
-
-
-void PicoSetSurfaceData( picoSurface_t *surface, void *data )
-{
-	if( surface == NULL )
-		return;
-	surface->data = data;
-}
-
-
-
-void PicoSetSurfaceType( picoSurface_t *surface, picoSurfaceType_t type )
-{
-	if( surface == NULL )
-		return;
-	surface->type = type;
-}
-
-
-
-void PicoSetSurfaceName( picoSurface_t *surface, char *name )
-{
-	if( surface == NULL || name == NULL )
-		return;
-	if( surface->name != NULL )
-		_pico_free( surface->name );
-
-	surface->name = _pico_clone_alloc( name );
-}
-
-
-
-void PicoSetSurfaceShader( picoSurface_t *surface, picoShader_t *shader )
-{
-	if( surface == NULL )
-		return;
-	surface->shader = shader;
-}
-
-
-
-void PicoSetSurfaceXYZ( picoSurface_t *surface, int num, picoVec3_t xyz )
-{
-	if( surface == NULL || num < 0 || xyz == NULL )
-		return;
-	if( !PicoAdjustSurface( surface, num + 1, 0, 0, 0, 0 ) )
-		return;
-	_pico_copy_vec( xyz, surface->xyz[ num ] );
-	if( surface->model != NULL )
-		_pico_expand_bounds( xyz, surface->model->mins, surface->model->maxs );
-}
-
-
-
-void PicoSetSurfaceNormal( picoSurface_t *surface, int num, picoVec3_t normal )
-{
-	if( surface == NULL || num < 0 || normal == NULL )
-		return;
-	if( !PicoAdjustSurface( surface, num + 1, 0, 0, 0, 0 ) )
-		return;
-	_pico_copy_vec( normal, surface->normal[ num ] );
-}
-
-
-
-void PicoSetSurfaceST( picoSurface_t *surface, int array, int num, picoVec2_t st )
-{
-	if( surface == NULL || num < 0 || st == NULL )
-		return;
-	if( !PicoAdjustSurface( surface, num + 1, array + 1, 0, 0, 0 ) )
-		return;
-	surface->st[ array ][ num ][ 0 ] = st[ 0 ];
-	surface->st[ array ][ num ][ 1 ] = st[ 1 ];
-}
-
-
-
-void PicoSetSurfaceColor( picoSurface_t *surface, int array, int num, picoColor_t color )
-{
-	if( surface == NULL || num < 0 || color == NULL )
-		return;
-	if( !PicoAdjustSurface( surface, num + 1, 0, array + 1, 0, 0 ) )
-		return;
-	surface->color[ array ][ num ][ 0 ] = color[ 0 ];
-	surface->color[ array ][ num ][ 1 ] = color[ 1 ];
-	surface->color[ array ][ num ][ 2 ] = color[ 2 ];
-	surface->color[ array ][ num ][ 3 ] = color[ 3 ];
-}
-
-
-
-void PicoSetSurfaceIndex( picoSurface_t *surface, int num, picoIndex_t index )
-{
-	if( surface == NULL || num < 0 )
-		return;
-	if( !PicoAdjustSurface( surface, 0, 0, 0, num + 1, 0 ) )
-		return;
-	surface->index[ num ] = index;
-}
-
-
-
-void PicoSetSurfaceIndexes( picoSurface_t *surface, int num, picoIndex_t *index, int count )
-{
-	if( num < 0 || index == NULL || count < 1 )
-		return;
-	if( !PicoAdjustSurface( surface, 0, 0, 0, num + count, 0 ) )
-		return;
-	memcpy( &surface->index[ num ], index, count * sizeof( surface->index[ num ] ) );
-}
-
-
-
-void PicoSetFaceNormal( picoSurface_t *surface, int num, picoVec3_t normal )
-{
-	if( surface == NULL || num < 0 || normal == NULL )
-		return;
-	if( !PicoAdjustSurface( surface, 0, 0, 0, 0, num + 1 ) )
-		return;
-	_pico_copy_vec( normal, surface->faceNormal[ num ] );
-}
-
-
-void PicoSetSurfaceSmoothingGroup( picoSurface_t *surface, int num, picoIndex_t smoothingGroup )
-{
-	if( num < 0 )
-		return;
-	if( !PicoAdjustSurface( surface, num + 1, 0, 0, 0, 0 ) )
-		return;
-	surface->smoothingGroup[ num ] = smoothingGroup;
-}
-
-
-void PicoSetSurfaceSpecial( picoSurface_t *surface, int num, int special )
-{
-	if( surface == NULL || num < 0 || num >= PICO_MAX_SPECIAL )
-		return;
-	surface->special[ num ] = special;
-}
-
-
-
-/*----------------------------------------------------------------------------
-  PicoGet*() Getter Functions
-----------------------------------------------------------------------------*/
-
-char *PicoGetModelName( picoModel_t *model )
-{
-	if( model == NULL )
-		return NULL;
-	if( model->name == NULL)
-		return (char*) "";
-	return model->name;
-}
-
-
-
-char *PicoGetModelFileName( picoModel_t *model )
-{
-	if( model == NULL )
-		return NULL;
-	if( model->fileName == NULL)
-		return (char*) "";
-	return model->fileName;
-}
-
-
-
-int PicoGetModelFrameNum( picoModel_t *model )
-{
-	if( model == NULL )
-		return 0;
-	return model->frameNum;
-}
-
-
-
-int PicoGetModelNumFrames( picoModel_t *model )
-{
-	if( model == NULL )
-		return 0;
-	return model->numFrames;
-}
-
-
-
-void *PicoGetModelData( picoModel_t *model )
-{
-	if( model == NULL )
-		return NULL;
-	return model->data;
-}
-
-
-
-int PicoGetModelNumShaders( picoModel_t *model )
-{
-	if( model == NULL )
-		return 0;
-	return model->numShaders;
-}
-
-
-
-picoShader_t *PicoGetModelShader( picoModel_t *model, int num )
-{
-	/* a few sanity checks */
-	if( model == NULL )
-		return NULL;
-	if( model->shader == NULL)
-		return NULL;
-	if( num < 0 || num >= model->numShaders )
-		return NULL;
-	
-	/* return the shader */
-	return model->shader[ num ];
-}
-
-
-
-int PicoGetModelNumSurfaces( picoModel_t *model )
-{
-	if( model == NULL )
-		return 0;
-	return model->numSurfaces;
-}
-
-
-
-picoSurface_t *PicoGetModelSurface( picoModel_t *model, int num )
-{
-	/* a few sanity checks */
-	if( model == NULL )
-		return NULL;
-	if( model->surface == NULL)
-		return NULL;
-	if( num < 0 || num >= model->numSurfaces )
-		return NULL;
-	
-	/* return the surface */
-	return model->surface[ num ];
-}
-
-
-
-int PicoGetModelTotalVertexes( picoModel_t *model )
-{
-	int		i, count;
-	
-	
-	if( model == NULL )
-		return 0;
-	if( model->surface == NULL )
-		return 0;
-	
-	count = 0;
-	for( i = 0; i < model->numSurfaces; i++ )
-		 count += PicoGetSurfaceNumVertexes( model->surface[ i ] );
-	
-	return count;
-}
-
-
-
-int PicoGetModelTotalIndexes( picoModel_t *model )
-{
-	int		i, count;
-	
-	
-	if( model == NULL )
-		return 0;
-	if( model->surface == NULL )
-		return 0;
-	
-	count = 0;
-	for( i = 0; i < model->numSurfaces; i++ )
-		 count += PicoGetSurfaceNumIndexes( model->surface[ i ] );
-	
-	return count;
-}
-
-
-
-char *PicoGetShaderName( picoShader_t *shader )
-{
-	if( shader == NULL )
-		return NULL;
-	if( shader->name == NULL)
-		return (char*) "";
-	return shader->name;
-}
-
-
-
-char *PicoGetShaderMapName( picoShader_t *shader )
-{
-	if( shader == NULL )
-		return NULL;
-	if( shader->mapName == NULL)
-		return (char*) "";
-	return shader->mapName;
-}
-
-
-
-picoByte_t *PicoGetShaderAmbientColor( picoShader_t *shader )
-{
-	if( shader == NULL )
-		return NULL;
-	return shader->ambientColor;
-}
-
-
-
-picoByte_t *PicoGetShaderDiffuseColor( picoShader_t *shader )
-{
-	if( shader == NULL )
-		return NULL;
-	return shader->diffuseColor;
-}
-
-
-
-picoByte_t *PicoGetShaderSpecularColor( picoShader_t *shader )
-{
-	if( shader == NULL )
-		return NULL;
-	return shader->specularColor;
-}
-
-
-
-float PicoGetShaderTransparency( picoShader_t *shader )
-{
-	if( shader == NULL )
-		return 0.0f;
-	return shader->transparency;
-}
-
-
-
-float PicoGetShaderShininess( picoShader_t *shader )
-{
-	if( shader == NULL )
-		return 0.0f;
-	return shader->shininess;
-}
-
-
-
-void *PicoGetSurfaceData( picoSurface_t *surface )
-{
-	if( surface == NULL )
-		return NULL;
-	return surface->data;
-}
-
-
-
-picoSurfaceType_t PicoGetSurfaceType( picoSurface_t *surface )
-{
-	if( surface == NULL )
-		return PICO_BAD;
-	return surface->type;
-}
-
-
-
-char *PicoGetSurfaceName( picoSurface_t *surface )
-{
-	if( surface == NULL )
-		return NULL;
-	if( surface->name == NULL )
-		return (char*) "";
-	return surface->name;
-}
-
-
-
-picoShader_t *PicoGetSurfaceShader( picoSurface_t *surface )
-{
-	if( surface == NULL )
-		return NULL;
-	return surface->shader;
-}
-
-
-
-int PicoGetSurfaceNumVertexes( picoSurface_t *surface )
-{
-	if( surface == NULL )
-		return 0;
-	return surface->numVertexes;
-}
-
-
-
-picoVec_t *PicoGetSurfaceXYZ( picoSurface_t *surface, int num )
-{
-	if( surface == NULL || num < 0 || num > surface->numVertexes )
-		return NULL;
-	return surface->xyz[ num ];
-}
-
-
-
-picoVec_t *PicoGetSurfaceNormal( picoSurface_t *surface, int num )
-{
-	if( surface == NULL || num < 0 || num > surface->numVertexes )
-		return NULL;
-	return surface->normal[ num ];
-}
-
-
-
-picoVec_t *PicoGetSurfaceST( picoSurface_t *surface, int array, int num  )
-{
-	if( surface == NULL || array < 0 || array > surface->numSTArrays || num < 0 || num > surface->numVertexes )
-		return NULL;
-	return surface->st[ array ][ num ];
-}
-
-
-
-picoByte_t *PicoGetSurfaceColor( picoSurface_t *surface, int array, int num )
-{
-	if( surface == NULL || array < 0 || array > surface->numColorArrays || num < 0 || num > surface->numVertexes )
-		return NULL;
-	return surface->color[ array ][ num ];
-}
-
-
-
-int PicoGetSurfaceNumIndexes( picoSurface_t *surface )
-{
-	if( surface == NULL )
-		return 0;
-	return surface->numIndexes;
-}
-
-
-
-picoIndex_t PicoGetSurfaceIndex( picoSurface_t *surface, int num )
-{
-	if( surface == NULL || num < 0 || num > surface->numIndexes )
-		return 0;
-	return surface->index[ num ];
-}
-
-
-
-picoIndex_t *PicoGetSurfaceIndexes( picoSurface_t *surface, int num )
-{
-	if( surface == NULL || num < 0 || num > surface->numIndexes )
-		return NULL;
-	return &surface->index[ num ];
-}
-
-
-picoVec_t *PicoGetFaceNormal( picoSurface_t *surface, int num )
-{
-	if( surface == NULL || num < 0 || num > surface->numFaceNormals )
-		return NULL;
-	return surface->faceNormal[ num ];
-}
-
-picoIndex_t PicoGetSurfaceSmoothingGroup( picoSurface_t *surface, int num )
-{
-	if( surface == NULL || num < 0 || num > surface->numVertexes )
-		return -1;
-	return surface->smoothingGroup[ num ];
-}
-
-
-int PicoGetSurfaceSpecial( picoSurface_t *surface, int num )
-{
-	if( surface == NULL || num < 0 || num >= PICO_MAX_SPECIAL )
-		return 0;
-	return surface->special[ num ];
-}
-
-
-
-/* ----------------------------------------------------------------------------
-hashtable related functions
----------------------------------------------------------------------------- */
-
-/* hashtable code for faster vertex lookups */
-//#define HASHTABLE_SIZE 32768 // 2048			/* power of 2, use & */
-#define HASHTABLE_SIZE 7919 // 32749 // 2039 	/* prime, use % */
-
-int PicoGetHashTableSize( void )
-{
-	return HASHTABLE_SIZE;
-}
-
-#define HASH_USE_EPSILON
-
-#ifdef HASH_USE_EPSILON
-#define HASH_XYZ_EPSILON					0.01f
-#define HASH_XYZ_EPSILONSPACE_MULTIPLIER	1.f / HASH_XYZ_EPSILON
-#define HASH_ST_EPSILON						0.0001f
-#define HASH_NORMAL_EPSILON					0.02f
-#endif
-
-unsigned int PicoVertexCoordGenerateHash( picoVec3_t xyz )
-{
-	unsigned int hash = 0;
-
-#ifndef HASH_USE_EPSILON
-	hash += ~(*((unsigned int*) &xyz[ 0 ]) << 15);
-	hash ^= (*((unsigned int*) &xyz[ 0 ]) >> 10);
-	hash += (*((unsigned int*) &xyz[ 1 ]) << 3);
-	hash ^= (*((unsigned int*) &xyz[ 1 ]) >> 6);
-	hash += ~(*((unsigned int*) &xyz[ 2 ]) << 11);
-	hash ^= (*((unsigned int*) &xyz[ 2 ]) >> 16);
-#else
-	picoVec3_t xyz_epsilonspace;
-
-	_pico_scale_vec( xyz, HASH_XYZ_EPSILONSPACE_MULTIPLIER, xyz_epsilonspace );
-	xyz_epsilonspace[ 0 ] = (double)floor(xyz_epsilonspace[ 0 ]);
-	xyz_epsilonspace[ 1 ] = (double)floor(xyz_epsilonspace[ 1 ]);
-	xyz_epsilonspace[ 2 ] = (double)floor(xyz_epsilonspace[ 2 ]);
-
-	hash += ~(*((unsigned int*) &xyz_epsilonspace[ 0 ]) << 15);
-	hash ^= (*((unsigned int*) &xyz_epsilonspace[ 0 ]) >> 10);
-	hash += (*((unsigned int*) &xyz_epsilonspace[ 1 ]) << 3);
-	hash ^= (*((unsigned int*) &xyz_epsilonspace[ 1 ]) >> 6);
-	hash += ~(*((unsigned int*) &xyz_epsilonspace[ 2 ]) << 11);
-	hash ^= (*((unsigned int*) &xyz_epsilonspace[ 2 ]) >> 16);
-#endif
-
-	//hash = hash & (HASHTABLE_SIZE-1);
-	hash = hash % (HASHTABLE_SIZE);
-	return hash;
-}
-
-picoVertexCombinationHash_t **PicoNewVertexCombinationHashTable( void )
-{
-	picoVertexCombinationHash_t	**hashTable = _pico_alloc( HASHTABLE_SIZE * sizeof(picoVertexCombinationHash_t*) );
-
-	memset( hashTable, 0, HASHTABLE_SIZE * sizeof(picoVertexCombinationHash_t*) );
-
-	return hashTable;
-}
-
-void PicoFreeVertexCombinationHashTable( picoVertexCombinationHash_t **hashTable )
-{
-	int							i;
-	picoVertexCombinationHash_t	*vertexCombinationHash;
-	picoVertexCombinationHash_t *nextVertexCombinationHash;
-
-	/* dummy check */
-	if (hashTable == NULL)
-		return;
-
-	for( i = 0; i < HASHTABLE_SIZE; i++ )
-	{
-		if (hashTable[ i ])
-		{
-			nextVertexCombinationHash = NULL;
-
-			for( vertexCombinationHash = hashTable[ i ]; vertexCombinationHash; vertexCombinationHash = nextVertexCombinationHash )
-			{
-				nextVertexCombinationHash = vertexCombinationHash->next;
-				if (vertexCombinationHash->data != NULL)
-				{
-					_pico_free( vertexCombinationHash->data );
-				}
-				_pico_free( vertexCombinationHash );
-			}
-		}
-	}
-
-	_pico_free( hashTable );
-}
-
-picoVertexCombinationHash_t *PicoFindVertexCombinationInHashTable( picoVertexCombinationHash_t **hashTable, picoVec3_t xyz, picoVec3_t normal, picoVec3_t st, picoColor_t color )
-{
-	unsigned int				hash;
-	picoVertexCombinationHash_t	*vertexCombinationHash;
-
-	/* dumy check */
-	if (hashTable == NULL || xyz == NULL || normal == NULL || st == NULL || color == NULL )
-		return NULL;
-
-	hash = PicoVertexCoordGenerateHash( xyz );
-
-	for( vertexCombinationHash = hashTable[ hash ]; vertexCombinationHash; vertexCombinationHash = vertexCombinationHash->next )
-	{
-#ifndef HASH_USE_EPSILON
-		/* check xyz */
-		if( (vertexCombinationHash->vcd.xyz[ 0 ] != xyz[ 0 ] || vertexCombinationHash->vcd.xyz[ 1 ] != xyz[ 1 ] || vertexCombinationHash->vcd.xyz[ 2 ] != xyz[ 2 ]) )
-			continue;
-
-		/* check normal */
-		if( (vertexCombinationHash->vcd.normal[ 0 ] != normal[ 0 ] || vertexCombinationHash->vcd.normal[ 1 ] != normal[ 1 ] || vertexCombinationHash->vcd.normal[ 2 ] != normal[ 2 ]) )
-			continue;
-		
-		/* check st */
-		if( vertexCombinationHash->vcd.st[ 0 ] != st[ 0 ] || vertexCombinationHash->vcd.st[ 1 ] != st[ 1 ] )
-			continue;
-#else
-		/* check xyz */
-		if( ( fabs(xyz[ 0 ] - vertexCombinationHash->vcd.xyz[ 0 ]) ) > HASH_XYZ_EPSILON ||
-			( fabs(xyz[ 1 ] - vertexCombinationHash->vcd.xyz[ 1 ]) ) > HASH_XYZ_EPSILON ||
-			( fabs(xyz[ 2 ] - vertexCombinationHash->vcd.xyz[ 2 ]) ) > HASH_XYZ_EPSILON )
-			continue;
-
-		/* check normal */
-		if( ( fabs(normal[ 0 ] - vertexCombinationHash->vcd.normal[ 0 ]) ) > HASH_NORMAL_EPSILON ||
-			( fabs(normal[ 1 ] - vertexCombinationHash->vcd.normal[ 1 ]) ) > HASH_NORMAL_EPSILON ||
-			( fabs(normal[ 2 ] - vertexCombinationHash->vcd.normal[ 2 ]) ) > HASH_NORMAL_EPSILON )
-			continue;
-		
-		/* check st */
-		if( ( fabs(st[ 0 ] - vertexCombinationHash->vcd.st[ 0 ]) ) > HASH_ST_EPSILON ||
-			( fabs(st[ 1 ] - vertexCombinationHash->vcd.st[ 1 ]) ) > HASH_ST_EPSILON )
-			continue;
-#endif
-
-		/* check color */
-		if( *((int*) vertexCombinationHash->vcd.color) != *((int*) color) )
-			continue;
-
-		/* gotcha */
-		return vertexCombinationHash;
-	}
-
-	return NULL;
-}
-
-picoVertexCombinationHash_t *PicoAddVertexCombinationToHashTable( picoVertexCombinationHash_t **hashTable, picoVec3_t xyz, picoVec3_t normal, picoVec3_t st, picoColor_t color, picoIndex_t index )
-{
-	unsigned int				hash;
-	picoVertexCombinationHash_t	*vertexCombinationHash;
-
-	/* dumy check */
-	if (hashTable == NULL || xyz == NULL || normal == NULL || st == NULL || color == NULL )
-		return NULL;
-
-	vertexCombinationHash = _pico_alloc( sizeof(picoVertexCombinationHash_t) );
-
-	if (!vertexCombinationHash)
-		return NULL;
-
-	hash = PicoVertexCoordGenerateHash( xyz );
-
-	_pico_copy_vec( xyz, vertexCombinationHash->vcd.xyz );
-	_pico_copy_vec( normal, vertexCombinationHash->vcd.normal );
-	_pico_copy_vec2( st, vertexCombinationHash->vcd.st );
-	_pico_copy_color( color, vertexCombinationHash->vcd.color );
-	vertexCombinationHash->index = index;
-	vertexCombinationHash->data = NULL;
-	vertexCombinationHash->next = hashTable[ hash ];
-	hashTable[ hash ] = vertexCombinationHash;
-
-	return vertexCombinationHash;
-}
-
-/* ----------------------------------------------------------------------------
-specialized routines
----------------------------------------------------------------------------- */
-
-/*
-PicoFindSurfaceVertex()
-finds a vertex matching the set parameters
-fixme: needs non-naive algorithm
-*/
-
-int PicoFindSurfaceVertexNum( picoSurface_t *surface, picoVec3_t xyz, picoVec3_t normal, int numSTs, picoVec2_t *st, int numColors, picoColor_t *color, picoIndex_t smoothingGroup)
-{
-	int		i, j;
-	
-	
-	/* dummy check */
-	if( surface == NULL || surface->numVertexes <= 0 )
-		return -1;
-	
-	/* walk vertex list */
-	for( i = 0; i < surface->numVertexes; i++ )
-	{
-		/* check xyz */
-		if( xyz != NULL && (surface->xyz[ i ][ 0 ] != xyz[ 0 ] || surface->xyz[ i ][ 1 ] != xyz[ 1 ] || surface->xyz[ i ][ 2 ] != xyz[ 2 ]) )
-			continue;
-		
-		/* check normal */
-		if( normal != NULL && (surface->normal[ i ][ 0 ] != normal[ 0 ] || surface->normal[ i ][ 1 ] != normal[ 1 ] || surface->normal[ i ][ 2 ] != normal[ 2 ]) )
-			continue;
-		
-		/* check normal */
-		if( surface->smoothingGroup[ i ] != smoothingGroup )
-			continue;
-
-    /* check st */
-		if( numSTs > 0 && st != NULL )
-		{
-			for( j = 0; j < numSTs; j++ )
-			{
-				if( surface->st[ j ][ i ][ 0 ] != st[ j ][ 0 ] || surface->st[ j ][ i ][ 1 ] != st[ j ][ 1 ] )
-					break;
-			}
-			if( j != numSTs )
-				continue;
-		}
-		
-		/* check color */
-		if( numColors > 0 && color != NULL )
-		{
-			for( j = 0; j < numSTs; j++ )
-			{
-				if( *((int*) surface->color[ j ]) != *((int*) color[ j ]) )
-					break;
-			}
-			if( j != numColors )
-				continue;
-		}
-		
-		/* vertex matches */
-		return i;
-	}
-	
-	/* nada */
-	return -1;
-}
-
-
-
-
-typedef struct _IndexArray IndexArray;
-struct _IndexArray
-{
-	picoIndex_t* data;
-	picoIndex_t* last;
-};
-
-void indexarray_push_back(IndexArray* self, picoIndex_t value)
-{
-	*self->last++ = value;
-}
-
-size_t indexarray_size(IndexArray* self)
-{
-	return self->last - self->data;
-}
-
-void indexarray_reserve(IndexArray* self, size_t size)
-{
-	self->data = self->last = _pico_calloc(size, sizeof(picoIndex_t));
-}
-
-void indexarray_clear(IndexArray* self)
-{
-	_pico_free(self->data);
-}
-
-typedef struct _BinaryTreeNode BinaryTreeNode;
-struct _BinaryTreeNode
-{
-	picoIndex_t left;
-	picoIndex_t right;
-};
-
-typedef struct _BinaryTree BinaryTree;
-struct _BinaryTree
-{
-	BinaryTreeNode* data;
-	BinaryTreeNode* last;
-};
-
-void binarytree_extend(BinaryTree* self)
-{
-	self->last->left = 0;
-	self->last->right = 0;
-	++self->last;
-}
-
-size_t binarytree_size(BinaryTree* self)
-{
-	return self->last - self->data;
-}
-
-void binarytree_reserve(BinaryTree* self, size_t size)
-{
-	self->data = self->last = _pico_calloc(size, sizeof(BinaryTreeNode));
-}
-
-void binarytree_clear(BinaryTree* self)
-{
-	_pico_free(self->data);
-}
-
-typedef int (*LessFunc)(void*, picoIndex_t, picoIndex_t);
-
-typedef struct _UniqueIndices UniqueIndices;
-struct _UniqueIndices
-{
-	BinaryTree tree;
-	IndexArray indices;
-	LessFunc lessFunc;
-	void* lessData;
-};
-
-size_t UniqueIndices_size(UniqueIndices* self)
-{
-  return binarytree_size(&self->tree);
-}
-
-void UniqueIndices_reserve(UniqueIndices* self, size_t size)
-{
-	binarytree_reserve(&self->tree, size);
-	indexarray_reserve(&self->indices, size);
-}
-
-void UniqueIndices_init(UniqueIndices* self, LessFunc lessFunc, void* lessData)
-{
-	self->lessFunc = lessFunc;
-	self->lessData = lessData;
-}
-
-void UniqueIndices_destroy(UniqueIndices* self)
-{
-	binarytree_clear(&self->tree);
-	indexarray_clear(&self->indices);
-}
-
-
-picoIndex_t UniqueIndices_find_or_insert(UniqueIndices* self, picoIndex_t value)
-{
-	picoIndex_t index = 0;
-
-	for(;;)
-	{
-		if(self->lessFunc(self->lessData, value, self->indices.data[index]))
-		{
-			BinaryTreeNode* node = self->tree.data + index;
-			if(node->left != 0)
-			{
-				index = node->left;
-				continue;
-			}
-			else
-			{
-				node->left = (picoIndex_t)binarytree_size(&self->tree);
-				binarytree_extend(&self->tree);
-				indexarray_push_back(&self->indices, value);
-				return node->left;
-			}
-		}
-		if(self->lessFunc(self->lessData, self->indices.data[index], value))
-		{
-			BinaryTreeNode* node = self->tree.data + index;
-			if(node->right != 0)
-			{
-				index = node->right;
-				continue;
-			}
-			else
-			{
-				node->right = (picoIndex_t)binarytree_size(&self->tree);
-				binarytree_extend(&self->tree);
-				indexarray_push_back(&self->indices, value);
-				return node->right;
-			}
-		}
-
-		return index;
-	}
-}
-
-picoIndex_t UniqueIndices_insert(UniqueIndices* self, picoIndex_t value)
-{
-	if(self->tree.data == self->tree.last)
-	{
-		binarytree_extend(&self->tree);
-		indexarray_push_back(&self->indices, value);
-		return 0;
-    }
-	else
-	{
-		return UniqueIndices_find_or_insert(self, value);
-	}
-}
-
-typedef struct picoSmoothVertices_s picoSmoothVertices_t;
-struct picoSmoothVertices_s
-{
-	picoVec3_t* xyz;
-	picoIndex_t* smoothingGroups;
-};
-
-int lessSmoothVertex(void* data, picoIndex_t first, picoIndex_t second)
-{
-	picoSmoothVertices_t* smoothVertices = data;
-	
-	if(smoothVertices->xyz[first][0] != smoothVertices->xyz[second][0])
-	{
-		return smoothVertices->xyz[first][0] < smoothVertices->xyz[second][0];
-	}
-	if(smoothVertices->xyz[first][1] != smoothVertices->xyz[second][1])
-	{
-		return smoothVertices->xyz[first][1] < smoothVertices->xyz[second][1];
-	}
-	if(smoothVertices->xyz[first][2] != smoothVertices->xyz[second][2])
-	{
-		return smoothVertices->xyz[first][2] < smoothVertices->xyz[second][2];
-	}
-	if(smoothVertices->smoothingGroups[first] != smoothVertices->smoothingGroups[second])
-	{
-		return smoothVertices->smoothingGroups[first] < smoothVertices->smoothingGroups[second];
-	}
-	return 0;
-}
-
-void _pico_vertices_combine_shared_normals(picoVec3_t* xyz, picoIndex_t* smoothingGroups, picoVec3_t* normals, picoIndex_t numVertices)
-{
-	UniqueIndices vertices;
-	IndexArray indices;
-	picoSmoothVertices_t smoothVertices = { xyz, smoothingGroups };
-	UniqueIndices_init(&vertices, lessSmoothVertex, &smoothVertices);
-	UniqueIndices_reserve(&vertices, numVertices);
-	indexarray_reserve(&indices, numVertices);
-
-
-	{
-		picoIndex_t i = 0;
-		for(; i < numVertices; ++i)
-		{
-			size_t size = UniqueIndices_size(&vertices);
-			picoIndex_t index = UniqueIndices_insert(&vertices, i);
-			if((size_t)index != size)
-			{
-				double* normal = normals[vertices.indices.data[index]];
-				_pico_add_vec(normal, normals[i], normal);
-			}
-			indexarray_push_back(&indices, index);
-		}
-	}
-
-	{
-		picoIndex_t maxIndex = 0;
-		picoIndex_t* i = indices.data;
-		for(; i != indices.last; ++i)
-		{
-			if(*i <= maxIndex)
-			{
-				_pico_copy_vec(normals[vertices.indices.data[*i]], normals[i - indices.data]);
-			}
-			else
-			{
-				maxIndex = *i;
-			}
-		}
-	}
-
-	UniqueIndices_destroy(&vertices);
-  indexarray_clear(&indices);
-}
-
-typedef picoVec3_t* picoNormalIter_t;
-typedef picoIndex_t* picoIndexIter_t;
-
-#define THE_CROSSPRODUCTS_OF_ANY_PAIR_OF_EDGES_OF_A_GIVEN_TRIANGLE_ARE_EQUAL 1
-
-void _pico_triangles_generate_weighted_normals(picoIndexIter_t first, picoIndexIter_t end, picoVec3_t* xyz, picoVec3_t* normals)
-{
-	for(; first != end; first += 3)
-	{
-#if (THE_CROSSPRODUCTS_OF_ANY_PAIR_OF_EDGES_OF_A_GIVEN_TRIANGLE_ARE_EQUAL)
-		picoVec3_t weightedNormal;
-		{
-			double* a = xyz[*(first + 0)];
-			double* b = xyz[*(first + 1)];
-			double* c = xyz[*(first + 2)];
-			picoVec3_t ba, ca;
-			_pico_subtract_vec( b, a, ba );
-			_pico_subtract_vec( c, a, ca );
-			_pico_cross_vec( ca, ba, weightedNormal );
-		}
-#endif
-		{
-			int j = 0;
-			for(; j < 3; ++j)
-			{
-				double* normal = normals[*(first + j)];
-#if (!THE_CROSSPRODUCTS_OF_ANY_PAIR_OF_EDGES_OF_A_GIVEN_TRIANGLE_ARE_EQUAL)
-				picoVec3_t weightedNormal;
-				{
-					double* a = xyz[*(first + ((j + 0) % 3))];
-					double* b = xyz[*(first + ((j + 1) % 3))];
-					double* c = xyz[*(first + ((j + 2) % 3))];
-					picoVec3_t ba, ca;
-					_pico_subtract_vec( b, a, ba );
-					_pico_subtract_vec( c, a, ca );
-					_pico_cross_vec( ca, ba, weightedNormal );
-				}
-#endif
-				_pico_add_vec(weightedNormal, normal, normal);
-			}
-		}
-	}
-}
-
-void _pico_normals_zero(picoNormalIter_t first, picoNormalIter_t last)
-{
-	for(; first != last; ++first)
-	{
-		_pico_zero_vec(*first);
-	}
-}
-
-void _pico_normals_normalize(picoNormalIter_t first, picoNormalIter_t last)
-{
-	for(; first != last; ++first)
-	{
-		_pico_normalize_vec(*first);
-	}
-}
-
-double _pico_length_vec( picoVec3_t vec )
-{
-	return sqrt( vec[ 0 ] * vec[ 0 ] + vec[ 1 ] * vec[ 1 ] + vec[ 2 ] * vec[ 2 ] );
-}
-
-#define NORMAL_UNIT_LENGTH_EPSILON 0.01
-#define FLOAT_EQUAL_EPSILON(f, other, epsilon) (fabs(f - other) < epsilon)
-
-int _pico_normal_is_unit_length(picoVec3_t normal)
-{
-	return FLOAT_EQUAL_EPSILON(_pico_length_vec(normal), 1.0, NORMAL_UNIT_LENGTH_EPSILON);
-}
-
-int _pico_normal_within_tolerance(picoVec3_t normal, picoVec3_t other)
-{
-	return _pico_dot_vec(normal, other) > 0.0f;
-}
-
-
-void _pico_normals_assign_generated_normals(picoNormalIter_t first, picoNormalIter_t last, picoNormalIter_t generated)
-{
-	for(; first != last; ++first, ++generated)
-	{
-		if(!_pico_normal_is_unit_length(*first) || !_pico_normal_within_tolerance(*first, *generated))
-		{
-			_pico_copy_vec(*generated, *first);
-		}
-	}
-}
-
-void PicoFixSurfaceNormals(picoSurface_t* surface)
-{
-	picoVec3_t* normals = (picoVec3_t*)_pico_calloc(surface->numVertexes, sizeof(picoVec3_t));
-
-	_pico_normals_zero(normals, normals + surface->numVertexes);
-
-	_pico_triangles_generate_weighted_normals(surface->index, surface->index + surface->numIndexes, surface->xyz, normals);
-	_pico_vertices_combine_shared_normals(surface->xyz, surface->smoothingGroup, normals, surface->numVertexes);
-
-	_pico_normals_normalize(normals, normals + surface->numVertexes);
-
-	_pico_normals_assign_generated_normals(surface->normal, surface->normal + surface->numVertexes, normals);
-
-	_pico_free(normals);
-}
-
-
-/*
-PicoRemapModel() - sea
-remaps model material/etc. information using the remappings
-contained in the given 'remapFile' (full path to the ascii file to open)
-returns 1 on success or 0 on error
-*/
-
-#define _prm_error_return \
-{ \
-	_pico_free_parser( p ); \
-	_pico_free_file( remapBuffer ); \
-	return 0; \
-}
-
-int PicoRemapModel( picoModel_t *model, char *remapFile )
-{
-	picoParser_t	*p;
-	picoByte_t		*remapBuffer;
-	int				remapBufSize;
-	
-	
-	/* sanity checks */
-	if( model == NULL || remapFile == NULL )
-		return 0;
-	
-	/* load remap file contents */
-	_pico_load_file( remapFile,&remapBuffer,&remapBufSize );
-	
-	/* check result */
-	if( remapBufSize == 0 )
-		return 1;	/* file is empty: no error */
-	if( remapBufSize < 0 )
-		return 0;	/* load failed: error */
-	
-	/* create a new pico parser */
-	p = _pico_new_parser( remapBuffer, remapBufSize );
-	if (p == NULL)
-	{
-		/* ram is really cheap nowadays... */
-		_prm_error_return;
-	}
-	
-	/* doo teh parse */
-	while( 1 )
-	{
-		/* get next token in remap file */
-		if (!_pico_parse( p,1 ))
-			break;
-
-		/* skip over c++ style comment lines */
-		if (!_pico_stricmp(p->token,"//"))
-		{
-			_pico_parse_skip_rest( p );
-			continue;
-		}
-		
-		/* block for quick material shader name remapping */
-		/* materials { "m" (=>|->|=) "s" } */
-		if( !_pico_stricmp(p->token, "materials" ) )
-		{
-			int level = 1;
-
-			/* check bracket */
-			if (!_pico_parse_check( p,1,"{" ))
-				_prm_error_return;
-
-			/* process assignments */
-			while( 1 )
-			{
-				picoShader_t	*shader;
-				char			*materialName;
-				
-				
-				/* get material name */
-				if (_pico_parse( p,1 ) == NULL) break;
-				if (!strlen(p->token)) continue;
-				materialName = _pico_clone_alloc( p->token );
-				if (materialName == NULL)
-					_prm_error_return;
-
-				/* handle levels */
-				if (p->token[0] == '{') level++;
-				if (p->token[0] == '}') level--;
-				if (!level) break;
-
-				/* get next token (assignment token or shader name) */
-				if (!_pico_parse( p,0 ))
-				{
-					_pico_free( materialName );
-					_prm_error_return;
-				}
-				/* skip assignment token (if present) */
-				if (!strcmp(p->token,"=>") ||
-					!strcmp(p->token,"->") ||
-					!strcmp(p->token,"="))
-				{
-					/* simply grab the next token */
-					if (!_pico_parse( p,0 ))
-					{
-						_pico_free( materialName );
-						_prm_error_return;
-					}
-				}
-				/* try to find material by name */
-				shader = PicoFindShader( model,materialName,0 );
-
-				/* we've found a material matching the name */
-				if (shader != NULL)
-				{
-					PicoSetShaderName( shader,p->token );
-				}
-				/* free memory used by material name */
-				_pico_free( materialName );
-
-				/* skip rest */
-				_pico_parse_skip_rest( p );
-			}
-		}
-		/* block for detailed single material remappings */
-		/* materials[ "m" ] { key data... } */
-		else if (!_pico_stricmp(p->token,"materials["))
-		{
-			picoShader_t *shader;
-			char *tempMaterialName;
-			int level = 1;
-
-			/* get material name */
-			if (!_pico_parse( p,0 ))
-				_prm_error_return;
-
-			/* temporary copy of material name */
-			tempMaterialName = _pico_clone_alloc( p->token );
-			if (tempMaterialName == NULL)
-				_prm_error_return;
-
-			/* check square closing bracket */
-			if (!_pico_parse_check( p,0,"]" ))
-				_prm_error_return;			
-
-			/* try to find material by name */
-			shader = PicoFindShader( model,tempMaterialName,0 );
-
-			/* free memory used by temporary material name */
-			_pico_free( tempMaterialName );
-
-			/* we haven't found a material matching the name */
-			/* so we simply skip the braced section now and */
-			/* continue parsing with the next main token */
-			if (shader == NULL)
-			{
-				_pico_parse_skip_braced( p );
-				continue;
-			}
-			/* check opening bracket */
-			if (!_pico_parse_check( p,1,"{" ))
-				_prm_error_return;
-
-			/* process material info keys */
-			while( 1 )
-			{
-				/* get key name */
-				if (_pico_parse( p,1 ) == NULL) break;
-				if (!strlen(p->token)) continue;
-
-				/* handle levels */
-				if (p->token[0] == '{') level++;
-				if (p->token[0] == '}') level--;
-				if (!level) break;
-
-				/* remap shader name */
-				if (!_pico_stricmp(p->token,"shader"))
-				{
-					if (!_pico_parse( p,0 )) _prm_error_return;
-					PicoSetShaderName( shader,p->token );
-				}
-				/* remap shader map name */
-				else if (!_pico_stricmp(p->token,"mapname"))
-				{
-					if (!_pico_parse( p,0 )) _prm_error_return;
-					PicoSetShaderMapName( shader,p->token );
-				}
-				/* remap shader's ambient color */
-				else if (!_pico_stricmp(p->token,"ambient"))
-				{
-					picoColor_t color;
-					picoVec3_t  v;
-
-					/* get vector from parser */
-					if (!_pico_parse_vec( p,v )) _prm_error_return;
-
-					/* store as color */
-					color[ 0 ] = (picoByte_t)v[ 0 ];
-					color[ 1 ] = (picoByte_t)v[ 1 ];
-					color[ 2 ] = (picoByte_t)v[ 2 ];
-
-					/* set new ambient color */
-					PicoSetShaderAmbientColor( shader,color );
-				}
-				/* remap shader's diffuse color */
-				else if (!_pico_stricmp(p->token,"diffuse"))
-				{
-					picoColor_t color;
-					picoVec3_t  v;
-
-					/* get vector from parser */
-					if (!_pico_parse_vec( p,v )) _prm_error_return;
-
-					/* store as color */
-					color[ 0 ] = (picoByte_t)v[ 0 ];
-					color[ 1 ] = (picoByte_t)v[ 1 ];
-					color[ 2 ] = (picoByte_t)v[ 2 ];
-
-					/* set new ambient color */
-					PicoSetShaderDiffuseColor( shader,color );
-				}
-				/* remap shader's specular color */
-				else if (!_pico_stricmp(p->token,"specular"))
-				{
-					picoColor_t color;
-					picoVec3_t  v;
-
-					/* get vector from parser */
-					if (!_pico_parse_vec( p,v )) _prm_error_return;
-
-					/* store as color */
-					color[ 0 ] = (picoByte_t)v[ 0 ];
-					color[ 1 ] = (picoByte_t)v[ 1 ];
-					color[ 2 ] = (picoByte_t)v[ 2 ];
-
-					/* set new ambient color */
-					PicoSetShaderSpecularColor( shader,color );
-				}
-				/* skip rest */
-				_pico_parse_skip_rest( p );
-			}
-		}
-		/* end 'materials[' */
-	}
-	
-	/* free both parser and file buffer */
-	_pico_free_parser( p );
-	_pico_free_file( remapBuffer );
-
-	/* return with success */
-	return 1;
-}
-
-
-/*
-PicoAddTriangleToModel() - jhefty
-A nice way to add individual triangles to the model.
-Chooses an appropriate surface based on the shader, or adds a new surface if necessary
-*/
-
-void PicoAddTriangleToModel( picoModel_t *model, picoVec3_t** xyz, picoVec3_t** normals, 
-							int numSTs, picoVec2_t **st, int numColors, picoColor_t **colors,
-							picoShader_t* shader, picoIndex_t* smoothingGroup )
-{
-	int i,j;
-	int vertDataIndex;
-	picoSurface_t* workSurface = NULL;
-
-	/* see if a surface already has the shader */
-	for ( i = 0 ; i < model->numSurfaces ; i++ )
-	{
-		workSurface = model->surface[i];
-		if ( workSurface->shader == shader )
-		{			
-			break;
-		}
-	}
-
-	/* no surface uses this shader yet, so create a new surface */
-	if ( !workSurface || i >=model->numSurfaces )
-	{
-		/* create a new surface in the model for the unique shader */
-		workSurface = PicoNewSurface(model);
-		if ( !workSurface )
-		{
-			_pico_printf ( PICO_ERROR , "Could not allocate a new surface!\n" );
-			return;
-		}
-
-		/* do surface setup */
-		PicoSetSurfaceType( workSurface, PICO_TRIANGLES );
-		PicoSetSurfaceName( workSurface, shader->name );
-		PicoSetSurfaceShader( workSurface, shader );
-	}
-
-	/* add the triangle data to the surface */
-	for ( i = 0 ; i < 3 ; i++ )	
-	{
-		/* get the next free spot in the index array */
-		int newVertIndex = PicoGetSurfaceNumIndexes ( workSurface );
-
-		/* get the index of the vertex that we're going to store at newVertIndex */
-		vertDataIndex = PicoFindSurfaceVertexNum ( workSurface , *xyz[i] , *normals[i] , numSTs , st[i] , numColors , colors[i], smoothingGroup[i]);
-
-		/* the vertex wasn't found, so create a new vertex in the pool from the data we have */
-		if ( vertDataIndex == -1 )
-		{			
-			/* find the next spot for a new vertex */
-			vertDataIndex = PicoGetSurfaceNumVertexes ( workSurface );			
-
-			/* assign the data to it */
-			PicoSetSurfaceXYZ ( workSurface ,vertDataIndex , *xyz[i] );
-			PicoSetSurfaceNormal ( workSurface , vertDataIndex , *normals[i] );			
-
-			/* make sure to copy over all available ST's and colors for the vertex */
-			for ( j = 0 ; j < numColors ; j++ )
-			{
-				PicoSetSurfaceColor( workSurface , j , vertDataIndex , colors[i][j] );
-			}
-			for ( j = 0 ; j < numSTs ; j++ )
-			{
-				PicoSetSurfaceST ( workSurface , j , vertDataIndex , st[i][j] );
-			}
-
-			PicoSetSurfaceSmoothingGroup ( workSurface , vertDataIndex , smoothingGroup[i] );			
-		}
-
-		/* add this vertex to the triangle */		
-		PicoSetSurfaceIndex ( workSurface , newVertIndex , vertDataIndex );
-	}
-}
+/* -----------------------------------------------------------------------------
+
+PicoModel Library
+
+Copyright (c) 2002, Randy Reddig & seaw0lf
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+Redistributions of source code must retain the above copyright notice, this list
+of conditions and the following disclaimer.
+
+Redistributions in binary form must reproduce the above copyright notice, this
+list of conditions and the following disclaimer in the documentation and/or
+other materials provided with the distribution.
+
+Neither the names of the copyright holders nor the names of its contributors may
+be used to endorse or promote products derived from this software without
+specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+----------------------------------------------------------------------------- */
+
+
+
+/* marker */
+#define PICOMODEL_C
+
+
+
+/* dependencies */
+#include "picointernal.h"
+
+
+
+/*
+PicoInit()
+initializes the picomodel library
+*/
+
+int PicoInit( void )
+{
+	/* successfully initialized -sea */
+	return 1;
+}
+
+
+
+/*
+PicoShutdown()
+shuts the pico model library down
+*/
+
+void PicoShutdown( void )
+{
+	/* do something interesting here in the future */
+	return;
+}
+
+
+
+/*
+PicoError()
+returns last picomodel error code (see PME_* defines)
+*/
+
+int PicoError( void )
+{
+	/* todo: do something here */
+	return 0;
+}
+
+
+
+/*
+PicoSetMallocFunc()
+sets the ptr to the malloc function
+*/
+
+void PicoSetMallocFunc( void *(*func)( size_t ) )
+{
+	if( func != NULL )
+		_pico_ptr_malloc = func;
+}
+
+
+
+/*
+PicoSetFreeFunc()
+sets the ptr to the free function
+*/
+
+void PicoSetFreeFunc( void (*func)( void* ) )
+{
+	if( func != NULL )
+		_pico_ptr_free = func;
+}
+
+
+
+/*
+PicoSetLoadFileFunc()
+sets the ptr to the file load function
+*/
+
+void PicoSetLoadFileFunc( void (*func)( char*, unsigned char**, int* ) )
+{
+	if( func != NULL )
+		_pico_ptr_load_file = func;
+}
+
+
+
+/*
+PicoSetFreeFileFunc()
+sets the ptr to the free function
+*/
+
+void PicoSetFreeFileFunc( void (*func)( void* ) )
+{
+	if( func != NULL )
+		_pico_ptr_free_file = func;
+}
+
+
+
+/*
+PicoSetPrintFunc()
+sets the ptr to the print function
+*/
+
+void PicoSetPrintFunc( void (*func)( int, const char* ) )
+{
+	if( func != NULL )
+		_pico_ptr_print = func;
+}
+
+
+
+picoModel_t	*PicoModuleLoadModel( const picoModule_t* pm, char* fileName, picoByte_t* buffer, int bufSize, int frameNum )
+{
+	char				*modelFileName, *remapFileName;
+
+	/* see whether this module can load the model file or not */
+	if( pm->canload( fileName, buffer, bufSize ) == PICO_PMV_OK )
+	{
+		/* use loader provided by module to read the model data */
+		picoModel_t* model = pm->load( fileName, frameNum, buffer, bufSize );
+		if( model == NULL )
+		{
+			_pico_free_file( buffer );
+			return NULL;
+		}
+		
+		/* assign pointer to file format module */
+		model->module = pm;
+		
+		/* get model file name */
+		modelFileName = PicoGetModelFileName( model );
+		
+		/* apply model remappings from <model>.remap */
+		if( strlen( modelFileName ) )
+		{
+			/* alloc copy of model file name */
+			remapFileName = _pico_alloc( strlen( modelFileName ) + 20 );
+			if( remapFileName != NULL )
+			{
+				/* copy model file name and change extension */
+				strcpy( remapFileName, modelFileName );
+				_pico_setfext( remapFileName, "remap" );
+
+				/* try to remap model; we don't handle the result */
+				PicoRemapModel( model, remapFileName );
+
+				/* free the remap file name string */
+				_pico_free( remapFileName );
+			}
+		}
+
+		return model;
+	}
+
+	return NULL;
+}
+
+/*
+PicoLoadModel()
+the meat and potatoes function
+*/
+
+picoModel_t	*PicoLoadModel( char *fileName, int frameNum )
+{
+	const picoModule_t	**modules, *pm;
+	picoModel_t			*model;
+	picoByte_t			*buffer;
+	int					bufSize;
+
+	
+	/* init */
+	model = NULL;
+	
+	/* make sure we've got a file name */
+	if( fileName == NULL )
+	{
+		_pico_printf( PICO_ERROR, "PicoLoadModel: No filename given (fileName == NULL)" );
+		return NULL;
+	}
+	
+	/* load file data (buffer is allocated by host app) */
+	_pico_load_file( fileName, &buffer, &bufSize );
+	if( bufSize < 0 )
+	{
+		_pico_printf( PICO_ERROR, "PicoLoadModel: Failed loading model %s", fileName );
+		return NULL;
+	}
+
+	/* get ptr to list of supported modules */
+	modules = PicoModuleList( NULL );
+	
+	/* run it through the various loader functions and try */
+	/* to find a loader that fits the given file data */
+	for( ; *modules != NULL; modules++ )
+	{
+		/* get module */
+		pm = *modules;
+		
+		/* sanity check */
+		if( pm == NULL)
+			break;
+
+		/* module must be able to load */
+		if( pm->canload == NULL || pm->load == NULL )
+			continue;
+	
+		model = PicoModuleLoadModel(pm, fileName, buffer, bufSize, frameNum);
+		if(model != NULL)
+		{
+			/* model was loaded, so break out of loop */
+			break;
+		}
+	}
+	
+	/* free memory used by file buffer */
+	if( buffer)
+		_pico_free_file( buffer );
+
+	/* return */
+	return model;
+}
+
+picoModel_t	*PicoModuleLoadModelStream( const picoModule_t* module, void* inputStream, PicoInputStreamReadFunc inputStreamRead, size_t streamLength, int frameNum )
+{
+	picoModel_t			*model;
+	picoByte_t			*buffer;
+	int					bufSize;
+
+	
+	/* init */
+	model = NULL;
+	
+	if( inputStream == NULL )
+	{
+		_pico_printf( PICO_ERROR, "PicoLoadModel: invalid input stream (inputStream == NULL)" );
+		return NULL;
+	}
+	
+	if( inputStreamRead == NULL )
+	{
+		_pico_printf( PICO_ERROR, "PicoLoadModel: invalid input stream (inputStreamRead == NULL)" );
+		return NULL;
+	}
+	
+	buffer = _pico_alloc(streamLength + 1);
+
+	bufSize = (int)inputStreamRead(inputStream, buffer, streamLength);
+	buffer[bufSize] = '\0';
+
+	{
+		// dummy filename
+		char fileName[128];
+		fileName[0] = '.';
+		strncpy(fileName + 1, module->defaultExts[0], 126);
+		fileName[127] = '\0';
+		model = PicoModuleLoadModel(module, fileName, buffer, bufSize, frameNum);
+	}
+	
+  if(model != 0)
+  {
+	  _pico_free(buffer);
+  }
+
+	/* return */
+	return model;
+}
+
+
+/* ----------------------------------------------------------------------------
+models
+---------------------------------------------------------------------------- */
+
+/*
+PicoNewModel()
+creates a new pico model
+*/
+
+picoModel_t *PicoNewModel( void )
+{
+	picoModel_t	*model;
+	
+	/* allocate */
+	model = _pico_alloc( sizeof(picoModel_t) );
+	if( model == NULL )
+		return NULL;
+
+	/* clear */
+	memset( model,0,sizeof(picoModel_t) );
+	
+	/* model set up */
+	_pico_zero_bounds( model->mins,model->maxs );
+
+	/* set initial frame count to 1 -sea */
+	model->numFrames = 1;
+
+	/* return ptr to new model */
+	return model;
+}
+
+
+
+/*
+PicoFreeModel()
+frees a model and all associated data
+*/
+
+void PicoFreeModel( picoModel_t *model )
+{
+	int				i;
+	
+
+	/* sanity check */
+	if( model == NULL )
+		return;
+	
+	/* free bits */
+	if( model->name )
+		_pico_free( model->name );
+	
+	if( model->fileName )
+		_pico_free( model->fileName );
+	
+	/* free shaders */
+	for( i = 0; i < model->numShaders; i++ )
+		PicoFreeShader( model->shader[ i ] );
+	free( model->shader );
+	
+	/* free surfaces */
+	for( i = 0; i < model->numSurfaces; i++ )
+		PicoFreeSurface( model->surface[ i ] );
+	free( model->surface );
+	
+	/* free the model */
+	_pico_free( model );
+}
+
+
+
+/*
+PicoAdjustModel()
+adjusts a models's memory allocations to handle the requested sizes.
+will always grow, never shrink
+*/
+
+int PicoAdjustModel( picoModel_t *model, int numShaders, int numSurfaces )
+{
+	/* dummy check */
+	if( model == NULL )
+		return 0;
+	
+	/* bare minimums */
+	/* sea: null surface/shader fix (1s=>0s) */
+	if( numShaders < 0 )
+		numShaders = 0;
+	if( numSurfaces < 0 )
+		numSurfaces = 0;
+
+	/* additional shaders? */
+	while( numShaders > model->maxShaders )
+	{
+		model->maxShaders += PICO_GROW_SHADERS;
+		if( !_pico_realloc( (void *) &model->shader, model->numShaders * sizeof( *model->shader ), model->maxShaders * sizeof( *model->shader ) ) )
+			return 0;
+	}
+	
+	/* set shader count to higher */
+	if( numShaders > model->numShaders )
+		model->numShaders = numShaders;
+	
+	/* additional surfaces? */
+	while( numSurfaces > model->maxSurfaces )
+	{
+		model->maxSurfaces += PICO_GROW_SURFACES;
+		if( !_pico_realloc( (void *) &model->surface, model->numSurfaces * sizeof( *model->surface ), model->maxSurfaces * sizeof( *model->surface ) ) )
+			return 0;
+	}
+	
+	/* set shader count to higher */
+	if( numSurfaces > model->numSurfaces )
+		model->numSurfaces = numSurfaces;
+	
+	/* return ok */
+	return 1;
+}
+
+
+
+/* ----------------------------------------------------------------------------
+shaders
+---------------------------------------------------------------------------- */
+
+/*
+PicoNewShader()
+creates a new pico shader and returns its index. -sea
+*/
+
+picoShader_t *PicoNewShader( picoModel_t *model )
+{
+	picoShader_t	*shader;
+	
+	
+	/* allocate and clear */
+	shader = _pico_alloc( sizeof(picoShader_t) );
+	if( shader == NULL )
+		return NULL;
+	memset( shader, 0, sizeof(picoShader_t) );
+	
+	/* attach it to the model */
+	if( model != NULL )
+	{
+		/* adjust model */
+		if( !PicoAdjustModel( model, model->numShaders + 1, 0 ) )
+		{
+			_pico_free( shader );
+			return NULL;
+		}
+		
+		/* attach */
+		model->shader[ model->numShaders - 1 ] = shader;
+		shader->model = model;
+	}
+	
+	/* setup default shader colors */
+	_pico_set_color( shader->ambientColor,0,0,0,0 );
+	_pico_set_color( shader->diffuseColor,255,255,255,1 );
+	_pico_set_color( shader->specularColor,0,0,0,0 );
+	
+	/* no need to do this, but i do it anyway */
+	shader->transparency = 0;
+	shader->shininess = 0;
+	
+	/* return the newly created shader */
+	return shader;
+}
+
+
+
+/*
+PicoFreeShader()
+frees a shader and all associated data -sea
+*/
+
+void PicoFreeShader( picoShader_t *shader )
+{
+	/* dummy check */
+	if( shader == NULL )
+		return;
+	
+	/* free bits */
+	if( shader->name )
+		_pico_free( shader->name );
+	if( shader->mapName )
+		_pico_free( shader->mapName );
+	
+	/* free the shader */
+	_pico_free( shader );
+}
+
+
+
+/*
+PicoFindShader()
+finds a named shader in a model
+*/
+
+picoShader_t *PicoFindShader( picoModel_t *model, char *name, int caseSensitive )
+{
+	int		i;
+	
+	
+	/* sanity checks */
+	if( model == NULL || name == NULL )	/* sea: null name fix */
+		return NULL;
+	
+	/* walk list */
+	for( i = 0; i < model->numShaders; i++ )
+	{
+		/* skip null shaders or shaders with null names */
+		if( model->shader[ i ] == NULL ||
+			model->shader[ i ]->name == NULL )
+			continue;
+
+		/* compare the shader name with name we're looking for */
+		if( caseSensitive )
+		{
+			if( !strcmp( name, model->shader[ i ]->name ) )
+				return model->shader[ i ];
+		}
+		else if( !_pico_stricmp( name, model->shader[ i ]->name ) )
+				return model->shader[ i ];
+	}
+	
+	/* named shader not found */
+	return NULL;
+}
+
+
+
+/* ----------------------------------------------------------------------------
+surfaces
+---------------------------------------------------------------------------- */
+
+/*
+PicoNewSurface()
+creates a new pico surface
+*/
+
+picoSurface_t *PicoNewSurface( picoModel_t *model )
+{
+	picoSurface_t	*surface;
+	char surfaceName[64];
+	
+	/* allocate and clear */
+	surface = _pico_alloc( sizeof( *surface ) );
+	if( surface == NULL )
+		return NULL;
+	memset( surface, 0, sizeof( *surface ) );
+	
+	/* attach it to the model */
+	if( model != NULL )
+	{
+		/* adjust model */
+		if( !PicoAdjustModel( model, 0, model->numSurfaces + 1 ) )
+		{
+			_pico_free( surface );
+			return NULL;
+		}
+		
+		/* attach */
+		model->surface[ model->numSurfaces - 1 ] = surface;
+		surface->model = model;
+		
+		/* set default name */
+		sprintf( surfaceName, "Unnamed_%d", model->numSurfaces );
+		PicoSetSurfaceName( surface, surfaceName );
+	}
+	
+	/* return */
+	return surface;
+}
+
+
+
+/*
+PicoFreeSurface()
+frees a surface and all associated data
+*/
+void PicoFreeSurface( picoSurface_t *surface )
+{
+	int		i;
+	
+	
+	/* dummy check */
+	if( surface == NULL )
+		return;
+	
+	/* free bits */
+	_pico_free( surface->xyz );
+	_pico_free( surface->normal );
+	_pico_free( surface->smoothingGroup );
+	_pico_free( surface->index );
+	_pico_free( surface->faceNormal );
+
+  if( surface->name )
+    _pico_free( surface->name );
+	
+	/* free arrays */
+	for( i = 0; i < surface->numSTArrays; i++ )
+		_pico_free( surface->st[ i ] );
+	free( surface->st );
+	for( i = 0; i < surface->numColorArrays; i++ )
+		_pico_free( surface->color[ i ] );
+	free( surface->color );
+	
+	/* free the surface */
+	_pico_free( surface );
+}
+
+
+
+/*
+PicoAdjustSurface()
+adjusts a surface's memory allocations to handle the requested sizes.
+will always grow, never shrink
+*/
+
+int PicoAdjustSurface( picoSurface_t *surface, int numVertexes, int numSTArrays, int numColorArrays, int numIndexes, int numFaceNormals )
+{
+	int		i;
+	
+	
+	/* dummy check */
+	if( surface == NULL )
+		return 0;
+	
+	/* bare minimums */
+	if( numVertexes < 1 )
+		numVertexes = 1;
+	if( numSTArrays < 1 )
+		numSTArrays = 1;
+	if( numColorArrays < 1 )
+		numColorArrays = 1;
+	if( numIndexes < 1 )
+		numIndexes = 1;
+	
+	/* additional vertexes? */
+	while( numVertexes > surface->maxVertexes ) /* fix */
+	{
+		surface->maxVertexes += PICO_GROW_VERTEXES;
+		if( !_pico_realloc( (void *) &surface->xyz, surface->numVertexes * sizeof( *surface->xyz ), surface->maxVertexes * sizeof( *surface->xyz ) ) )
+			return 0;
+		if( !_pico_realloc( (void *) &surface->normal, surface->numVertexes * sizeof( *surface->normal ), surface->maxVertexes * sizeof( *surface->normal ) ) )
+			return 0;
+		if( !_pico_realloc( (void *) &surface->smoothingGroup, surface->numVertexes * sizeof( *surface->smoothingGroup ), surface->maxVertexes * sizeof( *surface->smoothingGroup ) ) )
+			return 0;
+		for( i = 0; i < surface->numSTArrays; i++ )
+			if( !_pico_realloc( (void*) &surface->st[ i ], surface->numVertexes * sizeof( *surface->st[ i ] ), surface->maxVertexes * sizeof( *surface->st[ i ] ) ) )
+			return 0;
+		for( i = 0; i < surface->numColorArrays; i++ )
+			if( !_pico_realloc( (void*) &surface->color[ i ], surface->numVertexes * sizeof( *surface->color[ i ] ), surface->maxVertexes * sizeof( *surface->color[ i ] ) ) )
+			return 0;
+	}
+	
+	/* set vertex count to higher */
+	if( numVertexes > surface->numVertexes )
+		surface->numVertexes = numVertexes;
+	
+	/* additional st arrays? */
+	while( numSTArrays > surface->maxSTArrays ) /* fix */
+	{
+		surface->maxSTArrays += PICO_GROW_ARRAYS;
+		if( !_pico_realloc( (void*) &surface->st, surface->numSTArrays * sizeof( *surface->st ), surface->maxSTArrays * sizeof( *surface->st ) ) )
+			return 0;
+		while( surface->numSTArrays < numSTArrays )
+		{
+			surface->st[ surface->numSTArrays ] = _pico_alloc( surface->maxVertexes * sizeof( *surface->st[ 0 ] ) );
+			memset( surface->st[ surface->numSTArrays ], 0, surface->maxVertexes * sizeof( *surface->st[ 0 ] ) );
+			surface->numSTArrays++;
+		}
+	}
+	
+	/* additional color arrays? */
+	while( numColorArrays > surface->maxColorArrays ) /* fix */
+	{
+		surface->maxColorArrays += PICO_GROW_ARRAYS;
+		if( !_pico_realloc( (void*) &surface->color, surface->numColorArrays * sizeof( *surface->color ), surface->maxColorArrays * sizeof( *surface->color ) ) )
+			return 0;
+		while( surface->numColorArrays < numColorArrays )
+		{
+			surface->color[ surface->numColorArrays ] = _pico_alloc( surface->maxVertexes * sizeof( *surface->color[ 0 ] ) );
+			memset( surface->color[ surface->numColorArrays ], 0, surface->maxVertexes * sizeof( *surface->color[ 0 ] ) );
+			surface->numColorArrays++;
+		}
+	}
+	
+	/* additional indexes? */
+	while( numIndexes > surface->maxIndexes ) /* fix */
+	{
+		surface->maxIndexes += PICO_GROW_INDEXES;
+		if( !_pico_realloc( (void*) &surface->index, surface->numIndexes * sizeof( *surface->index ), surface->maxIndexes * sizeof( *surface->index ) ) )
+			return 0;
+	}
+	
+	/* set index count to higher */
+	if( numIndexes > surface->numIndexes )
+		surface->numIndexes = numIndexes;
+
+	/* additional face normals? */
+	while( numFaceNormals > surface->maxFaceNormals ) /* fix */
+	{
+		surface->maxFaceNormals += PICO_GROW_FACES;
+		if( !_pico_realloc( (void *) &surface->faceNormal, surface->numFaceNormals * sizeof( *surface->faceNormal ), surface->maxFaceNormals * sizeof( *surface->faceNormal ) ) )
+			return 0;
+	}
+
+	/* set face normal count to higher */
+	if( numFaceNormals > surface->numFaceNormals )
+		surface->numFaceNormals = numFaceNormals;
+
+	/* return ok */
+	return 1;
+}
+
+
+/* PicoFindSurface:
+ *   Finds first matching named surface in a model.
+ */
+picoSurface_t *PicoFindSurface(
+	picoModel_t *model, char *name, int caseSensitive )
+{
+	int		i;
+
+	/* sanity check */
+	if( model == NULL || name == NULL )
+		return NULL;
+	
+	/* walk list */
+	for( i = 0; i < model->numSurfaces; i++ )
+	{
+		/* skip null surfaces or surfaces with null names */
+		if( model->surface[ i ] == NULL ||
+			model->surface[ i ]->name == NULL )
+			continue;
+
+		/* compare the surface name with name we're looking for */
+		if (caseSensitive) {
+			if( !strcmp(name,model->surface[ i ]->name) )
+				return model->surface[ i ];
+		} else {
+			if( !_pico_stricmp(name,model->surface[ i ]->name) )
+				return model->surface[ i ];
+		}
+	}
+	/* named surface not found */
+	return NULL;
+}
+
+
+
+/*----------------------------------------------------------------------------
+  PicoSet*() Setter Functions
+----------------------------------------------------------------------------*/
+
+void PicoSetModelName( picoModel_t *model, char *name )
+{
+	if( model == NULL || name == NULL )
+		return;
+	if( model->name != NULL )
+		_pico_free( model->name );
+
+	model->name = _pico_clone_alloc( name );
+}
+
+
+
+void PicoSetModelFileName( picoModel_t *model, char *fileName )
+{
+	if( model == NULL || fileName == NULL )
+		return;
+	if( model->fileName != NULL )
+		_pico_free( model->fileName );
+
+	model->fileName = _pico_clone_alloc( fileName );
+}
+
+
+
+void PicoSetModelFrameNum( picoModel_t *model, int frameNum )
+{
+	if( model == NULL )
+		return;
+	model->frameNum = frameNum;
+}
+
+
+
+void PicoSetModelNumFrames( picoModel_t *model, int numFrames )
+{
+	if( model == NULL )
+		return;
+	model->numFrames = numFrames;
+}
+
+
+
+void PicoSetModelData( picoModel_t *model, void *data )
+{
+	if( model == NULL )
+		return;
+	model->data = data;
+}
+
+
+
+void PicoSetShaderName( picoShader_t *shader, char *name )
+{
+	if( shader == NULL || name == NULL )
+		return;
+	if( shader->name != NULL )
+		_pico_free( shader->name );
+
+	shader->name = _pico_clone_alloc( name );
+}
+
+
+
+void PicoSetShaderMapName( picoShader_t *shader, char *mapName )
+{
+	if( shader == NULL || mapName == NULL )
+		return;
+	if( shader->mapName != NULL )
+		_pico_free( shader->mapName );
+
+	shader->mapName = _pico_clone_alloc( mapName );
+}
+
+
+
+void PicoSetShaderAmbientColor( picoShader_t *shader, picoColor_t color )
+{
+	if( shader == NULL || color == NULL )
+		return;
+	shader->ambientColor[ 0 ] = color[ 0 ];
+	shader->ambientColor[ 1 ] = color[ 1 ];
+	shader->ambientColor[ 2 ] = color[ 2 ];
+	shader->ambientColor[ 3 ] = color[ 3 ];
+}
+
+
+
+void PicoSetShaderDiffuseColor( picoShader_t *shader, picoColor_t color )
+{
+	if( shader == NULL || color == NULL )
+		return;
+	shader->diffuseColor[ 0 ] = color[ 0 ];
+	shader->diffuseColor[ 1 ] = color[ 1 ];
+	shader->diffuseColor[ 2 ] = color[ 2 ];
+	shader->diffuseColor[ 3 ] = color[ 3 ];
+}
+
+
+
+void PicoSetShaderSpecularColor( picoShader_t *shader, picoColor_t color )
+{
+	if( shader == NULL || color == NULL )
+		return;
+	shader->specularColor[ 0 ] = color[ 0 ];
+	shader->specularColor[ 1 ] = color[ 1 ];
+	shader->specularColor[ 2 ] = color[ 2 ];
+	shader->specularColor[ 3 ] = color[ 3 ];
+}
+
+
+
+void PicoSetShaderTransparency( picoShader_t *shader, float value )
+{
+	if( shader == NULL )
+		return;
+	shader->transparency = value;
+
+	/* cap to 0..1 range */
+	if (shader->transparency < 0.0)
+		shader->transparency = 0.0;
+	if (shader->transparency > 1.0)
+		shader->transparency = 1.0;
+}
+
+
+
+void PicoSetShaderShininess( picoShader_t *shader, float value )
+{
+	if( shader == NULL )
+		return;
+	shader->shininess = value;
+
+	/* cap to 0..127 range */
+	if (shader->shininess < 0.0)
+		shader->shininess = 0.0;
+	if (shader->shininess > 127.0)
+		shader->shininess = 127.0;
+}
+
+
+
+void PicoSetSurfaceData( picoSurface_t *surface, void *data )
+{
+	if( surface == NULL )
+		return;
+	surface->data = data;
+}
+
+
+
+void PicoSetSurfaceType( picoSurface_t *surface, picoSurfaceType_t type )
+{
+	if( surface == NULL )
+		return;
+	surface->type = type;
+}
+
+
+
+void PicoSetSurfaceName( picoSurface_t *surface, char *name )
+{
+	if( surface == NULL || name == NULL )
+		return;
+	if( surface->name != NULL )
+		_pico_free( surface->name );
+
+	surface->name = _pico_clone_alloc( name );
+}
+
+
+
+void PicoSetSurfaceShader( picoSurface_t *surface, picoShader_t *shader )
+{
+	if( surface == NULL )
+		return;
+	surface->shader = shader;
+}
+
+
+
+void PicoSetSurfaceXYZ( picoSurface_t *surface, int num, picoVec3_t xyz )
+{
+	if( surface == NULL || num < 0 || xyz == NULL )
+		return;
+	if( !PicoAdjustSurface( surface, num + 1, 0, 0, 0, 0 ) )
+		return;
+	_pico_copy_vec( xyz, surface->xyz[ num ] );
+	if( surface->model != NULL )
+		_pico_expand_bounds( xyz, surface->model->mins, surface->model->maxs );
+}
+
+
+
+void PicoSetSurfaceNormal( picoSurface_t *surface, int num, picoVec3_t normal )
+{
+	if( surface == NULL || num < 0 || normal == NULL )
+		return;
+	if( !PicoAdjustSurface( surface, num + 1, 0, 0, 0, 0 ) )
+		return;
+	_pico_copy_vec( normal, surface->normal[ num ] );
+}
+
+
+
+void PicoSetSurfaceST( picoSurface_t *surface, int array, int num, picoVec2_t st )
+{
+	if( surface == NULL || num < 0 || st == NULL )
+		return;
+	if( !PicoAdjustSurface( surface, num + 1, array + 1, 0, 0, 0 ) )
+		return;
+	surface->st[ array ][ num ][ 0 ] = st[ 0 ];
+	surface->st[ array ][ num ][ 1 ] = st[ 1 ];
+}
+
+
+
+void PicoSetSurfaceColor( picoSurface_t *surface, int array, int num, picoColor_t color )
+{
+	if( surface == NULL || num < 0 || color == NULL )
+		return;
+	if( !PicoAdjustSurface( surface, num + 1, 0, array + 1, 0, 0 ) )
+		return;
+	surface->color[ array ][ num ][ 0 ] = color[ 0 ];
+	surface->color[ array ][ num ][ 1 ] = color[ 1 ];
+	surface->color[ array ][ num ][ 2 ] = color[ 2 ];
+	surface->color[ array ][ num ][ 3 ] = color[ 3 ];
+}
+
+
+
+void PicoSetSurfaceIndex( picoSurface_t *surface, int num, picoIndex_t index )
+{
+	if( surface == NULL || num < 0 )
+		return;
+	if( !PicoAdjustSurface( surface, 0, 0, 0, num + 1, 0 ) )
+		return;
+	surface->index[ num ] = index;
+}
+
+
+
+void PicoSetSurfaceIndexes( picoSurface_t *surface, int num, picoIndex_t *index, int count )
+{
+	if( num < 0 || index == NULL || count < 1 )
+		return;
+	if( !PicoAdjustSurface( surface, 0, 0, 0, num + count, 0 ) )
+		return;
+	memcpy( &surface->index[ num ], index, count * sizeof( surface->index[ num ] ) );
+}
+
+
+
+void PicoSetFaceNormal( picoSurface_t *surface, int num, picoVec3_t normal )
+{
+	if( surface == NULL || num < 0 || normal == NULL )
+		return;
+	if( !PicoAdjustSurface( surface, 0, 0, 0, 0, num + 1 ) )
+		return;
+	_pico_copy_vec( normal, surface->faceNormal[ num ] );
+}
+
+
+void PicoSetSurfaceSmoothingGroup( picoSurface_t *surface, int num, picoIndex_t smoothingGroup )
+{
+	if( num < 0 )
+		return;
+	if( !PicoAdjustSurface( surface, num + 1, 0, 0, 0, 0 ) )
+		return;
+	surface->smoothingGroup[ num ] = smoothingGroup;
+}
+
+
+void PicoSetSurfaceSpecial( picoSurface_t *surface, int num, int special )
+{
+	if( surface == NULL || num < 0 || num >= PICO_MAX_SPECIAL )
+		return;
+	surface->special[ num ] = special;
+}
+
+
+
+/*----------------------------------------------------------------------------
+  PicoGet*() Getter Functions
+----------------------------------------------------------------------------*/
+
+char *PicoGetModelName( picoModel_t *model )
+{
+	if( model == NULL )
+		return NULL;
+	if( model->name == NULL)
+		return (char*) "";
+	return model->name;
+}
+
+
+
+char *PicoGetModelFileName( picoModel_t *model )
+{
+	if( model == NULL )
+		return NULL;
+	if( model->fileName == NULL)
+		return (char*) "";
+	return model->fileName;
+}
+
+
+
+int PicoGetModelFrameNum( picoModel_t *model )
+{
+	if( model == NULL )
+		return 0;
+	return model->frameNum;
+}
+
+
+
+int PicoGetModelNumFrames( picoModel_t *model )
+{
+	if( model == NULL )
+		return 0;
+	return model->numFrames;
+}
+
+
+
+void *PicoGetModelData( picoModel_t *model )
+{
+	if( model == NULL )
+		return NULL;
+	return model->data;
+}
+
+
+
+int PicoGetModelNumShaders( picoModel_t *model )
+{
+	if( model == NULL )
+		return 0;
+	return model->numShaders;
+}
+
+
+
+picoShader_t *PicoGetModelShader( picoModel_t *model, int num )
+{
+	/* a few sanity checks */
+	if( model == NULL )
+		return NULL;
+	if( model->shader == NULL)
+		return NULL;
+	if( num < 0 || num >= model->numShaders )
+		return NULL;
+	
+	/* return the shader */
+	return model->shader[ num ];
+}
+
+
+
+int PicoGetModelNumSurfaces( picoModel_t *model )
+{
+	if( model == NULL )
+		return 0;
+	return model->numSurfaces;
+}
+
+
+
+picoSurface_t *PicoGetModelSurface( picoModel_t *model, int num )
+{
+	/* a few sanity checks */
+	if( model == NULL )
+		return NULL;
+	if( model->surface == NULL)
+		return NULL;
+	if( num < 0 || num >= model->numSurfaces )
+		return NULL;
+	
+	/* return the surface */
+	return model->surface[ num ];
+}
+
+
+
+int PicoGetModelTotalVertexes( picoModel_t *model )
+{
+	int		i, count;
+	
+	
+	if( model == NULL )
+		return 0;
+	if( model->surface == NULL )
+		return 0;
+	
+	count = 0;
+	for( i = 0; i < model->numSurfaces; i++ )
+		 count += PicoGetSurfaceNumVertexes( model->surface[ i ] );
+	
+	return count;
+}
+
+
+
+int PicoGetModelTotalIndexes( picoModel_t *model )
+{
+	int		i, count;
+	
+	
+	if( model == NULL )
+		return 0;
+	if( model->surface == NULL )
+		return 0;
+	
+	count = 0;
+	for( i = 0; i < model->numSurfaces; i++ )
+		 count += PicoGetSurfaceNumIndexes( model->surface[ i ] );
+	
+	return count;
+}
+
+
+
+char *PicoGetShaderName( picoShader_t *shader )
+{
+	if( shader == NULL )
+		return NULL;
+	if( shader->name == NULL)
+		return (char*) "";
+	return shader->name;
+}
+
+
+
+char *PicoGetShaderMapName( picoShader_t *shader )
+{
+	if( shader == NULL )
+		return NULL;
+	if( shader->mapName == NULL)
+		return (char*) "";
+	return shader->mapName;
+}
+
+
+
+picoByte_t *PicoGetShaderAmbientColor( picoShader_t *shader )
+{
+	if( shader == NULL )
+		return NULL;
+	return shader->ambientColor;
+}
+
+
+
+picoByte_t *PicoGetShaderDiffuseColor( picoShader_t *shader )
+{
+	if( shader == NULL )
+		return NULL;
+	return shader->diffuseColor;
+}
+
+
+
+picoByte_t *PicoGetShaderSpecularColor( picoShader_t *shader )
+{
+	if( shader == NULL )
+		return NULL;
+	return shader->specularColor;
+}
+
+
+
+float PicoGetShaderTransparency( picoShader_t *shader )
+{
+	if( shader == NULL )
+		return 0.0f;
+	return shader->transparency;
+}
+
+
+
+float PicoGetShaderShininess( picoShader_t *shader )
+{
+	if( shader == NULL )
+		return 0.0f;
+	return shader->shininess;
+}
+
+
+
+void *PicoGetSurfaceData( picoSurface_t *surface )
+{
+	if( surface == NULL )
+		return NULL;
+	return surface->data;
+}
+
+
+
+picoSurfaceType_t PicoGetSurfaceType( picoSurface_t *surface )
+{
+	if( surface == NULL )
+		return PICO_BAD;
+	return surface->type;
+}
+
+
+
+char *PicoGetSurfaceName( picoSurface_t *surface )
+{
+	if( surface == NULL )
+		return NULL;
+	if( surface->name == NULL )
+		return (char*) "";
+	return surface->name;
+}
+
+
+
+picoShader_t *PicoGetSurfaceShader( picoSurface_t *surface )
+{
+	if( surface == NULL )
+		return NULL;
+	return surface->shader;
+}
+
+
+
+int PicoGetSurfaceNumVertexes( picoSurface_t *surface )
+{
+	if( surface == NULL )
+		return 0;
+	return surface->numVertexes;
+}
+
+
+
+picoVec_t *PicoGetSurfaceXYZ( picoSurface_t *surface, int num )
+{
+	if( surface == NULL || num < 0 || num > surface->numVertexes )
+		return NULL;
+	return surface->xyz[ num ];
+}
+
+
+
+picoVec_t *PicoGetSurfaceNormal( picoSurface_t *surface, int num )
+{
+	if( surface == NULL || num < 0 || num > surface->numVertexes )
+		return NULL;
+	return surface->normal[ num ];
+}
+
+
+
+picoVec_t *PicoGetSurfaceST( picoSurface_t *surface, int array, int num  )
+{
+	if( surface == NULL || array < 0 || array > surface->numSTArrays || num < 0 || num > surface->numVertexes )
+		return NULL;
+	return surface->st[ array ][ num ];
+}
+
+
+
+picoByte_t *PicoGetSurfaceColor( picoSurface_t *surface, int array, int num )
+{
+	if( surface == NULL || array < 0 || array > surface->numColorArrays || num < 0 || num > surface->numVertexes )
+		return NULL;
+	return surface->color[ array ][ num ];
+}
+
+
+
+int PicoGetSurfaceNumIndexes( picoSurface_t *surface )
+{
+	if( surface == NULL )
+		return 0;
+	return surface->numIndexes;
+}
+
+
+
+picoIndex_t PicoGetSurfaceIndex( picoSurface_t *surface, int num )
+{
+	if( surface == NULL || num < 0 || num > surface->numIndexes )
+		return 0;
+	return surface->index[ num ];
+}
+
+
+
+picoIndex_t *PicoGetSurfaceIndexes( picoSurface_t *surface, int num )
+{
+	if( surface == NULL || num < 0 || num > surface->numIndexes )
+		return NULL;
+	return &surface->index[ num ];
+}
+
+
+picoVec_t *PicoGetFaceNormal( picoSurface_t *surface, int num )
+{
+	if( surface == NULL || num < 0 || num > surface->numFaceNormals )
+		return NULL;
+	return surface->faceNormal[ num ];
+}
+
+picoIndex_t PicoGetSurfaceSmoothingGroup( picoSurface_t *surface, int num )
+{
+	if( surface == NULL || num < 0 || num > surface->numVertexes )
+		return -1;
+	return surface->smoothingGroup[ num ];
+}
+
+
+int PicoGetSurfaceSpecial( picoSurface_t *surface, int num )
+{
+	if( surface == NULL || num < 0 || num >= PICO_MAX_SPECIAL )
+		return 0;
+	return surface->special[ num ];
+}
+
+
+
+/* ----------------------------------------------------------------------------
+hashtable related functions
+---------------------------------------------------------------------------- */
+
+/* hashtable code for faster vertex lookups */
+//#define HASHTABLE_SIZE 32768 // 2048			/* power of 2, use & */
+#define HASHTABLE_SIZE 7919 // 32749 // 2039 	/* prime, use % */
+
+int PicoGetHashTableSize( void )
+{
+	return HASHTABLE_SIZE;
+}
+
+#define HASH_USE_EPSILON
+
+#ifdef HASH_USE_EPSILON
+#define HASH_XYZ_EPSILON					0.01f
+#define HASH_XYZ_EPSILONSPACE_MULTIPLIER	1.f / HASH_XYZ_EPSILON
+#define HASH_ST_EPSILON						0.0001f
+#define HASH_NORMAL_EPSILON					0.02f
+#endif
+
+unsigned int PicoVertexCoordGenerateHash( picoVec3_t xyz )
+{
+	unsigned int hash = 0;
+
+#ifndef HASH_USE_EPSILON
+	hash += ~(*((unsigned int*) &xyz[ 0 ]) << 15);
+	hash ^= (*((unsigned int*) &xyz[ 0 ]) >> 10);
+	hash += (*((unsigned int*) &xyz[ 1 ]) << 3);
+	hash ^= (*((unsigned int*) &xyz[ 1 ]) >> 6);
+	hash += ~(*((unsigned int*) &xyz[ 2 ]) << 11);
+	hash ^= (*((unsigned int*) &xyz[ 2 ]) >> 16);
+#else
+	picoVec3_t xyz_epsilonspace;
+
+	_pico_scale_vec( xyz, HASH_XYZ_EPSILONSPACE_MULTIPLIER, xyz_epsilonspace );
+	xyz_epsilonspace[ 0 ] = (double)floor(xyz_epsilonspace[ 0 ]);
+	xyz_epsilonspace[ 1 ] = (double)floor(xyz_epsilonspace[ 1 ]);
+	xyz_epsilonspace[ 2 ] = (double)floor(xyz_epsilonspace[ 2 ]);
+
+	hash += ~(*((unsigned int*) &xyz_epsilonspace[ 0 ]) << 15);
+	hash ^= (*((unsigned int*) &xyz_epsilonspace[ 0 ]) >> 10);
+	hash += (*((unsigned int*) &xyz_epsilonspace[ 1 ]) << 3);
+	hash ^= (*((unsigned int*) &xyz_epsilonspace[ 1 ]) >> 6);
+	hash += ~(*((unsigned int*) &xyz_epsilonspace[ 2 ]) << 11);
+	hash ^= (*((unsigned int*) &xyz_epsilonspace[ 2 ]) >> 16);
+#endif
+
+	//hash = hash & (HASHTABLE_SIZE-1);
+	hash = hash % (HASHTABLE_SIZE);
+	return hash;
+}
+
+picoVertexCombinationHash_t **PicoNewVertexCombinationHashTable( void )
+{
+	picoVertexCombinationHash_t	**hashTable = _pico_alloc( HASHTABLE_SIZE * sizeof(picoVertexCombinationHash_t*) );
+
+	memset( hashTable, 0, HASHTABLE_SIZE * sizeof(picoVertexCombinationHash_t*) );
+
+	return hashTable;
+}
+
+void PicoFreeVertexCombinationHashTable( picoVertexCombinationHash_t **hashTable )
+{
+	int							i;
+	picoVertexCombinationHash_t	*vertexCombinationHash;
+	picoVertexCombinationHash_t *nextVertexCombinationHash;
+
+	/* dummy check */
+	if (hashTable == NULL)
+		return;
+
+	for( i = 0; i < HASHTABLE_SIZE; i++ )
+	{
+		if (hashTable[ i ])
+		{
+			nextVertexCombinationHash = NULL;
+
+			for( vertexCombinationHash = hashTable[ i ]; vertexCombinationHash; vertexCombinationHash = nextVertexCombinationHash )
+			{
+				nextVertexCombinationHash = vertexCombinationHash->next;
+				if (vertexCombinationHash->data != NULL)
+				{
+					_pico_free( vertexCombinationHash->data );
+				}
+				_pico_free( vertexCombinationHash );
+			}
+		}
+	}
+
+	_pico_free( hashTable );
+}
+
+picoVertexCombinationHash_t *PicoFindVertexCombinationInHashTable( picoVertexCombinationHash_t **hashTable, picoVec3_t xyz, picoVec3_t normal, picoVec3_t st, picoColor_t color )
+{
+	unsigned int				hash;
+	picoVertexCombinationHash_t	*vertexCombinationHash;
+
+	/* dumy check */
+	if (hashTable == NULL || xyz == NULL || normal == NULL || st == NULL || color == NULL )
+		return NULL;
+
+	hash = PicoVertexCoordGenerateHash( xyz );
+
+	for( vertexCombinationHash = hashTable[ hash ]; vertexCombinationHash; vertexCombinationHash = vertexCombinationHash->next )
+	{
+#ifndef HASH_USE_EPSILON
+		/* check xyz */
+		if( (vertexCombinationHash->vcd.xyz[ 0 ] != xyz[ 0 ] || vertexCombinationHash->vcd.xyz[ 1 ] != xyz[ 1 ] || vertexCombinationHash->vcd.xyz[ 2 ] != xyz[ 2 ]) )
+			continue;
+
+		/* check normal */
+		if( (vertexCombinationHash->vcd.normal[ 0 ] != normal[ 0 ] || vertexCombinationHash->vcd.normal[ 1 ] != normal[ 1 ] || vertexCombinationHash->vcd.normal[ 2 ] != normal[ 2 ]) )
+			continue;
+		
+		/* check st */
+		if( vertexCombinationHash->vcd.st[ 0 ] != st[ 0 ] || vertexCombinationHash->vcd.st[ 1 ] != st[ 1 ] )
+			continue;
+#else
+		/* check xyz */
+		if( ( fabs(xyz[ 0 ] - vertexCombinationHash->vcd.xyz[ 0 ]) ) > HASH_XYZ_EPSILON ||
+			( fabs(xyz[ 1 ] - vertexCombinationHash->vcd.xyz[ 1 ]) ) > HASH_XYZ_EPSILON ||
+			( fabs(xyz[ 2 ] - vertexCombinationHash->vcd.xyz[ 2 ]) ) > HASH_XYZ_EPSILON )
+			continue;
+
+		/* check normal */
+		if( ( fabs(normal[ 0 ] - vertexCombinationHash->vcd.normal[ 0 ]) ) > HASH_NORMAL_EPSILON ||
+			( fabs(normal[ 1 ] - vertexCombinationHash->vcd.normal[ 1 ]) ) > HASH_NORMAL_EPSILON ||
+			( fabs(normal[ 2 ] - vertexCombinationHash->vcd.normal[ 2 ]) ) > HASH_NORMAL_EPSILON )
+			continue;
+		
+		/* check st */
+		if( ( fabs(st[ 0 ] - vertexCombinationHash->vcd.st[ 0 ]) ) > HASH_ST_EPSILON ||
+			( fabs(st[ 1 ] - vertexCombinationHash->vcd.st[ 1 ]) ) > HASH_ST_EPSILON )
+			continue;
+#endif
+
+		/* check color */
+		if( *((int*) vertexCombinationHash->vcd.color) != *((int*) color) )
+			continue;
+
+		/* gotcha */
+		return vertexCombinationHash;
+	}
+
+	return NULL;
+}
+
+picoVertexCombinationHash_t *PicoAddVertexCombinationToHashTable( picoVertexCombinationHash_t **hashTable, picoVec3_t xyz, picoVec3_t normal, picoVec3_t st, picoColor_t color, picoIndex_t index )
+{
+	unsigned int				hash;
+	picoVertexCombinationHash_t	*vertexCombinationHash;
+
+	/* dumy check */
+	if (hashTable == NULL || xyz == NULL || normal == NULL || st == NULL || color == NULL )
+		return NULL;
+
+	vertexCombinationHash = _pico_alloc( sizeof(picoVertexCombinationHash_t) );
+
+	if (!vertexCombinationHash)
+		return NULL;
+
+	hash = PicoVertexCoordGenerateHash( xyz );
+
+	_pico_copy_vec( xyz, vertexCombinationHash->vcd.xyz );
+	_pico_copy_vec( normal, vertexCombinationHash->vcd.normal );
+	_pico_copy_vec2( st, vertexCombinationHash->vcd.st );
+	_pico_copy_color( color, vertexCombinationHash->vcd.color );
+	vertexCombinationHash->index = index;
+	vertexCombinationHash->data = NULL;
+	vertexCombinationHash->next = hashTable[ hash ];
+	hashTable[ hash ] = vertexCombinationHash;
+
+	return vertexCombinationHash;
+}
+
+/* ----------------------------------------------------------------------------
+specialized routines
+---------------------------------------------------------------------------- */
+
+/*
+PicoFindSurfaceVertex()
+finds a vertex matching the set parameters
+fixme: needs non-naive algorithm
+*/
+
+int PicoFindSurfaceVertexNum( picoSurface_t *surface, picoVec3_t xyz, picoVec3_t normal, int numSTs, picoVec2_t *st, int numColors, picoColor_t *color, picoIndex_t smoothingGroup)
+{
+	int		i, j;
+	
+	
+	/* dummy check */
+	if( surface == NULL || surface->numVertexes <= 0 )
+		return -1;
+	
+	/* walk vertex list */
+	for( i = 0; i < surface->numVertexes; i++ )
+	{
+		/* check xyz */
+		if( xyz != NULL && (surface->xyz[ i ][ 0 ] != xyz[ 0 ] || surface->xyz[ i ][ 1 ] != xyz[ 1 ] || surface->xyz[ i ][ 2 ] != xyz[ 2 ]) )
+			continue;
+		
+		/* check normal */
+		if( normal != NULL && (surface->normal[ i ][ 0 ] != normal[ 0 ] || surface->normal[ i ][ 1 ] != normal[ 1 ] || surface->normal[ i ][ 2 ] != normal[ 2 ]) )
+			continue;
+		
+		/* check normal */
+		if( surface->smoothingGroup[ i ] != smoothingGroup )
+			continue;
+
+    /* check st */
+		if( numSTs > 0 && st != NULL )
+		{
+			for( j = 0; j < numSTs; j++ )
+			{
+				if( surface->st[ j ][ i ][ 0 ] != st[ j ][ 0 ] || surface->st[ j ][ i ][ 1 ] != st[ j ][ 1 ] )
+					break;
+			}
+			if( j != numSTs )
+				continue;
+		}
+		
+		/* check color */
+		if( numColors > 0 && color != NULL )
+		{
+			for( j = 0; j < numSTs; j++ )
+			{
+				if( *((int*) surface->color[ j ]) != *((int*) color[ j ]) )
+					break;
+			}
+			if( j != numColors )
+				continue;
+		}
+		
+		/* vertex matches */
+		return i;
+	}
+	
+	/* nada */
+	return -1;
+}
+
+
+
+
+typedef struct _IndexArray IndexArray;
+struct _IndexArray
+{
+	picoIndex_t* data;
+	picoIndex_t* last;
+};
+
+void indexarray_push_back(IndexArray* self, picoIndex_t value)
+{
+	*self->last++ = value;
+}
+
+size_t indexarray_size(IndexArray* self)
+{
+	return self->last - self->data;
+}
+
+void indexarray_reserve(IndexArray* self, size_t size)
+{
+	self->data = self->last = _pico_calloc(size, sizeof(picoIndex_t));
+}
+
+void indexarray_clear(IndexArray* self)
+{
+	_pico_free(self->data);
+}
+
+typedef struct _BinaryTreeNode BinaryTreeNode;
+struct _BinaryTreeNode
+{
+	picoIndex_t left;
+	picoIndex_t right;
+};
+
+typedef struct _BinaryTree BinaryTree;
+struct _BinaryTree
+{
+	BinaryTreeNode* data;
+	BinaryTreeNode* last;
+};
+
+void binarytree_extend(BinaryTree* self)
+{
+	self->last->left = 0;
+	self->last->right = 0;
+	++self->last;
+}
+
+size_t binarytree_size(BinaryTree* self)
+{
+	return self->last - self->data;
+}
+
+void binarytree_reserve(BinaryTree* self, size_t size)
+{
+	self->data = self->last = _pico_calloc(size, sizeof(BinaryTreeNode));
+}
+
+void binarytree_clear(BinaryTree* self)
+{
+	_pico_free(self->data);
+}
+
+typedef int (*LessFunc)(void*, picoIndex_t, picoIndex_t);
+
+typedef struct _UniqueIndices UniqueIndices;
+struct _UniqueIndices
+{
+	BinaryTree tree;
+	IndexArray indices;
+	LessFunc lessFunc;
+	void* lessData;
+};
+
+size_t UniqueIndices_size(UniqueIndices* self)
+{
+  return binarytree_size(&self->tree);
+}
+
+void UniqueIndices_reserve(UniqueIndices* self, size_t size)
+{
+	binarytree_reserve(&self->tree, size);
+	indexarray_reserve(&self->indices, size);
+}
+
+void UniqueIndices_init(UniqueIndices* self, LessFunc lessFunc, void* lessData)
+{
+	self->lessFunc = lessFunc;
+	self->lessData = lessData;
+}
+
+void UniqueIndices_destroy(UniqueIndices* self)
+{
+	binarytree_clear(&self->tree);
+	indexarray_clear(&self->indices);
+}
+
+
+picoIndex_t UniqueIndices_find_or_insert(UniqueIndices* self, picoIndex_t value)
+{
+	picoIndex_t index = 0;
+
+	for(;;)
+	{
+		if(self->lessFunc(self->lessData, value, self->indices.data[index]))
+		{
+			BinaryTreeNode* node = self->tree.data + index;
+			if(node->left != 0)
+			{
+				index = node->left;
+				continue;
+			}
+			else
+			{
+				node->left = (picoIndex_t)binarytree_size(&self->tree);
+				binarytree_extend(&self->tree);
+				indexarray_push_back(&self->indices, value);
+				return node->left;
+			}
+		}
+		if(self->lessFunc(self->lessData, self->indices.data[index], value))
+		{
+			BinaryTreeNode* node = self->tree.data + index;
+			if(node->right != 0)
+			{
+				index = node->right;
+				continue;
+			}
+			else
+			{
+				node->right = (picoIndex_t)binarytree_size(&self->tree);
+				binarytree_extend(&self->tree);
+				indexarray_push_back(&self->indices, value);
+				return node->right;
+			}
+		}
+
+		return index;
+	}
+}
+
+picoIndex_t UniqueIndices_insert(UniqueIndices* self, picoIndex_t value)
+{
+	if(self->tree.data == self->tree.last)
+	{
+		binarytree_extend(&self->tree);
+		indexarray_push_back(&self->indices, value);
+		return 0;
+    }
+	else
+	{
+		return UniqueIndices_find_or_insert(self, value);
+	}
+}
+
+typedef struct picoSmoothVertices_s picoSmoothVertices_t;
+struct picoSmoothVertices_s
+{
+	picoVec3_t* xyz;
+	picoIndex_t* smoothingGroups;
+};
+
+int lessSmoothVertex(void* data, picoIndex_t first, picoIndex_t second)
+{
+	picoSmoothVertices_t* smoothVertices = data;
+	
+	if(smoothVertices->xyz[first][0] != smoothVertices->xyz[second][0])
+	{
+		return smoothVertices->xyz[first][0] < smoothVertices->xyz[second][0];
+	}
+	if(smoothVertices->xyz[first][1] != smoothVertices->xyz[second][1])
+	{
+		return smoothVertices->xyz[first][1] < smoothVertices->xyz[second][1];
+	}
+	if(smoothVertices->xyz[first][2] != smoothVertices->xyz[second][2])
+	{
+		return smoothVertices->xyz[first][2] < smoothVertices->xyz[second][2];
+	}
+	if(smoothVertices->smoothingGroups[first] != smoothVertices->smoothingGroups[second])
+	{
+		return smoothVertices->smoothingGroups[first] < smoothVertices->smoothingGroups[second];
+	}
+	return 0;
+}
+
+void _pico_vertices_combine_shared_normals(picoVec3_t* xyz, picoIndex_t* smoothingGroups, picoVec3_t* normals, picoIndex_t numVertices)
+{
+	UniqueIndices vertices;
+	IndexArray indices;
+	picoSmoothVertices_t smoothVertices = { xyz, smoothingGroups };
+	UniqueIndices_init(&vertices, lessSmoothVertex, &smoothVertices);
+	UniqueIndices_reserve(&vertices, numVertices);
+	indexarray_reserve(&indices, numVertices);
+
+
+	{
+		picoIndex_t i = 0;
+		for(; i < numVertices; ++i)
+		{
+			size_t size = UniqueIndices_size(&vertices);
+			picoIndex_t index = UniqueIndices_insert(&vertices, i);
+			if((size_t)index != size)
+			{
+				double* normal = normals[vertices.indices.data[index]];
+				_pico_add_vec(normal, normals[i], normal);
+			}
+			indexarray_push_back(&indices, index);
+		}
+	}
+
+	{
+		picoIndex_t maxIndex = 0;
+		picoIndex_t* i = indices.data;
+		for(; i != indices.last; ++i)
+		{
+			if(*i <= maxIndex)
+			{
+				_pico_copy_vec(normals[vertices.indices.data[*i]], normals[i - indices.data]);
+			}
+			else
+			{
+				maxIndex = *i;
+			}
+		}
+	}
+
+	UniqueIndices_destroy(&vertices);
+  indexarray_clear(&indices);
+}
+
+typedef picoVec3_t* picoNormalIter_t;
+typedef picoIndex_t* picoIndexIter_t;
+
+#define THE_CROSSPRODUCTS_OF_ANY_PAIR_OF_EDGES_OF_A_GIVEN_TRIANGLE_ARE_EQUAL 1
+
+void _pico_triangles_generate_weighted_normals(picoIndexIter_t first, picoIndexIter_t end, picoVec3_t* xyz, picoVec3_t* normals)
+{
+	for(; first != end; first += 3)
+	{
+#if (THE_CROSSPRODUCTS_OF_ANY_PAIR_OF_EDGES_OF_A_GIVEN_TRIANGLE_ARE_EQUAL)
+		picoVec3_t weightedNormal;
+		{
+			double* a = xyz[*(first + 0)];
+			double* b = xyz[*(first + 1)];
+			double* c = xyz[*(first + 2)];
+			picoVec3_t ba, ca;
+			_pico_subtract_vec( b, a, ba );
+			_pico_subtract_vec( c, a, ca );
+			_pico_cross_vec( ca, ba, weightedNormal );
+		}
+#endif
+		{
+			int j = 0;
+			for(; j < 3; ++j)
+			{
+				double* normal = normals[*(first + j)];
+#if (!THE_CROSSPRODUCTS_OF_ANY_PAIR_OF_EDGES_OF_A_GIVEN_TRIANGLE_ARE_EQUAL)
+				picoVec3_t weightedNormal;
+				{
+					double* a = xyz[*(first + ((j + 0) % 3))];
+					double* b = xyz[*(first + ((j + 1) % 3))];
+					double* c = xyz[*(first + ((j + 2) % 3))];
+					picoVec3_t ba, ca;
+					_pico_subtract_vec( b, a, ba );
+					_pico_subtract_vec( c, a, ca );
+					_pico_cross_vec( ca, ba, weightedNormal );
+				}
+#endif
+				_pico_add_vec(weightedNormal, normal, normal);
+			}
+		}
+	}
+}
+
+void _pico_normals_zero(picoNormalIter_t first, picoNormalIter_t last)
+{
+	for(; first != last; ++first)
+	{
+		_pico_zero_vec(*first);
+	}
+}
+
+void _pico_normals_normalize(picoNormalIter_t first, picoNormalIter_t last)
+{
+	for(; first != last; ++first)
+	{
+		_pico_normalize_vec(*first);
+	}
+}
+
+double _pico_length_vec( picoVec3_t vec )
+{
+	return sqrt( vec[ 0 ] * vec[ 0 ] + vec[ 1 ] * vec[ 1 ] + vec[ 2 ] * vec[ 2 ] );
+}
+
+#define NORMAL_UNIT_LENGTH_EPSILON 0.01
+#define FLOAT_EQUAL_EPSILON(f, other, epsilon) (fabs(f - other) < epsilon)
+
+int _pico_normal_is_unit_length(picoVec3_t normal)
+{
+	return FLOAT_EQUAL_EPSILON(_pico_length_vec(normal), 1.0, NORMAL_UNIT_LENGTH_EPSILON);
+}
+
+int _pico_normal_within_tolerance(picoVec3_t normal, picoVec3_t other)
+{
+	return _pico_dot_vec(normal, other) > 0.0f;
+}
+
+
+void _pico_normals_assign_generated_normals(picoNormalIter_t first, picoNormalIter_t last, picoNormalIter_t generated)
+{
+	for(; first != last; ++first, ++generated)
+	{
+		if(!_pico_normal_is_unit_length(*first) || !_pico_normal_within_tolerance(*first, *generated))
+		{
+			_pico_copy_vec(*generated, *first);
+		}
+	}
+}
+
+void PicoFixSurfaceNormals(picoSurface_t* surface)
+{
+	picoVec3_t* normals = (picoVec3_t*)_pico_calloc(surface->numVertexes, sizeof(picoVec3_t));
+
+	_pico_normals_zero(normals, normals + surface->numVertexes);
+
+	_pico_triangles_generate_weighted_normals(surface->index, surface->index + surface->numIndexes, surface->xyz, normals);
+	_pico_vertices_combine_shared_normals(surface->xyz, surface->smoothingGroup, normals, surface->numVertexes);
+
+	_pico_normals_normalize(normals, normals + surface->numVertexes);
+
+	_pico_normals_assign_generated_normals(surface->normal, surface->normal + surface->numVertexes, normals);
+
+	_pico_free(normals);
+}
+
+
+/*
+PicoRemapModel() - sea
+remaps model material/etc. information using the remappings
+contained in the given 'remapFile' (full path to the ascii file to open)
+returns 1 on success or 0 on error
+*/
+
+#define _prm_error_return \
+{ \
+	_pico_free_parser( p ); \
+	_pico_free_file( remapBuffer ); \
+	return 0; \
+}
+
+int PicoRemapModel( picoModel_t *model, char *remapFile )
+{
+	picoParser_t	*p;
+	picoByte_t		*remapBuffer;
+	int				remapBufSize;
+	
+	
+	/* sanity checks */
+	if( model == NULL || remapFile == NULL )
+		return 0;
+	
+	/* load remap file contents */
+	_pico_load_file( remapFile,&remapBuffer,&remapBufSize );
+	
+	/* check result */
+	if( remapBufSize == 0 )
+		return 1;	/* file is empty: no error */
+	if( remapBufSize < 0 )
+		return 0;	/* load failed: error */
+	
+	/* create a new pico parser */
+	p = _pico_new_parser( remapBuffer, remapBufSize );
+	if (p == NULL)
+	{
+		/* ram is really cheap nowadays... */
+		_prm_error_return;
+	}
+	
+	/* doo teh parse */
+	while( 1 )
+	{
+		/* get next token in remap file */
+		if (!_pico_parse( p,1 ))
+			break;
+
+		/* skip over c++ style comment lines */
+		if (!_pico_stricmp(p->token,"//"))
+		{
+			_pico_parse_skip_rest( p );
+			continue;
+		}
+		
+		/* block for quick material shader name remapping */
+		/* materials { "m" (=>|->|=) "s" } */
+		if( !_pico_stricmp(p->token, "materials" ) )
+		{
+			int level = 1;
+
+			/* check bracket */
+			if (!_pico_parse_check( p,1,"{" ))
+				_prm_error_return;
+
+			/* process assignments */
+			while( 1 )
+			{
+				picoShader_t	*shader;
+				char			*materialName;
+				
+				
+				/* get material name */
+				if (_pico_parse( p,1 ) == NULL) break;
+				if (!strlen(p->token)) continue;
+				materialName = _pico_clone_alloc( p->token );
+				if (materialName == NULL)
+					_prm_error_return;
+
+				/* handle levels */
+				if (p->token[0] == '{') level++;
+				if (p->token[0] == '}') level--;
+				if (!level) break;
+
+				/* get next token (assignment token or shader name) */
+				if (!_pico_parse( p,0 ))
+				{
+					_pico_free( materialName );
+					_prm_error_return;
+				}
+				/* skip assignment token (if present) */
+				if (!strcmp(p->token,"=>") ||
+					!strcmp(p->token,"->") ||
+					!strcmp(p->token,"="))
+				{
+					/* simply grab the next token */
+					if (!_pico_parse( p,0 ))
+					{
+						_pico_free( materialName );
+						_prm_error_return;
+					}
+				}
+				/* try to find material by name */
+				shader = PicoFindShader( model,materialName,0 );
+
+				/* we've found a material matching the name */
+				if (shader != NULL)
+				{
+					PicoSetShaderName( shader,p->token );
+				}
+				/* free memory used by material name */
+				_pico_free( materialName );
+
+				/* skip rest */
+				_pico_parse_skip_rest( p );
+			}
+		}
+		/* block for detailed single material remappings */
+		/* materials[ "m" ] { key data... } */
+		else if (!_pico_stricmp(p->token,"materials["))
+		{
+			picoShader_t *shader;
+			char *tempMaterialName;
+			int level = 1;
+
+			/* get material name */
+			if (!_pico_parse( p,0 ))
+				_prm_error_return;
+
+			/* temporary copy of material name */
+			tempMaterialName = _pico_clone_alloc( p->token );
+			if (tempMaterialName == NULL)
+				_prm_error_return;
+
+			/* check square closing bracket */
+			if (!_pico_parse_check( p,0,"]" ))
+				_prm_error_return;			
+
+			/* try to find material by name */
+			shader = PicoFindShader( model,tempMaterialName,0 );
+
+			/* free memory used by temporary material name */
+			_pico_free( tempMaterialName );
+
+			/* we haven't found a material matching the name */
+			/* so we simply skip the braced section now and */
+			/* continue parsing with the next main token */
+			if (shader == NULL)
+			{
+				_pico_parse_skip_braced( p );
+				continue;
+			}
+			/* check opening bracket */
+			if (!_pico_parse_check( p,1,"{" ))
+				_prm_error_return;
+
+			/* process material info keys */
+			while( 1 )
+			{
+				/* get key name */
+				if (_pico_parse( p,1 ) == NULL) break;
+				if (!strlen(p->token)) continue;
+
+				/* handle levels */
+				if (p->token[0] == '{') level++;
+				if (p->token[0] == '}') level--;
+				if (!level) break;
+
+				/* remap shader name */
+				if (!_pico_stricmp(p->token,"shader"))
+				{
+					if (!_pico_parse( p,0 )) _prm_error_return;
+					PicoSetShaderName( shader,p->token );
+				}
+				/* remap shader map name */
+				else if (!_pico_stricmp(p->token,"mapname"))
+				{
+					if (!_pico_parse( p,0 )) _prm_error_return;
+					PicoSetShaderMapName( shader,p->token );
+				}
+				/* remap shader's ambient color */
+				else if (!_pico_stricmp(p->token,"ambient"))
+				{
+					picoColor_t color;
+					picoVec3_t  v;
+
+					/* get vector from parser */
+					if (!_pico_parse_vec( p,v )) _prm_error_return;
+
+					/* store as color */
+					color[ 0 ] = (picoByte_t)v[ 0 ];
+					color[ 1 ] = (picoByte_t)v[ 1 ];
+					color[ 2 ] = (picoByte_t)v[ 2 ];
+
+					/* set new ambient color */
+					PicoSetShaderAmbientColor( shader,color );
+				}
+				/* remap shader's diffuse color */
+				else if (!_pico_stricmp(p->token,"diffuse"))
+				{
+					picoColor_t color;
+					picoVec3_t  v;
+
+					/* get vector from parser */
+					if (!_pico_parse_vec( p,v )) _prm_error_return;
+
+					/* store as color */
+					color[ 0 ] = (picoByte_t)v[ 0 ];
+					color[ 1 ] = (picoByte_t)v[ 1 ];
+					color[ 2 ] = (picoByte_t)v[ 2 ];
+
+					/* set new ambient color */
+					PicoSetShaderDiffuseColor( shader,color );
+				}
+				/* remap shader's specular color */
+				else if (!_pico_stricmp(p->token,"specular"))
+				{
+					picoColor_t color;
+					picoVec3_t  v;
+
+					/* get vector from parser */
+					if (!_pico_parse_vec( p,v )) _prm_error_return;
+
+					/* store as color */
+					color[ 0 ] = (picoByte_t)v[ 0 ];
+					color[ 1 ] = (picoByte_t)v[ 1 ];
+					color[ 2 ] = (picoByte_t)v[ 2 ];
+
+					/* set new ambient color */
+					PicoSetShaderSpecularColor( shader,color );
+				}
+				/* skip rest */
+				_pico_parse_skip_rest( p );
+			}
+		}
+		/* end 'materials[' */
+	}
+	
+	/* free both parser and file buffer */
+	_pico_free_parser( p );
+	_pico_free_file( remapBuffer );
+
+	/* return with success */
+	return 1;
+}
+
+
+/*
+PicoAddTriangleToModel() - jhefty
+A nice way to add individual triangles to the model.
+Chooses an appropriate surface based on the shader, or adds a new surface if necessary
+*/
+
+void PicoAddTriangleToModel( picoModel_t *model, picoVec3_t** xyz, picoVec3_t** normals, 
+							int numSTs, picoVec2_t **st, int numColors, picoColor_t **colors,
+							picoShader_t* shader, picoIndex_t* smoothingGroup )
+{
+	int i,j;
+	int vertDataIndex;
+	picoSurface_t* workSurface = NULL;
+
+	/* see if a surface already has the shader */
+	for ( i = 0 ; i < model->numSurfaces ; i++ )
+	{
+		workSurface = model->surface[i];
+		if ( workSurface->shader == shader )
+		{			
+			break;
+		}
+	}
+
+	/* no surface uses this shader yet, so create a new surface */
+	if ( !workSurface || i >=model->numSurfaces )
+	{
+		/* create a new surface in the model for the unique shader */
+		workSurface = PicoNewSurface(model);
+		if ( !workSurface )
+		{
+			_pico_printf ( PICO_ERROR , "Could not allocate a new surface!\n" );
+			return;
+		}
+
+		/* do surface setup */
+		PicoSetSurfaceType( workSurface, PICO_TRIANGLES );
+		PicoSetSurfaceName( workSurface, shader->name );
+		PicoSetSurfaceShader( workSurface, shader );
+	}
+
+	/* add the triangle data to the surface */
+	for ( i = 0 ; i < 3 ; i++ )	
+	{
+		/* get the next free spot in the index array */
+		int newVertIndex = PicoGetSurfaceNumIndexes ( workSurface );
+
+		/* get the index of the vertex that we're going to store at newVertIndex */
+		vertDataIndex = PicoFindSurfaceVertexNum ( workSurface , *xyz[i] , *normals[i] , numSTs , st[i] , numColors , colors[i], smoothingGroup[i]);
+
+		/* the vertex wasn't found, so create a new vertex in the pool from the data we have */
+		if ( vertDataIndex == -1 )
+		{			
+			/* find the next spot for a new vertex */
+			vertDataIndex = PicoGetSurfaceNumVertexes ( workSurface );			
+
+			/* assign the data to it */
+			PicoSetSurfaceXYZ ( workSurface ,vertDataIndex , *xyz[i] );
+			PicoSetSurfaceNormal ( workSurface , vertDataIndex , *normals[i] );			
+
+			/* make sure to copy over all available ST's and colors for the vertex */
+			for ( j = 0 ; j < numColors ; j++ )
+			{
+				PicoSetSurfaceColor( workSurface , j , vertDataIndex , colors[i][j] );
+			}
+			for ( j = 0 ; j < numSTs ; j++ )
+			{
+				PicoSetSurfaceST ( workSurface , j , vertDataIndex , st[i][j] );
+			}
+
+			PicoSetSurfaceSmoothingGroup ( workSurface , vertDataIndex , smoothingGroup[i] );			
+		}
+
+		/* add this vertex to the triangle */		
+		PicoSetSurfaceIndex ( workSurface , newVertIndex , vertDataIndex );
+	}
+}
Index: libs/picomodel/pm_ase.c
===================================================================
--- libs/picomodel/pm_ase.c	(revision 3603)
+++ libs/picomodel/pm_ase.c	(working copy)
@@ -1,1212 +1,1216 @@
-/* -----------------------------------------------------------------------------
-
-PicoModel Library
-
-Copyright (c) 2002, Randy Reddig & seaw0lf
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-Redistributions of source code must retain the above copyright notice, this list
-of conditions and the following disclaimer.
-
-Redistributions in binary form must reproduce the above copyright notice, this
-list of conditions and the following disclaimer in the documentation and/or
-other aseMaterialList provided with the distribution.
-
-Neither the names of the copyright holders nor the names of its contributors may
-be used to endorse or promote products derived from this software without
-specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
------------------------------------------------------------------------------ */
-
-
-/* marker */
-#define PM_ASE_C
-
-/* uncomment when debugging this module */
-//#define DEBUG_PM_ASE 
-//#define DEBUG_PM_ASE_EX
-
-
-/* dependencies */
-#include "picointernal.h"
-
-#ifdef DEBUG_PM_ASE
-#include "time.h"
-#endif
-
-/* plain white */
-static picoColor_t white = { 255, 255, 255, 255 };
-
-/* jhefty - multi-subobject material support */
-
-/* Material/SubMaterial management */
-/* A material should have 1..n submaterials assigned to it */
-
-typedef struct aseSubMaterial_s
-{
-	struct aseSubMaterial_s* next;
-	int subMtlId;
-	picoShader_t* shader;
-	
-} aseSubMaterial_t;
-
-typedef struct aseMaterial_s
-{
-	struct aseMaterial_s* next;
-	struct aseSubMaterial_s* subMtls;
-	int mtlId;		
-} aseMaterial_t;
-
-/* Material/SubMaterial management functions */
-static aseMaterial_t* _ase_get_material ( aseMaterial_t* list , int mtlIdParent )
-{
-	aseMaterial_t* mtl = list;
-
-	while ( mtl )
-	{
-		if ( mtlIdParent == mtl->mtlId )
-		{
-			break;
-		}
-		mtl = mtl->next;
-	}
-	return mtl;
-}
-
-static aseSubMaterial_t* _ase_get_submaterial ( aseMaterial_t* list, int  mtlIdParent , int subMtlId )
-{
-	aseMaterial_t* parent = _ase_get_material ( list , mtlIdParent );
-	aseSubMaterial_t* subMtl = NULL;
-
-	if ( !parent )
-	{
-		_pico_printf ( PICO_ERROR , "No ASE material exists with id %i\n" , mtlIdParent );
-		return NULL;
-	}
-
-	subMtl = parent->subMtls;
-	while ( subMtl )
-	{
-		if ( subMtlId == subMtl->subMtlId )
-		{
-			break;
-		}
-		subMtl = subMtl->next;
-	}
-	return subMtl;
-}
-
-aseSubMaterial_t* _ase_get_submaterial_or_default ( aseMaterial_t* materials, int  mtlIdParent , int subMtlId )
-{
-	aseSubMaterial_t* subMtl = _ase_get_submaterial( materials, mtlIdParent, subMtlId );
-	if(subMtl != NULL)
-	{
-		return subMtl;
-	}
-
-	/* ydnar: trying default submaterial */
-	subMtl = _ase_get_submaterial( materials, mtlIdParent, 0 );
-	if( subMtl != NULL )
-	{
-		return subMtl;
-	}
-
-	_pico_printf( PICO_ERROR, "Could not find material/submaterial for id %d/%d\n", mtlIdParent, subMtlId );
-	return NULL;
-}
-
-
-
-
-static aseMaterial_t* _ase_add_material( aseMaterial_t **list, int mtlIdParent )
-{
-	aseMaterial_t *mtl = _pico_calloc( 1, sizeof( aseMaterial_t ) );
-	mtl->mtlId = mtlIdParent;
-	mtl->subMtls = NULL;
-	mtl->next = *list;
-	*list = mtl;
-
-	return mtl;
-}
-
-static aseSubMaterial_t* _ase_add_submaterial( aseMaterial_t **list, int mtlIdParent, int subMtlId, picoShader_t* shader )
-{
-	aseMaterial_t *parent = _ase_get_material( *list,  mtlIdParent );
-	aseSubMaterial_t *subMtl = _pico_calloc( 1, sizeof ( aseSubMaterial_t ) );
-
-	if ( !parent )
-	{
-		parent = _ase_add_material ( list , mtlIdParent );
-	}
-
-	subMtl->shader = shader;
-	subMtl->subMtlId = subMtlId;
-	subMtl->next = parent->subMtls;
-	parent->subMtls = subMtl;
-
-	return subMtl;
-}
-
-static void _ase_free_materials( aseMaterial_t **list )
-{
-	aseMaterial_t* mtl = *list;
-	aseSubMaterial_t* subMtl = NULL;
-
-	aseMaterial_t* mtlTemp = NULL;
-	aseSubMaterial_t* subMtlTemp = NULL;
-
-	while ( mtl )
-	{
-		subMtl = mtl->subMtls;
-		while ( subMtl )
-		{
-			subMtlTemp = subMtl->next;
-			_pico_free ( subMtl );
-			subMtl = subMtlTemp;
-		}
-		mtlTemp = mtl->next;
-		_pico_free ( mtl );
-		mtl = mtlTemp;
-	}
-	(*list) = NULL;
-}
-
-#ifdef DEBUG_PM_ASE
-static void _ase_print_materials( aseMaterial_t *list )
-{
-	aseMaterial_t* mtl = list;
-	aseSubMaterial_t* subMtl = NULL;
-
-	while ( mtl )
-	{
-		_pico_printf ( PICO_NORMAL ,  "ASE Material %i" , mtl->mtlId );
-		subMtl = mtl->subMtls;
-		while ( subMtl )
-		{
-			_pico_printf ( PICO_NORMAL ,  " -- ASE SubMaterial %i - %s\n" , subMtl->subMtlId , subMtl->shader->name );
-			subMtl = subMtl->next;
-		}
-		mtl = mtl->next;
-	}
-}
-#endif //DEBUG_PM_ASE
-
-/* todo:
- * - apply material specific uv offsets to uv coordinates
- */
-
-/* _ase_canload:
- *  validates a 3dsmax ase model file.
- */
-static int _ase_canload( PM_PARAMS_CANLOAD )
-{
-	picoParser_t *p;
-	
-	
-	/* quick data length validation */
-	if( bufSize < 80 )
-		return PICO_PMV_ERROR_SIZE;
-	
-	/* keep the friggin compiler happy */
-	*fileName = *fileName;
-	
-	/* create pico parser */
-	p = _pico_new_parser( (picoByte_t*) buffer, bufSize );
-	if( p == NULL )
-		return PICO_PMV_ERROR_MEMORY;
-	
-	/* get first token */
-	if( _pico_parse_first( p ) == NULL)
-	{
-		return PICO_PMV_ERROR_IDENT;
-	}
-	
-	/* check first token */
-	if( _pico_stricmp( p->token, "*3dsmax_asciiexport" ) )
-	{
-		_pico_free_parser( p );
-		return PICO_PMV_ERROR_IDENT;
-	}
-	
-	/* free the pico parser object */
-	_pico_free_parser( p );
-	
-	/* file seems to be a valid ase file */
-	return PICO_PMV_OK;
-}
-
-typedef struct aseVertex_s aseVertex_t;
-struct aseVertex_s
-{
-	picoVec3_t xyz;
-	picoVec3_t normal;
-	picoIndex_t id;
-};
-
-typedef struct aseTexCoord_s aseTexCoord_t;
-struct aseTexCoord_s
-{
-	picoVec2_t texcoord;
-};
-
-typedef struct aseColor_s aseColor_t;
-struct aseColor_s
-{
-	picoColor_t color;
-};
-
-typedef struct aseFace_s aseFace_t;
-struct aseFace_s
-{
-	picoIndex_t indices[9];
-	picoIndex_t smoothingGroup;
-	picoIndex_t materialId;
-	picoIndex_t subMaterialId;
-};
-typedef aseFace_t* aseFacesIter_t;
-
-picoSurface_t* PicoModelFindOrAddSurface( picoModel_t *model, picoShader_t* shader )
-{
-	/* see if a surface already has the shader */
-	int i = 0;
-	for ( ; i < model->numSurfaces ; i++ )
-	{
-		picoSurface_t* workSurface = model->surface[i];
-		if ( workSurface->shader == shader )
-		{			
-			return workSurface;
-		}
-	}
-
-	/* no surface uses this shader yet, so create a new surface */
-
-	{
-		/* create a new surface in the model for the unique shader */
-		picoSurface_t* workSurface = PicoNewSurface(model);
-		if ( !workSurface )
-		{
-			_pico_printf ( PICO_ERROR , "Could not allocate a new surface!\n" );
-			return 0;
-		}
-
-		/* do surface setup */
-		PicoSetSurfaceType( workSurface, PICO_TRIANGLES );
-		PicoSetSurfaceName( workSurface, shader->name );
-		PicoSetSurfaceShader( workSurface, shader );
-
-		return workSurface;
-	}
-}
-
-/* _ase_submit_triangles - jhefty
- use the surface and the current face list to look up material/submaterial IDs
- and submit them to the model for proper processing
-
-The following still holds from ydnar's _ase_make_surface:
- indexes 0 1 2 = vert indexes
- indexes 3 4 5 = st indexes
- indexes 6 7 8 = color indexes (new)
-*/
-
-#if 0
-typedef picoIndex_t* picoIndexIter_t;
-
-typedef struct aseUniqueIndices_s aseUniqueIndices_t;
-struct aseUniqueIndices_s
-{
-	picoIndex_t* data;
-	picoIndex_t* last;
-
-	aseFace_t* faces;
-};
-
-size_t aseUniqueIndices_size(aseUniqueIndices_t* self)
-{
-	return self->last - self->data;
-}
-
-void aseUniqueIndices_reserve(aseUniqueIndices_t* self, picoIndex_t size)
-{
-	self->data = self->last = (picoIndex_t*)_pico_calloc(size, sizeof(picoIndex_t));
-}
-
-void aseUniqueIndices_clear(aseUniqueIndices_t* self)
-{
-	_pico_free(self->data);
-}
-
-void aseUniqueIndices_pushBack(aseUniqueIndices_t* self, picoIndex_t index)
-{
-	*self->last++ = index;
-}
-
-picoIndex_t aseFaces_getVertexIndex(aseFace_t* faces, picoIndex_t index)
-{
-	return faces[index / 3].indices[index % 3];
-}
-
-picoIndex_t aseFaces_getTexCoordIndex(aseFace_t* faces, picoIndex_t index)
-{
-	return faces[index / 3].indices[(index % 3) + 3];
-}
-
-picoIndex_t aseFaces_getColorIndex(aseFace_t* faces, picoIndex_t index)
-{
-	return faces[index / 3].indices[(index % 3) + 6];
-}
-
-int aseUniqueIndex_equal(aseFace_t* faces, picoIndex_t index, picoIndex_t other)
-{
-	return aseFaces_getVertexIndex(faces, index) == aseFaces_getVertexIndex(faces, other)
-		&& aseFaces_getTexCoordIndex(faces, index) == aseFaces_getTexCoordIndex(faces, other)
-		&& aseFaces_getColorIndex(faces, index) == aseFaces_getColorIndex(faces, other);
-}
-
-picoIndex_t aseUniqueIndices_insertUniqueVertex(aseUniqueIndices_t* self, picoIndex_t index)
-{
-	picoIndexIter_t i = self->data;
-	for(; i != self->last; ++i)
-	{
-		picoIndex_t other = (picoIndex_t)(i - self->data);
-		if(aseUniqueIndex_equal(self->faces, index, other))
-		{
-			return other;
-		}
-	}
-
-	aseUniqueIndices_pushBack(self, index);
-	return (picoIndex_t)(aseUniqueIndices_size(self) - 1);
-}
-
-static void _ase_submit_triangles_unshared ( picoModel_t* model , aseMaterial_t* materials , aseVertex_t* vertices, aseTexCoord_t* texcoords, aseColor_t* colors, aseFace_t* faces, int numFaces, int meshHasNormals )
-{
-	aseFacesIter_t i = faces, end = faces + numFaces;
-
-	aseUniqueIndices_t indices;
-	aseUniqueIndices_t remap;
-	aseUniqueIndices_reserve(&indices, numFaces * 3);
-	aseUniqueIndices_reserve(&remap, numFaces * 3);
-	indices.faces = faces;
-
-	for(; i != end; ++i)
-	{
-		/* look up the shader for the material/submaterial pair */
-		aseSubMaterial_t* subMtl = _ase_get_submaterial_or_default( materials, (*i).materialId, (*i).subMaterialId );
-		if( subMtl == NULL )
-		{
-			return;
-		}
-
-		{
-			picoSurface_t* surface = PicoModelFindOrAddSurface(model, subMtl->shader);
-			int j;
-			/* we pull the data from the vertex, color and texcoord arrays using the face index data */
-			for ( j = 0 ; j < 3 ; j ++ )
-			{
-				picoIndex_t index = (picoIndex_t)(((i - faces) * 3) + j);
-				picoIndex_t size = (picoIndex_t)aseUniqueIndices_size(&indices);
-				picoIndex_t unique = aseUniqueIndices_insertUniqueVertex(&indices, index);
-
-				picoIndex_t numVertexes = PicoGetSurfaceNumVertexes(surface);
-				picoIndex_t numIndexes = PicoGetSurfaceNumIndexes(surface);
-
-				aseUniqueIndices_pushBack(&remap, numIndexes);
-
-				PicoSetSurfaceIndex(surface, numIndexes, remap.data[unique]);
-
-				if(unique == size)
-				{
-					PicoSetSurfaceXYZ(surface, numVertexes, vertices[(*i).indices[j]].xyz);
-					PicoSetSurfaceNormal(surface, numVertexes, vertices[(*i).indices[j]].normal);
-					PicoSetSurfaceST(surface, 0, numVertexes, texcoords[(*i).indices[j + 3]].texcoord);
-
-					if ( (*i).indices[j + 6] >= 0 )
-					{
-						PicoSetSurfaceColor(surface, 0, numVertexes, colors[(*i).indices[j + 6]].color);
-					}
-					else
-					{
-						PicoSetSurfaceColor(surface, 0, numVertexes, white);
-					}
-
-					PicoSetSurfaceSmoothingGroup(surface, numVertexes, (vertices[(*i).indices[j]].id * (1 << 16)) + (*i).smoothingGroup);
-				}
-			}
-		}
-	}
-
-	aseUniqueIndices_clear(&indices);
-	aseUniqueIndices_clear(&remap);
-}
-
-#endif
-
-static void _ase_submit_triangles( picoModel_t* model , aseMaterial_t* materials , aseVertex_t* vertices, aseTexCoord_t* texcoords, aseColor_t* colors, aseFace_t* faces, int numFaces )
-{
-	aseFacesIter_t i = faces, end = faces + numFaces;
-	for(; i != end; ++i)
-	{
-		/* look up the shader for the material/submaterial pair */
-		aseSubMaterial_t* subMtl = _ase_get_submaterial_or_default( materials, (*i).materialId, (*i).subMaterialId );
-		if( subMtl == NULL )
-		{
-			return;
-		}
-
-		{
-			picoVec3_t* xyz[3];
-			picoVec3_t* normal[3];
-			picoVec2_t* st[3];
-			picoColor_t* color[3];
-			picoIndex_t smooth[3];
-			int j;
-			/* we pull the data from the vertex, color and texcoord arrays using the face index data */
-			for ( j = 0 ; j < 3 ; j ++ )
-			{
-				xyz[j]    = &vertices[(*i).indices[j]].xyz;
-				normal[j] = &vertices[(*i).indices[j]].normal;
-				st[j]     = &texcoords[(*i).indices[j + 3]].texcoord;
-	 	 	
-				if( colors != NULL && (*i).indices[j + 6] >= 0 )
-				{
-					color[j] = &colors[(*i).indices[j + 6]].color;
-				}
-				else
-				{
-					color[j] = &white;
-				}
-
-				smooth[j] = (vertices[(*i).indices[j]].id * (1 << 16)) + (*i).smoothingGroup; /* don't merge vertices */
-				
-			}
-
-			/* submit the triangle to the model */
-			PicoAddTriangleToModel ( model , xyz , normal , 1 , st , 1 , color , subMtl->shader, smooth );
-		}
-	}
-}
-
-static void shadername_convert(char* shaderName)
-{
-  /* unix-style path separators */
-  char* s = shaderName;
-  for(; *s != '\0'; ++s)
-  {
-    if(*s == '\\')
-    {
-      *s = '/';
-    }
-  }
-}
-
-
-/* _ase_load:
- *  loads a 3dsmax ase model file.
-*/
-static picoModel_t *_ase_load( PM_PARAMS_LOAD )
-{
-	picoModel_t    *model;
-	picoParser_t   *p;
-	char			lastNodeName[ 1024 ];
-
-	aseVertex_t* vertices = NULL;
-	aseTexCoord_t* texcoords = NULL;
-	aseColor_t* colors = NULL;
-	aseFace_t* faces = NULL;
-	int numVertices = 0;
-	int numFaces = 0;
-	int numTextureVertices = 0;
-	int numTextureVertexFaces = 0;
-	int numColorVertices = 0;
-	int numColorVertexFaces = 0;
-	int vertexId = 0;
-
-	aseMaterial_t* materials = NULL;
-
-#ifdef DEBUG_PM_ASE
-	clock_t start, finish;
-	double elapsed;
-	start = clock();
-#endif
-
-	/* helper */
-	#define _ase_error_return(m) \
-	{ \
-		_pico_printf( PICO_ERROR,"%s in ASE, line %d.",m,p->curLine); \
-		_pico_free_parser( p ); \
-		PicoFreeModel( model ); \
-		return NULL; \
-	}
-	/* create a new pico parser */
-	p = _pico_new_parser( (picoByte_t *)buffer,bufSize );
-	if (p == NULL) return NULL;
-
-	/* create a new pico model */
-	model = PicoNewModel();
-	if (model == NULL)
-	{
-		_pico_free_parser( p );
-		return NULL;
-	}
-	/* do model setup */
-	PicoSetModelFrameNum( model, frameNum );
-	PicoSetModelName( model, fileName );
-	PicoSetModelFileName( model, fileName );
-
-	/* initialize some stuff */
-	memset( lastNodeName,0,sizeof(lastNodeName) );
-
-	/* parse ase model file */
-	while( 1 )
-	{
-		/* get first token on line */
-		if (_pico_parse_first( p ) == NULL)
-			break;
-
-		/* we just skip empty lines */
-		if (p->token == NULL || !strlen( p->token ))
-			continue;
-
-		/* we skip invalid ase statements */
-		if (p->token[0] != '*' && p->token[0] != '{' && p->token[0] != '}')
-		{
-			_pico_parse_skip_rest( p );
-			continue;
-		}
-		/* remember node name */
-		if (!_pico_stricmp(p->token,"*node_name"))
-		{
-			/* read node name */
-			char *ptr = _pico_parse( p,0 );
-			if (ptr == NULL)
-				_ase_error_return("Node name parse error");
-
-			/* remember node name */
-			strncpy( lastNodeName,ptr,sizeof(lastNodeName) );
-		}
-		/* model mesh (originally contained within geomobject) */
-		else if (!_pico_stricmp(p->token,"*mesh"))
-		{
-			/* finish existing surface */
-			_ase_submit_triangles(model, materials, vertices, texcoords, colors, faces, numFaces);
-			_pico_free(faces);
-			_pico_free(vertices);
-			_pico_free(texcoords);
-			_pico_free(colors);
-			colors = faces = vertices = texcoords = NULL; /* OrbWeaver: reset all pointers to avoid double-free */
-		}
-		else if (!_pico_stricmp(p->token,"*mesh_numvertex"))
-		{
-			if (!_pico_parse_int( p, &numVertices) )
-				_ase_error_return("Missing MESH_NUMVERTEX value");
-
-			vertices = _pico_calloc(numVertices, sizeof(aseVertex_t));
-		}
-		else if (!_pico_stricmp(p->token,"*mesh_numfaces"))
-		{
-			if (!_pico_parse_int( p, &numFaces) )
-				_ase_error_return("Missing MESH_NUMFACES value");
-
-			faces = _pico_calloc(numFaces, sizeof(aseFace_t));
-		}
-		else if (!_pico_stricmp(p->token,"*mesh_numtvertex"))
-		{
-			if (!_pico_parse_int( p, &numTextureVertices) )
-				_ase_error_return("Missing MESH_NUMTVERTEX value");
-
-			texcoords = _pico_calloc(numTextureVertices, sizeof(aseTexCoord_t));
-		}
-		else if (!_pico_stricmp(p->token,"*mesh_numtvfaces"))
-		{
-			if (!_pico_parse_int( p, &numTextureVertexFaces) )
-				_ase_error_return("Missing MESH_NUMTVFACES value");
-		}
-		else if (!_pico_stricmp(p->token,"*mesh_numcvertex"))
-		{
-			if (!_pico_parse_int( p, &numColorVertices) )
-				_ase_error_return("Missing MESH_NUMCVERTEX value");
-
-			colors = _pico_calloc(numColorVertices, sizeof(aseColor_t));
-			memset( colors, 255, numColorVertices * sizeof( aseColor_t ) );	/* ydnar: force colors to white initially */
-		}
-		else if (!_pico_stricmp(p->token,"*mesh_numcvfaces"))
-		{
-			if (!_pico_parse_int( p, &numColorVertexFaces) )
-				_ase_error_return("Missing MESH_NUMCVFACES value");
-		}
-		/* mesh material reference. this usually comes at the end of */
-		/* geomobjects after the mesh blocks. we must assume that the */
-		/* new mesh was already created so all we can do here is assign */
-		/* the material reference id (shader index) now. */
-		else if (!_pico_stricmp(p->token,"*material_ref"))
-		{
-			int mtlId;
-
-			/* get the material ref (0..n) */
-			if (!_pico_parse_int( p,&mtlId) )
-				_ase_error_return("Missing material reference ID");
-
-			{
-				int i = 0;
-				/* fix up all of the aseFaceList in the surface to point to the parent material */
-				/* we've already saved off their subMtl */
-				for(; i < numFaces; ++i)
-				{
-					faces[i].materialId = mtlId;
-				}
-			}
-		}
-		/* model mesh vertex */
-		else if (!_pico_stricmp(p->token,"*mesh_vertex"))
-		{
-			int			index;
-
-			if( numVertices == 0 )
-				_ase_error_return("Vertex parse error");
-
-			/* get vertex data (orig: index +y -x +z) */
-			if (!_pico_parse_int( p,&index ))
-				_ase_error_return("Vertex parse error");
-			if (!_pico_parse_vec( p,vertices[index].xyz ))
-				_ase_error_return("Vertex parse error");
-
-			vertices[index].id = vertexId++;
-		}
-		/* model mesh vertex normal */
-		else if (!_pico_stricmp(p->token,"*mesh_vertexnormal"))
-		{
-			int			index;
-
-			if( numVertices == 0 )
-				_ase_error_return("Vertex parse error");
-
-			/* get vertex data (orig: index +y -x +z) */
-			if (!_pico_parse_int( p,&index ))
-				_ase_error_return("Vertex parse error");
-			if (!_pico_parse_vec( p,vertices[index].normal ))
-				_ase_error_return("Vertex parse error");
-		}
-		/* model mesh face */
-		else if (!_pico_stricmp(p->token,"*mesh_face"))
-		{
-			picoIndex_t indexes[3];
-			int index;
-			
-			if( numFaces == 0 )
-				_ase_error_return("Face parse error");
-
-			/* get face index */
-			if (!_pico_parse_int( p,&index ))
-				_ase_error_return("Face parse error");
-
-			/* get 1st vertex index */
-			_pico_parse( p,0 );
-			if (!_pico_parse_int( p,&indexes[0] ))
-				_ase_error_return("Face parse error");
-
-			/* get 2nd vertex index */
-			_pico_parse( p,0 );
-			if (!_pico_parse_int( p,&indexes[1] ))
-				_ase_error_return("Face parse error");
-
-			/* get 3rd vertex index */
-			_pico_parse( p,0 );
-			if (!_pico_parse_int( p,&indexes[2] ))
-				_ase_error_return("Face parse error");
-			
-			/* parse to the subMaterial ID */
-			while ( 1 )
-			{
-				if (!_pico_parse (p,0)) /* EOL */
-				{
-					break;
-				}
-				if (!_pico_stricmp (p->token,"*MESH_SMOOTHING" ))
-				{
-					_pico_parse_int ( p , &faces[index].smoothingGroup );
-				}
-				if (!_pico_stricmp (p->token,"*MESH_MTLID" ))
-				{
-					_pico_parse_int ( p , &faces[index].subMaterialId );
-				}
-			}
-			
-			faces[index].materialId = 0;
-			faces[index].indices[0] = indexes[2];
-			faces[index].indices[1] = indexes[1];
-			faces[index].indices[2] = indexes[0];
-		}
-		/* model texture vertex */
-		else if (!_pico_stricmp(p->token,"*mesh_tvert"))
-		{
-			int			index;
-
-			if( numVertices == 0 )
-				_ase_error_return("Texture Vertex parse error");
-
-			/* get uv vertex index */
-			if (!_pico_parse_int( p,&index ) || index >= numTextureVertices)
-				_ase_error_return("Texture vertex parse error");
-
-			/* get uv vertex s */
-			if (!_pico_parse_double( p,&texcoords[index].texcoord[0] ))
-				_ase_error_return("Texture vertex parse error");
-
-			/* get uv vertex t */
-			if (!_pico_parse_double( p,&texcoords[index].texcoord[1] ))
-				_ase_error_return("Texture vertex parse error");
-			
-			/* ydnar: invert t */
-			texcoords[index].texcoord[ 1 ] = 1.0f - texcoords[index].texcoord[ 1 ];
-		}
-		/* ydnar: model mesh texture face */
-		else if( !_pico_stricmp( p->token, "*mesh_tface" ) )
-		{
-			picoIndex_t indexes[3];
-			int			index;
-			
-			if( numFaces == 0 )
-				_ase_error_return("Texture face parse error");
-			
-			/* get face index */
-			if (!_pico_parse_int( p,&index ))
-				_ase_error_return("Texture face parse error");
-			
-			/* get 1st vertex index */
-			if (!_pico_parse_int( p,&indexes[0] ))
-				_ase_error_return("Texture face parse error");
-			
-			/* get 2nd vertex index */
-			if (!_pico_parse_int( p,&indexes[1] ))
-				_ase_error_return("Texture face parse error");
-			
-			/* get 3rd vertex index */
-			if (!_pico_parse_int( p,&indexes[2] ))
-				_ase_error_return("Texture face parse error");
-
-			faces[index].indices[3] = indexes[2];
-			faces[index].indices[4] = indexes[1];
-			faces[index].indices[5] = indexes[0];
-		}
-		/* model color vertex */
-		else if (!_pico_stricmp(p->token,"*mesh_vertcol"))
-		{
-			int			index;
-			float		colorInput;
-
-			if( numVertices == 0 )
-				_ase_error_return("Color Vertex parse error");
-
-			/* get color vertex index */
-			if (!_pico_parse_int( p,&index ))
-				_ase_error_return("Color vertex parse error");
-
-			/* get R component */
-			if (!_pico_parse_float( p,&colorInput ))
-				_ase_error_return("Color vertex parse error");
-			colors[index].color[0] = (picoByte_t)(colorInput * 255);
-
-			/* get G component */
-			if (!_pico_parse_float( p,&colorInput ))
-				_ase_error_return("Color vertex parse error");
-			colors[index].color[1] = (picoByte_t)(colorInput * 255);
-
-			/* get B component */
-			if (!_pico_parse_float( p,&colorInput ))
-				_ase_error_return("Color vertex parse error");
-			colors[index].color[2] = (picoByte_t)(colorInput * 255);
-			
-			/* leave alpha alone since we don't get any data from the ASE format */
-			colors[index].color[3] = 255;
-		}
-		/* model color face */
-		else if (!_pico_stricmp(p->token,"*mesh_cface"))
-		{
-			picoIndex_t indexes[3];
-			int			index;
-
-			if( numFaces == 0 )
-				_ase_error_return("Face parse error");
-
-			/* get face index */
-			if (!_pico_parse_int( p,&index ))
-				_ase_error_return("Face parse error");
-
-			/* get 1st cvertex index */
-			//			_pico_parse( p,0 );
-			if (!_pico_parse_int( p,&indexes[0] ))
-				_ase_error_return("Face parse error");
-
-			/* get 2nd cvertex index */
-			//			_pico_parse( p,0 );
-			if (!_pico_parse_int( p,&indexes[1] ))
-				_ase_error_return("Face parse error");
-
-			/* get 3rd cvertex index */
-			//			_pico_parse( p,0 );
-			if (!_pico_parse_int( p,&indexes[2] ))
-				_ase_error_return("Face parse error");
-
-			faces[index].indices[6] = indexes[2];
-			faces[index].indices[7] = indexes[1];
-			faces[index].indices[8] = indexes[0];
-		}
-		/* model material */
-		else if( !_pico_stricmp( p->token, "*material" ) )
-		{
-			aseSubMaterial_t*	subMaterial = NULL;
-			picoShader_t		*shader;
-			int					level = 1, index;
-			char				materialName[ 1024 ];
-			float				transValue = 0.0f, shineValue = 1.0f;
-			picoColor_t			ambientColor, diffuseColor, specularColor;
-			char				*mapname = NULL;
-			int					subMtlId, subMaterialLevel = -1;
-			
-			
-			/* get material index */
-			_pico_parse_int( p,&index );
-			
-			/* check brace */
-			if (!_pico_parse_check(p,1,"{"))
-				_ase_error_return("Material missing opening brace");
-			
-			/* parse material block */
-			while( 1 )
-			{
-				/* get next token */
-				if (_pico_parse(p,1) == NULL) break;
-				if (!strlen(p->token)) continue;
-
-				/* handle levels */
-				if (p->token[0] == '{') level++;
-				if (p->token[0] == '}') level--;
-				if (!level) break;
-
-				if( level == subMaterialLevel )
-				{
-					/* set material name */
-					_pico_first_token( materialName );
-          shadername_convert(materialName);
-					PicoSetShaderName( shader, materialName);
-
-					/* set shader's transparency */
-					PicoSetShaderTransparency( shader,transValue );
-
-					/* set shader's ambient color */
-					PicoSetShaderAmbientColor( shader,ambientColor );
-
-					/* set diffuse alpha to transparency */
-					diffuseColor[3] = (picoByte_t)( transValue * 255.0 );
-
-					/* set shader's diffuse color */
-					PicoSetShaderDiffuseColor( shader,diffuseColor );
-
-					/* set shader's specular color */
-					PicoSetShaderSpecularColor( shader,specularColor );
-
-					/* set shader's shininess */
-					PicoSetShaderShininess( shader,shineValue );
-
-					/* set material map name */
-					PicoSetShaderMapName( shader, mapname );
-
-					subMaterial = _ase_add_submaterial( &materials, index, subMtlId, shader );
-					subMaterialLevel = -1;
-				}
-
-				/* parse submaterial index */
-				if (!_pico_stricmp(p->token,"*submaterial"))
-				{											
-					/* allocate new pico shader */
-					_pico_parse_int( p , &subMtlId );
-
-					shader = PicoNewShader( model );
-					if (shader == NULL)
-					{
-						PicoFreeModel( model );
-						return NULL;
-					}			
-					subMaterialLevel = level;
-				}
-				/* parse material name */
-				else if (!_pico_stricmp(p->token,"*material_name"))
-				{
-					char* name = _pico_parse(p,0);
-					if ( name == NULL)
-						_ase_error_return("Missing material name");
-					
-					strcpy ( materialName , name );
-					/* skip rest and continue with next token */
-					_pico_parse_skip_rest( p );
-					continue;
-				}
-				/* parse material transparency */
-				else if (!_pico_stricmp(p->token,"*material_transparency"))
-				{
-					/* get transparency value from ase */
-					if (!_pico_parse_float( p,&transValue ))
-						_ase_error_return("Material transparency parse error");
-
-					/* skip rest and continue with next token */
-					_pico_parse_skip_rest( p );
-					continue;
-				}
-				/* parse material shininess */
-				else if (!_pico_stricmp(p->token,"*material_shine"))
-				{
-					/* remark:
-					 * - not sure but instead of '*material_shine' i might
-					 *   need to use '*material_shinestrength' */
-
-					/* get shine value from ase */
-					if (!_pico_parse_float( p,&shineValue ))
-						_ase_error_return("Material shine parse error");
-
-					/* scale ase shine range 0..1 to pico range 0..127 */
-					shineValue *= 128.0;
-
-					/* skip rest and continue with next token */
-					_pico_parse_skip_rest( p );
-					continue;
-				}
-				/* parse ambient material color */
-				else if (!_pico_stricmp(p->token,"*material_ambient"))
-				{
-					picoVec3_t  vec;
-					/* get r,g,b float values from ase */
-					if (!_pico_parse_vec( p,vec ))
-						_ase_error_return("Material color parse error");
-
-					/* setup 0..255 range color values */
-					ambientColor[ 0 ] = (int)( vec[ 0 ] * 255.0 );
-					ambientColor[ 1 ] = (int)( vec[ 1 ] * 255.0 );
-					ambientColor[ 2 ] = (int)( vec[ 2 ] * 255.0 );
-					ambientColor[ 3 ] = (int)( 255 );
-
-					/* skip rest and continue with next token */
-					_pico_parse_skip_rest( p );
-					continue;
-				}
-				/* parse diffuse material color */
-				else if (!_pico_stricmp(p->token,"*material_diffuse"))
-				{
-					picoVec3_t  vec;
-
-					/* get r,g,b float values from ase */
-					if (!_pico_parse_vec( p,vec ))
-						_ase_error_return("Material color parse error");
-
-					/* setup 0..255 range color */
-					diffuseColor[ 0 ] = (int)( vec[ 0 ] * 255.0 );
-					diffuseColor[ 1 ] = (int)( vec[ 1 ] * 255.0 );
-					diffuseColor[ 2 ] = (int)( vec[ 2 ] * 255.0 );
-					diffuseColor[ 3 ] = (int)( 255 );
-
-					/* skip rest and continue with next token */
-					_pico_parse_skip_rest( p );
-					continue;
-				}
-				/* parse specular material color */
-				else if (!_pico_stricmp(p->token,"*material_specular"))
-				{
-					picoVec3_t  vec;
-
-					/* get r,g,b float values from ase */
-					if (!_pico_parse_vec( p,vec ))
-						_ase_error_return("Material color parse error");
-
-					/* setup 0..255 range color */
-					specularColor[ 0 ] = (int)( vec[ 0 ] * 255 );
-					specularColor[ 1 ] = (int)( vec[ 1 ] * 255 );
-					specularColor[ 2 ] = (int)( vec[ 2 ] * 255 );
-					specularColor[ 3 ] = (int)( 255 );
-
-					/* skip rest and continue with next token */
-					_pico_parse_skip_rest( p );
-					continue;
-				}
-				/* material diffuse map */
-				else if (!_pico_stricmp(p->token,"*map_diffuse") )
-				{
-					int sublevel = 0;
-
-					/* parse material block */
-					while( 1 )
-					{
-						/* get next token */
-						if (_pico_parse(p,1) == NULL) break;
-						if (!strlen(p->token)) continue;
-						
-						/* handle levels */
-						if (p->token[0] == '{') sublevel++;
-						if (p->token[0] == '}') sublevel--;
-						if (!sublevel) break;
-						
-						/* parse diffuse map bitmap */
-						if (!_pico_stricmp(p->token,"*bitmap"))
-						{
-							char* name = _pico_parse(p,0);
-							if (name == NULL)
-								_ase_error_return("Missing material map bitmap name");
-							mapname = _pico_alloc ( strlen ( name ) + 1 );
-							strcpy ( mapname, name );
-							/* skip rest and continue with next token */
-							_pico_parse_skip_rest( p );
-							continue;
-						}
-					}
-				}
-				/* end map_diffuse block */
-			}
-			/* end material block */
-
-			if( subMaterial == NULL )
-			{
-				/* allocate new pico shader */
-				shader = PicoNewShader( model );
-				if (shader == NULL)
-				{
-					PicoFreeModel( model );
-					return NULL;
-				}
-
-				/* set material name */
-        shadername_convert(materialName);
-				PicoSetShaderName( shader,materialName );
-
-				/* set shader's transparency */
-				PicoSetShaderTransparency( shader,transValue );
-
-				/* set shader's ambient color */
-				PicoSetShaderAmbientColor( shader,ambientColor );
-
-				/* set diffuse alpha to transparency */
-				diffuseColor[3] = (picoByte_t)( transValue * 255.0 );
-
-				/* set shader's diffuse color */
-				PicoSetShaderDiffuseColor( shader,diffuseColor );
-
-				/* set shader's specular color */
-				PicoSetShaderSpecularColor( shader,specularColor );
-
-				/* set shader's shininess */
-				PicoSetShaderShininess( shader,shineValue );
-
-				/* set material map name */
-				PicoSetShaderMapName( shader, mapname );
-
-        /* extract shadername from bitmap path */
-        if(mapname != NULL)
-        {
-          char* p = mapname;
-
-          /* convert to shader-name format */
-          shadername_convert(mapname);
-          {
-            /* remove extension */
-            char* last_period = strrchr(p, '.');
-            if(last_period != NULL)
-            {
-              *last_period = '\0';
-            }
-          }
-
-          /* find game root */
-          for(; *p != '\0'; ++p)
-          {
-            if(_pico_strnicmp(p, "quake", 5) == 0 || _pico_strnicmp(p, "doom", 4) == 0)
-            {
-              break;
-            }
-          }
-          /* root-relative */
-          for(; *p != '\0'; ++p)
-          {
-            if(*p == '/')
-            {
-              ++p;
-              break;
-            }
-          }
-          /* game-relative */
-          for(; *p != '\0'; ++p)
-          {
-            if(*p == '/')
-            {
-              ++p;
-              break;
-            }
-          }
-
-          if(*p != '\0')
-          {
-				    /* set material name */
-				    PicoSetShaderName( shader,p );
-          }
-        }
-
-        /* this is just a material with 1 submaterial */
-				subMaterial = _ase_add_submaterial( &materials, index, 0, shader );
-			}
-			
-			/* ydnar: free mapname */
-			if( mapname != NULL )
-				_pico_free( mapname );
-		}	// !_pico_stricmp ( "*material" )
-
-		/* skip unparsed rest of line and continue */
-		_pico_parse_skip_rest( p );
-	}
-	
-	/* ydnar: finish existing surface */
-	_ase_submit_triangles(model, materials, vertices, texcoords, colors, faces, numFaces);
-	_pico_free(faces);
-	_pico_free(vertices);
-	_pico_free(texcoords);
-	_pico_free(colors);
-
-#ifdef DEBUG_PM_ASE
-	_ase_print_materials(materials);
-	finish = clock();
-	elapsed = (double)(finish - start) / CLOCKS_PER_SEC;
-	_pico_printf( PICO_NORMAL, "Loaded model in in %-.2f second(s)\n", elapsed );
-#endif //DEBUG_PM_ASE
-
-	_ase_free_materials(&materials);
-
-  _pico_free_parser( p );
-
-	/* return allocated pico model */
-	return model;
-}
-
-/* pico file format module definition */
-const picoModule_t picoModuleASE =
-{
-	"1.0",					/* module version string */
-	"Autodesk 3DSMAX ASCII",	/* module display name */
-	"Jared Hefty, seaw0lf",					/* author's name */
-	"2003 Jared Hefty, 2002 seaw0lf",				/* module copyright */
-	{
-		"ase",NULL,NULL,NULL	/* default extensions to use */
-	},
-	_ase_canload,				/* validation routine */
-	_ase_load,					/* load routine */
-	 NULL,						/* save validation routine */
-	 NULL						/* save routine */
-};
+/* -----------------------------------------------------------------------------
+
+PicoModel Library
+
+Copyright (c) 2002, Randy Reddig & seaw0lf
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+Redistributions of source code must retain the above copyright notice, this list
+of conditions and the following disclaimer.
+
+Redistributions in binary form must reproduce the above copyright notice, this
+list of conditions and the following disclaimer in the documentation and/or
+other aseMaterialList provided with the distribution.
+
+Neither the names of the copyright holders nor the names of its contributors may
+be used to endorse or promote products derived from this software without
+specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+----------------------------------------------------------------------------- */
+
+
+/* marker */
+#define PM_ASE_C
+
+/* uncomment when debugging this module */
+//#define DEBUG_PM_ASE 
+//#define DEBUG_PM_ASE_EX
+
+
+/* dependencies */
+#include "picointernal.h"
+
+#ifdef DEBUG_PM_ASE
+#include "time.h"
+#endif
+
+/* plain white */
+static picoColor_t white = { 255, 255, 255, 255 };
+
+/* jhefty - multi-subobject material support */
+
+/* Material/SubMaterial management */
+/* A material should have 1..n submaterials assigned to it */
+
+typedef struct aseSubMaterial_s
+{
+	struct aseSubMaterial_s* next;
+	int subMtlId;
+	picoShader_t* shader;
+	
+} aseSubMaterial_t;
+
+typedef struct aseMaterial_s
+{
+	struct aseMaterial_s* next;
+	struct aseSubMaterial_s* subMtls;
+	int mtlId;		
+} aseMaterial_t;
+
+/* Material/SubMaterial management functions */
+static aseMaterial_t* _ase_get_material ( aseMaterial_t* list , int mtlIdParent )
+{
+	aseMaterial_t* mtl = list;
+
+	while ( mtl )
+	{
+		if ( mtlIdParent == mtl->mtlId )
+		{
+			break;
+		}
+		mtl = mtl->next;
+	}
+	return mtl;
+}
+
+static aseSubMaterial_t* _ase_get_submaterial ( aseMaterial_t* list, int  mtlIdParent , int subMtlId )
+{
+	aseMaterial_t* parent = _ase_get_material ( list , mtlIdParent );
+	aseSubMaterial_t* subMtl = NULL;
+
+	if ( !parent )
+	{
+		_pico_printf ( PICO_ERROR , "No ASE material exists with id %i\n" , mtlIdParent );
+		return NULL;
+	}
+
+	subMtl = parent->subMtls;
+	while ( subMtl )
+	{
+		if ( subMtlId == subMtl->subMtlId )
+		{
+			break;
+		}
+		subMtl = subMtl->next;
+	}
+	return subMtl;
+}
+
+aseSubMaterial_t* _ase_get_submaterial_or_default ( aseMaterial_t* materials, int  mtlIdParent , int subMtlId )
+{
+	aseSubMaterial_t* subMtl = _ase_get_submaterial( materials, mtlIdParent, subMtlId );
+	if(subMtl != NULL)
+	{
+		return subMtl;
+	}
+
+	/* ydnar: trying default submaterial */
+	subMtl = _ase_get_submaterial( materials, mtlIdParent, 0 );
+	if( subMtl != NULL )
+	{
+		return subMtl;
+	}
+
+	_pico_printf( PICO_ERROR, "Could not find material/submaterial for id %d/%d\n", mtlIdParent, subMtlId );
+	return NULL;
+}
+
+
+
+
+static aseMaterial_t* _ase_add_material( aseMaterial_t **list, int mtlIdParent )
+{
+	aseMaterial_t *mtl = _pico_calloc( 1, sizeof( aseMaterial_t ) );
+	mtl->mtlId = mtlIdParent;
+	mtl->subMtls = NULL;
+	mtl->next = *list;
+	*list = mtl;
+
+	return mtl;
+}
+
+static aseSubMaterial_t* _ase_add_submaterial( aseMaterial_t **list, int mtlIdParent, int subMtlId, picoShader_t* shader )
+{
+	aseMaterial_t *parent = _ase_get_material( *list,  mtlIdParent );
+	aseSubMaterial_t *subMtl = _pico_calloc( 1, sizeof ( aseSubMaterial_t ) );
+
+	if ( !parent )
+	{
+		parent = _ase_add_material ( list , mtlIdParent );
+	}
+
+	subMtl->shader = shader;
+	subMtl->subMtlId = subMtlId;
+	subMtl->next = parent->subMtls;
+	parent->subMtls = subMtl;
+
+	return subMtl;
+}
+
+static void _ase_free_materials( aseMaterial_t **list )
+{
+	aseMaterial_t* mtl = *list;
+	aseSubMaterial_t* subMtl = NULL;
+
+	aseMaterial_t* mtlTemp = NULL;
+	aseSubMaterial_t* subMtlTemp = NULL;
+
+	while ( mtl )
+	{
+		subMtl = mtl->subMtls;
+		while ( subMtl )
+		{
+			subMtlTemp = subMtl->next;
+			_pico_free ( subMtl );
+			subMtl = subMtlTemp;
+		}
+		mtlTemp = mtl->next;
+		_pico_free ( mtl );
+		mtl = mtlTemp;
+	}
+	(*list) = NULL;
+}
+
+#ifdef DEBUG_PM_ASE
+static void _ase_print_materials( aseMaterial_t *list )
+{
+	aseMaterial_t* mtl = list;
+	aseSubMaterial_t* subMtl = NULL;
+
+	while ( mtl )
+	{
+		_pico_printf ( PICO_NORMAL ,  "ASE Material %i" , mtl->mtlId );
+		subMtl = mtl->subMtls;
+		while ( subMtl )
+		{
+			_pico_printf ( PICO_NORMAL ,  " -- ASE SubMaterial %i - %s\n" , subMtl->subMtlId , subMtl->shader->name );
+			subMtl = subMtl->next;
+		}
+		mtl = mtl->next;
+	}
+}
+#endif //DEBUG_PM_ASE
+
+/* todo:
+ * - apply material specific uv offsets to uv coordinates
+ */
+
+/* _ase_canload:
+ *  validates a 3dsmax ase model file.
+ */
+static int _ase_canload( PM_PARAMS_CANLOAD )
+{
+	picoParser_t *p;
+	
+	
+	/* quick data length validation */
+	if( bufSize < 80 )
+		return PICO_PMV_ERROR_SIZE;
+	
+	/* keep the friggin compiler happy */
+	*fileName = *fileName;
+	
+	/* create pico parser */
+	p = _pico_new_parser( (picoByte_t*) buffer, bufSize );
+	if( p == NULL )
+		return PICO_PMV_ERROR_MEMORY;
+	
+	/* get first token */
+	if( _pico_parse_first( p ) == NULL)
+	{
+		return PICO_PMV_ERROR_IDENT;
+	}
+	
+	/* check first token */
+	if( _pico_stricmp( p->token, "*3dsmax_asciiexport" ) )
+	{
+		_pico_free_parser( p );
+		return PICO_PMV_ERROR_IDENT;
+	}
+	
+	/* free the pico parser object */
+	_pico_free_parser( p );
+	
+	/* file seems to be a valid ase file */
+	return PICO_PMV_OK;
+}
+
+typedef struct aseVertex_s aseVertex_t;
+struct aseVertex_s
+{
+	picoVec3_t xyz;
+	picoVec3_t normal;
+	picoIndex_t id;
+};
+
+typedef struct aseTexCoord_s aseTexCoord_t;
+struct aseTexCoord_s
+{
+	picoVec2_t texcoord;
+};
+
+typedef struct aseColor_s aseColor_t;
+struct aseColor_s
+{
+	picoColor_t color;
+};
+
+typedef struct aseFace_s aseFace_t;
+struct aseFace_s
+{
+	picoIndex_t indices[9];
+	picoIndex_t smoothingGroup;
+	picoIndex_t materialId;
+	picoIndex_t subMaterialId;
+};
+typedef aseFace_t* aseFacesIter_t;
+
+picoSurface_t* PicoModelFindOrAddSurface( picoModel_t *model, picoShader_t* shader )
+{
+	/* see if a surface already has the shader */
+	int i = 0;
+	for ( ; i < model->numSurfaces ; i++ )
+	{
+		picoSurface_t* workSurface = model->surface[i];
+		if ( workSurface->shader == shader )
+		{			
+			return workSurface;
+		}
+	}
+
+	/* no surface uses this shader yet, so create a new surface */
+
+	{
+		/* create a new surface in the model for the unique shader */
+		picoSurface_t* workSurface = PicoNewSurface(model);
+		if ( !workSurface )
+		{
+			_pico_printf ( PICO_ERROR , "Could not allocate a new surface!\n" );
+			return 0;
+		}
+
+		/* do surface setup */
+		PicoSetSurfaceType( workSurface, PICO_TRIANGLES );
+		PicoSetSurfaceName( workSurface, shader->name );
+		PicoSetSurfaceShader( workSurface, shader );
+
+		return workSurface;
+	}
+}
+
+/* _ase_submit_triangles - jhefty
+ use the surface and the current face list to look up material/submaterial IDs
+ and submit them to the model for proper processing
+
+The following still holds from ydnar's _ase_make_surface:
+ indexes 0 1 2 = vert indexes
+ indexes 3 4 5 = st indexes
+ indexes 6 7 8 = color indexes (new)
+*/
+
+#if 0
+typedef picoIndex_t* picoIndexIter_t;
+
+typedef struct aseUniqueIndices_s aseUniqueIndices_t;
+struct aseUniqueIndices_s
+{
+	picoIndex_t* data;
+	picoIndex_t* last;
+
+	aseFace_t* faces;
+};
+
+size_t aseUniqueIndices_size(aseUniqueIndices_t* self)
+{
+	return self->last - self->data;
+}
+
+void aseUniqueIndices_reserve(aseUniqueIndices_t* self, picoIndex_t size)
+{
+	self->data = self->last = (picoIndex_t*)_pico_calloc(size, sizeof(picoIndex_t));
+}
+
+void aseUniqueIndices_clear(aseUniqueIndices_t* self)
+{
+	_pico_free(self->data);
+}
+
+void aseUniqueIndices_pushBack(aseUniqueIndices_t* self, picoIndex_t index)
+{
+	*self->last++ = index;
+}
+
+picoIndex_t aseFaces_getVertexIndex(aseFace_t* faces, picoIndex_t index)
+{
+	return faces[index / 3].indices[index % 3];
+}
+
+picoIndex_t aseFaces_getTexCoordIndex(aseFace_t* faces, picoIndex_t index)
+{
+	return faces[index / 3].indices[(index % 3) + 3];
+}
+
+picoIndex_t aseFaces_getColorIndex(aseFace_t* faces, picoIndex_t index)
+{
+	return faces[index / 3].indices[(index % 3) + 6];
+}
+
+int aseUniqueIndex_equal(aseFace_t* faces, picoIndex_t index, picoIndex_t other)
+{
+	return aseFaces_getVertexIndex(faces, index) == aseFaces_getVertexIndex(faces, other)
+		&& aseFaces_getTexCoordIndex(faces, index) == aseFaces_getTexCoordIndex(faces, other)
+		&& aseFaces_getColorIndex(faces, index) == aseFaces_getColorIndex(faces, other);
+}
+
+picoIndex_t aseUniqueIndices_insertUniqueVertex(aseUniqueIndices_t* self, picoIndex_t index)
+{
+	picoIndexIter_t i = self->data;
+	for(; i != self->last; ++i)
+	{
+		picoIndex_t other = (picoIndex_t)(i - self->data);
+		if(aseUniqueIndex_equal(self->faces, index, other))
+		{
+			return other;
+		}
+	}
+
+	aseUniqueIndices_pushBack(self, index);
+	return (picoIndex_t)(aseUniqueIndices_size(self) - 1);
+}
+
+static void _ase_submit_triangles_unshared ( picoModel_t* model , aseMaterial_t* materials , aseVertex_t* vertices, aseTexCoord_t* texcoords, aseColor_t* colors, aseFace_t* faces, int numFaces, int meshHasNormals )
+{
+	aseFacesIter_t i = faces, end = faces + numFaces;
+
+	aseUniqueIndices_t indices;
+	aseUniqueIndices_t remap;
+	aseUniqueIndices_reserve(&indices, numFaces * 3);
+	aseUniqueIndices_reserve(&remap, numFaces * 3);
+	indices.faces = faces;
+
+	for(; i != end; ++i)
+	{
+		/* look up the shader for the material/submaterial pair */
+		aseSubMaterial_t* subMtl = _ase_get_submaterial_or_default( materials, (*i).materialId, (*i).subMaterialId );
+		if( subMtl == NULL )
+		{
+			return;
+		}
+
+		{
+			picoSurface_t* surface = PicoModelFindOrAddSurface(model, subMtl->shader);
+			int j;
+			/* we pull the data from the vertex, color and texcoord arrays using the face index data */
+			for ( j = 0 ; j < 3 ; j ++ )
+			{
+				picoIndex_t index = (picoIndex_t)(((i - faces) * 3) + j);
+				picoIndex_t size = (picoIndex_t)aseUniqueIndices_size(&indices);
+				picoIndex_t unique = aseUniqueIndices_insertUniqueVertex(&indices, index);
+
+				picoIndex_t numVertexes = PicoGetSurfaceNumVertexes(surface);
+				picoIndex_t numIndexes = PicoGetSurfaceNumIndexes(surface);
+
+				aseUniqueIndices_pushBack(&remap, numIndexes);
+
+				PicoSetSurfaceIndex(surface, numIndexes, remap.data[unique]);
+
+				if(unique == size)
+				{
+					PicoSetSurfaceXYZ(surface, numVertexes, vertices[(*i).indices[j]].xyz);
+					PicoSetSurfaceNormal(surface, numVertexes, vertices[(*i).indices[j]].normal);
+					PicoSetSurfaceST(surface, 0, numVertexes, texcoords[(*i).indices[j + 3]].texcoord);
+
+					if ( (*i).indices[j + 6] >= 0 )
+					{
+						PicoSetSurfaceColor(surface, 0, numVertexes, colors[(*i).indices[j + 6]].color);
+					}
+					else
+					{
+						PicoSetSurfaceColor(surface, 0, numVertexes, white);
+					}
+
+					PicoSetSurfaceSmoothingGroup(surface, numVertexes, (vertices[(*i).indices[j]].id * (1 << 16)) + (*i).smoothingGroup);
+				}
+			}
+		}
+	}
+
+	aseUniqueIndices_clear(&indices);
+	aseUniqueIndices_clear(&remap);
+}
+
+#endif
+
+static void _ase_submit_triangles( picoModel_t* model , aseMaterial_t* materials , aseVertex_t* vertices, aseTexCoord_t* texcoords, aseColor_t* colors, aseFace_t* faces, int numFaces )
+{
+	aseFacesIter_t i = faces, end = faces + numFaces;
+	for(; i != end; ++i)
+	{
+		/* look up the shader for the material/submaterial pair */
+		aseSubMaterial_t* subMtl = _ase_get_submaterial_or_default( materials, (*i).materialId, (*i).subMaterialId );
+		if( subMtl == NULL )
+		{
+			return;
+		}
+
+		{
+			picoVec3_t* xyz[3];
+			picoVec3_t* normal[3];
+			picoVec2_t* st[3];
+			picoColor_t* color[3];
+			picoIndex_t smooth[3];
+			int j;
+			/* we pull the data from the vertex, color and texcoord arrays using the face index data */
+			for ( j = 0 ; j < 3 ; j ++ )
+			{
+				xyz[j]    = &vertices[(*i).indices[j]].xyz;
+				normal[j] = &vertices[(*i).indices[j]].normal;
+				st[j]     = &texcoords[(*i).indices[j + 3]].texcoord;
+	 	 	
+				if( colors != NULL && (*i).indices[j + 6] >= 0 )
+				{
+					color[j] = &colors[(*i).indices[j + 6]].color;
+				}
+				else
+				{
+					color[j] = &white;
+				}
+
+				smooth[j] = (vertices[(*i).indices[j]].id * (1 << 16)) + (*i).smoothingGroup; /* don't merge vertices */
+				
+			}
+
+			/* submit the triangle to the model */
+			PicoAddTriangleToModel ( model , xyz , normal , 1 , st , 1 , color , subMtl->shader, smooth );
+		}
+	}
+}
+
+static void shadername_convert(char* shaderName)
+{
+  /* unix-style path separators */
+  char* s = shaderName;
+  for(; *s != '\0'; ++s)
+  {
+    if(*s == '\\')
+    {
+      *s = '/';
+    }
+  }
+}
+
+
+/* _ase_load:
+ *  loads a 3dsmax ase model file.
+*/
+static picoModel_t *_ase_load( PM_PARAMS_LOAD )
+{
+	picoModel_t    *model;
+	picoParser_t   *p;
+	char			lastNodeName[ 1024 ];
+
+	aseVertex_t* vertices = NULL;
+	aseTexCoord_t* texcoords = NULL;
+	aseColor_t* colors = NULL;
+	aseFace_t* faces = NULL;
+	int numVertices = 0;
+	int numFaces = 0;
+	int numTextureVertices = 0;
+	int numTextureVertexFaces = 0;
+	int numColorVertices = 0;
+	int numColorVertexFaces = 0;
+	int vertexId = 0;
+
+	aseMaterial_t* materials = NULL;
+
+#ifdef DEBUG_PM_ASE
+	clock_t start, finish;
+	double elapsed;
+	start = clock();
+#endif
+
+	/* helper */
+	#define _ase_error_return(m) \
+	{ \
+		_pico_printf( PICO_ERROR,"%s in ASE, line %d.",m,p->curLine); \
+		_pico_free_parser( p ); \
+		PicoFreeModel( model ); \
+		return NULL; \
+	}
+	/* create a new pico parser */
+	p = _pico_new_parser( (picoByte_t *)buffer,bufSize );
+	if (p == NULL) return NULL;
+
+	/* create a new pico model */
+	model = PicoNewModel();
+	if (model == NULL)
+	{
+		_pico_free_parser( p );
+		return NULL;
+	}
+	/* do model setup */
+	PicoSetModelFrameNum( model, frameNum );
+	PicoSetModelName( model, fileName );
+	PicoSetModelFileName( model, fileName );
+
+	/* initialize some stuff */
+	memset( lastNodeName,0,sizeof(lastNodeName) );
+
+	/* parse ase model file */
+	while( 1 )
+	{
+		/* get first token on line */
+		if (_pico_parse_first( p ) == NULL)
+			break;
+
+		/* we just skip empty lines */
+		if (p->token == NULL || !strlen( p->token ))
+			continue;
+
+		/* we skip invalid ase statements */
+		if (p->token[0] != '*' && p->token[0] != '{' && p->token[0] != '}')
+		{
+			_pico_parse_skip_rest( p );
+			continue;
+		}
+		/* remember node name */
+		if (!_pico_stricmp(p->token,"*node_name"))
+		{
+			/* read node name */
+			char *ptr = _pico_parse( p,0 );
+			if (ptr == NULL)
+				_ase_error_return("Node name parse error");
+
+			/* remember node name */
+			strncpy( lastNodeName,ptr,sizeof(lastNodeName) );
+		}
+		/* model mesh (originally contained within geomobject) */
+		else if (!_pico_stricmp(p->token,"*mesh"))
+		{
+			/* finish existing surface */
+			_ase_submit_triangles(model, materials, vertices, texcoords, colors, faces, numFaces);
+			_pico_free(faces);
+			_pico_free(vertices);
+			_pico_free(texcoords);
+			_pico_free(colors);
+			colors = faces = vertices = texcoords = NULL; /* OrbWeaver: reset all pointers to avoid double-free */
+		}
+		else if (!_pico_stricmp(p->token,"*mesh_numvertex"))
+		{
+			if (!_pico_parse_int( p, &numVertices) )
+				_ase_error_return("Missing MESH_NUMVERTEX value");
+
+			vertices = _pico_calloc(numVertices, sizeof(aseVertex_t));
+		}
+		else if (!_pico_stricmp(p->token,"*mesh_numfaces"))
+		{
+			if (!_pico_parse_int( p, &numFaces) )
+				_ase_error_return("Missing MESH_NUMFACES value");
+
+			faces = _pico_calloc(numFaces, sizeof(aseFace_t));
+		}
+		else if (!_pico_stricmp(p->token,"*mesh_numtvertex"))
+		{
+			if (!_pico_parse_int( p, &numTextureVertices) )
+				_ase_error_return("Missing MESH_NUMTVERTEX value");
+
+			texcoords = _pico_calloc(numTextureVertices, sizeof(aseTexCoord_t));
+		}
+		else if (!_pico_stricmp(p->token,"*mesh_numtvfaces"))
+		{
+			if (!_pico_parse_int( p, &numTextureVertexFaces) )
+				_ase_error_return("Missing MESH_NUMTVFACES value");
+		}
+		else if (!_pico_stricmp(p->token,"*mesh_numcvertex"))
+		{
+			if (!_pico_parse_int( p, &numColorVertices) )
+				_ase_error_return("Missing MESH_NUMCVERTEX value");
+
+			colors = _pico_calloc(numColorVertices, sizeof(aseColor_t));
+			memset( colors, 255, numColorVertices * sizeof( aseColor_t ) );	/* ydnar: force colors to white initially */
+		}
+		else if (!_pico_stricmp(p->token,"*mesh_numcvfaces"))
+		{
+			if (!_pico_parse_int( p, &numColorVertexFaces) )
+				_ase_error_return("Missing MESH_NUMCVFACES value");
+		}
+		/* mesh material reference. this usually comes at the end of */
+		/* geomobjects after the mesh blocks. we must assume that the */
+		/* new mesh was already created so all we can do here is assign */
+		/* the material reference id (shader index) now. */
+		else if (!_pico_stricmp(p->token,"*material_ref"))
+		{
+			int mtlId;
+
+			/* get the material ref (0..n) */
+			if (!_pico_parse_int( p,&mtlId) )
+				_ase_error_return("Missing material reference ID");
+
+			{
+				int i = 0;
+				/* fix up all of the aseFaceList in the surface to point to the parent material */
+				/* we've already saved off their subMtl */
+				for(; i < numFaces; ++i)
+				{
+					faces[i].materialId = mtlId;
+				}
+			}
+		}
+		/* model mesh vertex */
+		else if (!_pico_stricmp(p->token,"*mesh_vertex"))
+		{
+			int			index;
+
+			if( numVertices == 0 )
+				_ase_error_return("Vertex parse error");
+
+			/* get vertex data (orig: index +y -x +z) */
+			if (!_pico_parse_int( p,&index ))
+				_ase_error_return("Vertex parse error");
+			if (!_pico_parse_vec( p,vertices[index].xyz ))
+				_ase_error_return("Vertex parse error");
+
+			vertices[index].id = vertexId++;
+		}
+		/* model mesh vertex normal */
+		else if (!_pico_stricmp(p->token,"*mesh_vertexnormal"))
+		{
+			int			index;
+
+			if( numVertices == 0 )
+				_ase_error_return("Vertex parse error");
+
+			/* get vertex data (orig: index +y -x +z) */
+			if (!_pico_parse_int( p,&index ))
+				_ase_error_return("Vertex parse error");
+			if (!_pico_parse_vec( p,vertices[index].normal ))
+				_ase_error_return("Vertex parse error");
+		}
+		/* model mesh face */
+		else if (!_pico_stricmp(p->token,"*mesh_face"))
+		{
+			picoIndex_t indexes[3];
+			int index;
+			
+			if( numFaces == 0 )
+				_ase_error_return("Face parse error");
+
+			/* get face index */
+			if (!_pico_parse_int( p,&index ))
+				_ase_error_return("Face parse error");
+
+			/* get 1st vertex index */
+			_pico_parse( p,0 );
+			if (!_pico_parse_int( p,&indexes[0] ))
+				_ase_error_return("Face parse error");
+
+			/* get 2nd vertex index */
+			_pico_parse( p,0 );
+			if (!_pico_parse_int( p,&indexes[1] ))
+				_ase_error_return("Face parse error");
+
+			/* get 3rd vertex index */
+			_pico_parse( p,0 );
+			if (!_pico_parse_int( p,&indexes[2] ))
+				_ase_error_return("Face parse error");
+			
+			/* parse to the subMaterial ID */
+			while ( 1 )
+			{
+				if (!_pico_parse (p,0)) /* EOL */
+				{
+					break;
+				}
+				if (!_pico_stricmp (p->token,"*MESH_SMOOTHING" ))
+				{
+					_pico_parse_int ( p , &faces[index].smoothingGroup );
+				}
+				if (!_pico_stricmp (p->token,"*MESH_MTLID" ))
+				{
+					_pico_parse_int ( p , &faces[index].subMaterialId );
+				}
+			}
+			
+			faces[index].materialId = 0;
+			faces[index].indices[0] = indexes[2];
+			faces[index].indices[1] = indexes[1];
+			faces[index].indices[2] = indexes[0];
+		}
+		/* model texture vertex */
+		else if (!_pico_stricmp(p->token,"*mesh_tvert"))
+		{
+			int			index;
+
+			if( numVertices == 0 )
+				_ase_error_return("Texture Vertex parse error");
+
+			/* get uv vertex index */
+			if (!_pico_parse_int( p,&index ) || index >= numTextureVertices)
+				_ase_error_return("Texture vertex parse error");
+
+			/* get uv vertex s */
+			if (!_pico_parse_double( p,&texcoords[index].texcoord[0] ))
+				_ase_error_return("Texture vertex parse error");
+
+			/* get uv vertex t */
+			if (!_pico_parse_double( p,&texcoords[index].texcoord[1] ))
+				_ase_error_return("Texture vertex parse error");
+			
+			/* ydnar: invert t */
+			texcoords[index].texcoord[ 1 ] = 1.0f - texcoords[index].texcoord[ 1 ];
+		}
+		/* ydnar: model mesh texture face */
+		else if( !_pico_stricmp( p->token, "*mesh_tface" ) )
+		{
+			picoIndex_t indexes[3];
+			int			index;
+			
+			if( numFaces == 0 )
+				_ase_error_return("Texture face parse error");
+			
+			/* get face index */
+			if (!_pico_parse_int( p,&index ))
+				_ase_error_return("Texture face parse error");
+			
+			/* get 1st vertex index */
+			if (!_pico_parse_int( p,&indexes[0] ))
+				_ase_error_return("Texture face parse error");
+			
+			/* get 2nd vertex index */
+			if (!_pico_parse_int( p,&indexes[1] ))
+				_ase_error_return("Texture face parse error");
+			
+			/* get 3rd vertex index */
+			if (!_pico_parse_int( p,&indexes[2] ))
+				_ase_error_return("Texture face parse error");
+
+			faces[index].indices[3] = indexes[2];
+			faces[index].indices[4] = indexes[1];
+			faces[index].indices[5] = indexes[0];
+		}
+		/* model color vertex */
+		else if (!_pico_stricmp(p->token,"*mesh_vertcol"))
+		{
+			int			index;
+			float		colorInput;
+
+			if( numVertices == 0 )
+				_ase_error_return("Color Vertex parse error");
+
+			/* get color vertex index */
+			if (!_pico_parse_int( p,&index ))
+				_ase_error_return("Color vertex parse error");
+
+			/* get R component */
+			if (!_pico_parse_float( p,&colorInput ))
+				_ase_error_return("Color vertex parse error");
+			colors[index].color[0] = (picoByte_t)(colorInput * 255);
+
+			/* get G component */
+			if (!_pico_parse_float( p,&colorInput ))
+				_ase_error_return("Color vertex parse error");
+			colors[index].color[1] = (picoByte_t)(colorInput * 255);
+
+			/* get B component */
+			if (!_pico_parse_float( p,&colorInput ))
+				_ase_error_return("Color vertex parse error");
+			colors[index].color[2] = (picoByte_t)(colorInput * 255);
+			
+			/* leave alpha alone since we don't get any data from the ASE format */
+			colors[index].color[3] = 255;
+		}
+		/* model color face */
+		else if (!_pico_stricmp(p->token,"*mesh_cface"))
+		{
+			picoIndex_t indexes[3];
+			int			index;
+
+			if( numFaces == 0 )
+				_ase_error_return("Face parse error");
+
+			/* get face index */
+			if (!_pico_parse_int( p,&index ))
+				_ase_error_return("Face parse error");
+
+			/* get 1st cvertex index */
+			//			_pico_parse( p,0 );
+			if (!_pico_parse_int( p,&indexes[0] ))
+				_ase_error_return("Face parse error");
+
+			/* get 2nd cvertex index */
+			//			_pico_parse( p,0 );
+			if (!_pico_parse_int( p,&indexes[1] ))
+				_ase_error_return("Face parse error");
+
+			/* get 3rd cvertex index */
+			//			_pico_parse( p,0 );
+			if (!_pico_parse_int( p,&indexes[2] ))
+				_ase_error_return("Face parse error");
+
+			faces[index].indices[6] = indexes[2];
+			faces[index].indices[7] = indexes[1];
+			faces[index].indices[8] = indexes[0];
+		}
+		/* model material */
+		else if( !_pico_stricmp( p->token, "*material" ) )
+		{
+			aseSubMaterial_t*	subMaterial = NULL;
+			picoShader_t		*shader;
+			int					level = 1, index;
+			char				materialName[ 1024 ];
+			float				transValue = 0.0f, shineValue = 1.0f;
+			picoColor_t			ambientColor, diffuseColor, specularColor;
+			char				*mapname = NULL;
+			int					subMtlId, subMaterialLevel = -1;
+			
+			
+			/* get material index */
+			_pico_parse_int( p,&index );
+			
+			/* check brace */
+			if (!_pico_parse_check(p,1,"{"))
+				_ase_error_return("Material missing opening brace");
+			
+			/* parse material block */
+			while( 1 )
+			{
+				/* get next token */
+				if (_pico_parse(p,1) == NULL) break;
+				if (!strlen(p->token)) continue;
+
+				/* handle levels */
+				if (p->token[0] == '{') level++;
+				if (p->token[0] == '}') level--;
+				if (!level) break;
+
+				if( level == subMaterialLevel )
+				{
+					/* set material name */
+					_pico_first_token( materialName );
+          shadername_convert(materialName);
+					PicoSetShaderName( shader, materialName);
+
+					/* set shader's transparency */
+					PicoSetShaderTransparency( shader,transValue );
+
+					/* set shader's ambient color */
+					PicoSetShaderAmbientColor( shader,ambientColor );
+
+					/* set diffuse alpha to transparency */
+					diffuseColor[3] = (picoByte_t)( transValue * 255.0 );
+
+					/* set shader's diffuse color */
+					PicoSetShaderDiffuseColor( shader,diffuseColor );
+
+					/* set shader's specular color */
+					PicoSetShaderSpecularColor( shader,specularColor );
+
+					/* set shader's shininess */
+					PicoSetShaderShininess( shader,shineValue );
+
+					/* set material map name */
+					PicoSetShaderMapName( shader, mapname );
+
+					subMaterial = _ase_add_submaterial( &materials, index, subMtlId, shader );
+					subMaterialLevel = -1;
+				}
+
+				/* parse submaterial index */
+				if (!_pico_stricmp(p->token,"*submaterial"))
+				{											
+					/* allocate new pico shader */
+					_pico_parse_int( p , &subMtlId );
+
+					shader = PicoNewShader( model );
+					if (shader == NULL)
+					{
+						PicoFreeModel( model );
+						return NULL;
+					}			
+					subMaterialLevel = level;
+				}
+				/* parse material name */
+				else if (!_pico_stricmp(p->token,"*material_name"))
+				{
+					char* name = _pico_parse(p,0);
+					if ( name == NULL)
+						_ase_error_return("Missing material name");
+					
+					strcpy ( materialName , name );
+					/* skip rest and continue with next token */
+					_pico_parse_skip_rest( p );
+					continue;
+				}
+				/* parse material transparency */
+				else if (!_pico_stricmp(p->token,"*material_transparency"))
+				{
+					/* get transparency value from ase */
+					if (!_pico_parse_float( p,&transValue ))
+						_ase_error_return("Material transparency parse error");
+
+					/* skip rest and continue with next token */
+					_pico_parse_skip_rest( p );
+					continue;
+				}
+				/* parse material shininess */
+				else if (!_pico_stricmp(p->token,"*material_shine"))
+				{
+					/* remark:
+					 * - not sure but instead of '*material_shine' i might
+					 *   need to use '*material_shinestrength' */
+
+					/* get shine value from ase */
+					if (!_pico_parse_float( p,&shineValue ))
+						_ase_error_return("Material shine parse error");
+
+					/* scale ase shine range 0..1 to pico range 0..127 */
+					shineValue *= 128.0;
+
+					/* skip rest and continue with next token */
+					_pico_parse_skip_rest( p );
+					continue;
+				}
+				/* parse ambient material color */
+				else if (!_pico_stricmp(p->token,"*material_ambient"))
+				{
+					picoVec3_t  vec;
+					/* get r,g,b float values from ase */
+					if (!_pico_parse_vec( p,vec ))
+						_ase_error_return("Material color parse error");
+
+					/* setup 0..255 range color values */
+					ambientColor[ 0 ] = (int)( vec[ 0 ] * 255.0 );
+					ambientColor[ 1 ] = (int)( vec[ 1 ] * 255.0 );
+					ambientColor[ 2 ] = (int)( vec[ 2 ] * 255.0 );
+					ambientColor[ 3 ] = (int)( 255 );
+
+					/* skip rest and continue with next token */
+					_pico_parse_skip_rest( p );
+					continue;
+				}
+				/* parse diffuse material color */
+				else if (!_pico_stricmp(p->token,"*material_diffuse"))
+				{
+					picoVec3_t  vec;
+
+					/* get r,g,b float values from ase */
+					if (!_pico_parse_vec( p,vec ))
+						_ase_error_return("Material color parse error");
+
+					/* setup 0..255 range color */
+					diffuseColor[ 0 ] = (int)( vec[ 0 ] * 255.0 );
+					diffuseColor[ 1 ] = (int)( vec[ 1 ] * 255.0 );
+					diffuseColor[ 2 ] = (int)( vec[ 2 ] * 255.0 );
+					diffuseColor[ 3 ] = (int)( 255 );
+
+					/* skip rest and continue with next token */
+					_pico_parse_skip_rest( p );
+					continue;
+				}
+				/* parse specular material color */
+				else if (!_pico_stricmp(p->token,"*material_specular"))
+				{
+					picoVec3_t  vec;
+
+					/* get r,g,b float values from ase */
+					if (!_pico_parse_vec( p,vec ))
+						_ase_error_return("Material color parse error");
+
+					/* setup 0..255 range color */
+					specularColor[ 0 ] = (int)( vec[ 0 ] * 255 );
+					specularColor[ 1 ] = (int)( vec[ 1 ] * 255 );
+					specularColor[ 2 ] = (int)( vec[ 2 ] * 255 );
+					specularColor[ 3 ] = (int)( 255 );
+
+					/* skip rest and continue with next token */
+					_pico_parse_skip_rest( p );
+					continue;
+				}
+				/* material diffuse map */
+				else if (!_pico_stricmp(p->token,"*map_diffuse") )
+				{
+					int sublevel = 0;
+
+					/* parse material block */
+					while( 1 )
+					{
+						/* get next token */
+						if (_pico_parse(p,1) == NULL) break;
+						if (!strlen(p->token)) continue;
+						
+						/* handle levels */
+						if (p->token[0] == '{') sublevel++;
+						if (p->token[0] == '}') sublevel--;
+						if (!sublevel) break;
+						
+						/* parse diffuse map bitmap */
+						if (!_pico_stricmp(p->token,"*bitmap"))
+						{
+							char* name = _pico_parse(p,0);
+							if (name == NULL)
+								_ase_error_return("Missing material map bitmap name");
+							mapname = _pico_alloc ( strlen ( name ) + 1 );
+							strcpy ( mapname, name );
+							/* skip rest and continue with next token */
+							_pico_parse_skip_rest( p );
+							continue;
+						}
+					}
+				}
+				/* end map_diffuse block */
+			}
+			/* end material block */
+
+			if( subMaterial == NULL )
+			{
+				/* allocate new pico shader */
+				shader = PicoNewShader( model );
+				if (shader == NULL)
+				{
+					PicoFreeModel( model );
+					return NULL;
+				}
+
+				/* set material name */
+        shadername_convert(materialName);
+				PicoSetShaderName( shader,materialName );
+
+				/* set shader's transparency */
+				PicoSetShaderTransparency( shader,transValue );
+
+				/* set shader's ambient color */
+				PicoSetShaderAmbientColor( shader,ambientColor );
+
+				/* set diffuse alpha to transparency */
+				diffuseColor[3] = (picoByte_t)( transValue * 255.0 );
+
+				/* set shader's diffuse color */
+				PicoSetShaderDiffuseColor( shader,diffuseColor );
+
+				/* set shader's specular color */
+				PicoSetShaderSpecularColor( shader,specularColor );
+
+				/* set shader's shininess */
+				PicoSetShaderShininess( shader,shineValue );
+
+				/* set material map name */
+				PicoSetShaderMapName( shader, mapname );
+
+        /* extract shadername from bitmap path */
+        if(mapname != NULL)
+        {
+          char* p = mapname;
+
+          /* convert to shader-name format */
+          shadername_convert(mapname);
+          {
+            /* remove extension */
+            char* last_period = strrchr(p, '.');
+            if(last_period != NULL)
+            {
+              *last_period = '\0';
+            }
+          }
+
+          /* find game root */
+          for(; *p != '\0'; ++p)
+          {
+            if(_pico_strnicmp(p, "quake", 5) == 0 || _pico_strnicmp(p, "doom", 4) == 0)
+            {
+              /* root-relative */
+              for(; *p != '\0'; ++p)
+              {
+                if(*p == '/')
+                {
+                  ++p;
+                  /* game-relative */
+                  for(; *p != '\0'; ++p)
+                  {
+                    if(*p == '/')
+                    {
+                      ++p;
+                      break;
+                    }
+                  }
+                }
+              }
+            }
+            /* DoomEdit's ASE loader searches for /base/ */
+            else if(_pico_strnicmp(p, "base/", 5) == 0)
+            {
+              p += 5;
+              break;
+            }
+          }
+
+          if(*p != '\0')
+          {
+				    /* set material name */
+				    PicoSetShaderName( shader,p );
+          }
+        }
+
+        /* this is just a material with 1 submaterial */
+				subMaterial = _ase_add_submaterial( &materials, index, 0, shader );
+			}
+			
+			/* ydnar: free mapname */
+			if( mapname != NULL )
+				_pico_free( mapname );
+		}	// !_pico_stricmp ( "*material" )
+
+		/* skip unparsed rest of line and continue */
+		_pico_parse_skip_rest( p );
+	}
+	
+	/* ydnar: finish existing surface */
+	_ase_submit_triangles(model, materials, vertices, texcoords, colors, faces, numFaces);
+	_pico_free(faces);
+	_pico_free(vertices);
+	_pico_free(texcoords);
+	_pico_free(colors);
+
+#ifdef DEBUG_PM_ASE
+	_ase_print_materials(materials);
+	finish = clock();
+	elapsed = (double)(finish - start) / CLOCKS_PER_SEC;
+	_pico_printf( PICO_NORMAL, "Loaded model in in %-.2f second(s)\n", elapsed );
+#endif //DEBUG_PM_ASE
+
+	_ase_free_materials(&materials);
+
+  _pico_free_parser( p );
+
+	/* return allocated pico model */
+	return model;
+}
+
+/* pico file format module definition */
+const picoModule_t picoModuleASE =
+{
+	"1.0",					/* module version string */
+	"Autodesk 3DSMAX ASCII",	/* module display name */
+	"Jared Hefty, seaw0lf",					/* author's name */
+	"2003 Jared Hefty, 2002 seaw0lf",				/* module copyright */
+	{
+		"ase",NULL,NULL,NULL	/* default extensions to use */
+	},
+	_ase_canload,				/* validation routine */
+	_ase_load,					/* load routine */
+	 NULL,						/* save validation routine */
+	 NULL						/* save routine */
+};
Index: libs/picomodel/pm_lwo.c
===================================================================
--- libs/picomodel/pm_lwo.c	(revision 3603)
+++ libs/picomodel/pm_lwo.c	(working copy)
@@ -1,454 +1,454 @@
-/* -----------------------------------------------------------------------------
-
-PicoModel Library 
-
-Copyright (c) 2002, Randy Reddig & seaw0lf
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-Redistributions of source code must retain the above copyright notice, this list
-of conditions and the following disclaimer.
-
-Redistributions in binary form must reproduce the above copyright notice, this
-list of conditions and the following disclaimer in the documentation and/or
-other materials provided with the distribution.
-
-Neither the names of the copyright holders nor the names of its contributors may
-be used to endorse or promote products derived from this software without
-specific prior written permission. 
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
------------------------------------------------------------------------------ */
-
-/* marker */
-#define PM_LWO_C
-
-/* dependencies */
-#include "picointernal.h"
-#include "lwo/lwo2.h"
-
-/* uncomment when debugging this module */
-/*#define DEBUG_PM_LWO*/
-
-#ifdef DEBUG_PM_LWO
-#include "time.h"
-#endif
-
-/* helper functions */
-static const char *lwo_lwIDToStr( unsigned int lwID )
-{
-	static char lwIDStr[5];
-
-	if (!lwID)
-	{
-		return "n/a";
-	}
-
-	lwIDStr[ 0 ] = (char)((lwID) >> 24);
-	lwIDStr[ 1 ] = (char)((lwID) >> 16);
-	lwIDStr[ 2 ] = (char)((lwID) >> 8);
-	lwIDStr[ 3 ] = (char)((lwID));
-	lwIDStr[ 4 ] = '\0';
-
-	return lwIDStr;
-}
-
-/*
-_lwo_canload()
-validates a LightWave Object model file. btw, i use the
-preceding underscore cause it's a static func referenced
-by one structure only.
-*/
-static int _lwo_canload( PM_PARAMS_CANLOAD )
-{
-	picoMemStream_t *s;
-	unsigned int failID = 0;
-	int failpos = -1;
-	int ret;
-
-	/* create a new pico memorystream */
-	s = _pico_new_memstream( (picoByte_t *)buffer, bufSize );
-	if (s == NULL)
-	{
-		return PICO_PMV_ERROR_MEMORY;
-	}
-
-	ret = lwValidateObject( fileName, s, &failID, &failpos );
-
-	_pico_free_memstream( s );
-
-	return ret;
-}
-
-/*
-_lwo_load()
-loads a LightWave Object model file.
-*/
-static picoModel_t *_lwo_load( PM_PARAMS_LOAD )
-{
-	picoMemStream_t	*s;
-	unsigned int	failID = 0;
-	int				failpos = -1;
-	lwObject		*obj;
-	lwSurface		*surface;
-	lwLayer			*layer;
-	lwPoint			*pt;
-	lwPolygon		*pol;
-	lwPolVert		*v;
-	lwVMapPt		*vm;
-	char			name[ 256 ];
-	int				i, j, k, numverts;
-
-	picoModel_t		*picoModel;
-	picoSurface_t	*picoSurface;
-	picoShader_t	*picoShader;
-	picoVec3_t		xyz, normal;
-	picoVec2_t		st;
-	picoColor_t		color;
-
-	int				defaultSTAxis[ 2 ];
-	picoVec2_t		defaultXYZtoSTScale;
-
-	picoVertexCombinationHash_t **hashTable;
-	picoVertexCombinationHash_t	*vertexCombinationHash;
-
-	int surfacePolyCount;
-
-#ifdef DEBUG_PM_LWO
-	clock_t load_start, load_finish, convert_start, convert_finish;
-	double load_elapsed, convert_elapsed;
-
-	load_start = clock();
-#endif
-
-	/* do frame check */
-	if( frameNum < 0 || frameNum >= 1 )
-	{
-		_pico_printf( PICO_ERROR, "Invalid or out-of-range LWO frame specified" );
-		return NULL;
-	}
-
-	/* create a new pico memorystream */
-	s = _pico_new_memstream( (picoByte_t *)buffer, bufSize );
-	if (s == NULL)
-	{
-		return NULL;
-	}
-
-	obj = lwGetObject( fileName, s, &failID, &failpos );
-
-	_pico_free_memstream( s );
-
-	if( !obj ) {
-		_pico_printf( PICO_ERROR, "Couldn't load LWO file, failed on ID '%s', position %d", lwo_lwIDToStr( failID ), failpos );
-		return NULL;
-	}
-
-#ifdef DEBUG_PM_LWO
-	convert_start = load_finish = clock();
-	load_elapsed = (double)(load_finish - load_start) / CLOCKS_PER_SEC;
-#endif
-
-	/* -------------------------------------------------
-	pico model creation
-	------------------------------------------------- */
-	
-	/* create a new pico model */
-	picoModel = PicoNewModel();
-	if (picoModel == NULL)
-	{
-		_pico_printf( PICO_ERROR, "Unable to allocate a new model" );
-		return NULL;
-	}
-
-	/* do model setup */
-	PicoSetModelFrameNum( picoModel, frameNum );
-	PicoSetModelNumFrames( picoModel, 1 );
-	PicoSetModelName( picoModel, fileName );
-	PicoSetModelFileName( picoModel, fileName );
-
-	/* create all polygons from layer[ 0 ] that belong to this surface */
-	layer = &obj->layer[0];
-
-	/* warn the user that other layers are discarded */
-	if (obj->nlayers > 1)
-	{
-		_pico_printf( PICO_WARNING, "LWO loader discards any geometry data not in Layer 1 (%d layers found)", obj->nlayers );
-	}
-
-	/* initialize dummy normal */
-	normal[ 0 ] = normal[ 1 ] = normal[ 2 ] = 0.f;
-
-	/* setup default st map */
-	st[ 0 ] = st[ 1 ] = 0.f;	/* st[0] holds max, st[1] holds max par one */
-	defaultSTAxis[ 0 ] = 0;
-	defaultSTAxis[ 1 ] = 1;
-	for( i = 0; i < 3; i++ )
-	{
-		float min = layer->bbox[ i ];
-		float max = layer->bbox[ i + 3 ];
-		float size = max - min;
-		
-		if (size > st[ 0 ])
-		{
-			defaultSTAxis[ 1 ] = defaultSTAxis[ 0 ];
-			defaultSTAxis[ 0 ] = i;
-
-			st[ 1 ] = st[ 0 ];
-			st[ 0 ] = size;
-		}
-		else if (size > st[ 1 ])
-		{
-			defaultSTAxis[ 1 ] = i;
-			st[ 1 ] = size;
-		}
-	}
-	defaultXYZtoSTScale[ 0 ] = 4.f / st[ 0 ];
-	defaultXYZtoSTScale[ 1 ] = 4.f / st[ 1 ];
-
-	/* LWO surfaces become pico surfaces */
-	surface = obj->surf;
-	while (surface)
-	{
-		/* allocate new pico surface */
-		picoSurface = PicoNewSurface( picoModel );
-		if (picoSurface == NULL)
-		{
-			_pico_printf( PICO_ERROR, "Unable to allocate a new model surface" );
-			PicoFreeModel( picoModel );
-			lwFreeObject( obj );
-			return NULL;
-		}
-
-		/* LWO model surfaces are all triangle meshes */
-		PicoSetSurfaceType( picoSurface, PICO_TRIANGLES );
-
-		/* set surface name */
-		PicoSetSurfaceName( picoSurface, surface->name );
-
-		/* create new pico shader */
-		picoShader = PicoNewShader( picoModel );
-		if (picoShader == NULL)
-		{
-			_pico_printf( PICO_ERROR, "Unable to allocate a new model shader" );
-			PicoFreeModel( picoModel );
-			lwFreeObject( obj );
-			return NULL;
-		}
-
-		/* detox and set shader name */
-		strncpy( name, surface->name, sizeof(name) );
-		_pico_first_token( name );
-		_pico_setfext( name, "" );
-		_pico_unixify( name );
-		PicoSetShaderName( picoShader, name );
-
-		/* associate current surface with newly created shader */
-		PicoSetSurfaceShader( picoSurface, picoShader );
-
-		/* copy indices and vertex data */
-		numverts = 0;
-
-		hashTable = PicoNewVertexCombinationHashTable();
-
-		if (hashTable == NULL)
-		{
-			_pico_printf( PICO_ERROR, "Unable to allocate hash table" );
-			PicoFreeModel( picoModel );
-			lwFreeObject( obj );
-			return NULL;
-		}
-
-		/* Local polygon index for this surface. We don't want to use i in the loop
-		 * since that is the global poly index for the entire layer */
-		surfacePolyCount = 0;
-
-		for( i = 0, pol = layer->polygon.pol; i < layer->polygon.count; i++, pol++ )
-		{
-			/* does this polygon belong to this surface? */
-			if (pol->surf != surface)
-				continue;
-
-			/* we only support polygons of the FACE type */
-			if (pol->type != ID_FACE)
-			{
-				_pico_printf( PICO_WARNING, "LWO loader discarded a polygon because it's type != FACE (%s)", lwo_lwIDToStr( pol->type ) );
-				continue;
-			}
-
-			/* NOTE: LWO has support for non-convex polygons, do we want to store them as well? */
-			if (pol->nverts != 3)
-			{
-				_pico_printf( PICO_WARNING, "LWO loader discarded a polygon because it has != 3 verts (%d)", pol->nverts );
-				continue;
-			}
-
-			/* We haven't discarded this polygon, so bump the surface polycount */
-			surfacePolyCount++;
-
-			for( j = 0, v = pol->v; j < 3; j++, v++ )
-			{
-				pt = &layer->point.pt[ v->index ];
-
-				/* setup data */
-				xyz[ 0 ] = pt->pos[ 0 ];
-				xyz[ 1 ] = pt->pos[ 2 ];
-				xyz[ 2 ] = pt->pos[ 1 ];
-
-/* doom3 lwo data doesn't seem to have smoothing-angle information */
-#if 0
-        if(surface->smooth <= 0)
-        {
-          /* use face normals */
-				  normal[ 0 ] = v->norm[ 0 ];
-				  normal[ 1 ] = v->norm[ 2 ];
-				  normal[ 2 ] = v->norm[ 1 ];
-        }
-        else
-#endif
-        {
-          /* smooth normals later */
-				  normal[ 0 ] = 0;
-				  normal[ 1 ] = 0;
-				  normal[ 2 ] = 0;
-        }
-
-				st[ 0 ] = xyz[ defaultSTAxis[ 0 ] ] * defaultXYZtoSTScale[ 0 ];
-				st[ 1 ] = xyz[ defaultSTAxis[ 1 ] ] * defaultXYZtoSTScale[ 1 ];
-
-				color[ 0 ] = (picoByte_t)(surface->color.rgb[ 0 ] * surface->diffuse.val * 0xFF);
-				color[ 1 ] = (picoByte_t)(surface->color.rgb[ 1 ] * surface->diffuse.val * 0xFF);
-				color[ 2 ] = (picoByte_t)(surface->color.rgb[ 2 ] * surface->diffuse.val * 0xFF);
-				color[ 3 ] = 0xFF;
-
-				/* set from points */
-				for( k = 0, vm = pt->vm; k < pt->nvmaps; k++, vm++ )
-				{
-					if (vm->vmap->type == LWID_('T','X','U','V'))
-					{
-						/* set st coords */
-						st[ 0 ] = vm->vmap->val[ vm->index ][ 0 ];
-						st[ 1 ] = 1.f - vm->vmap->val[ vm->index ][ 1 ];
-					}
-					else if (vm->vmap->type == LWID_('R','G','B','A'))
-					{
-						/* set rgba */
-						color[ 0 ] = (picoByte_t)(vm->vmap->val[ vm->index ][ 0 ] * surface->color.rgb[ 0 ] * surface->diffuse.val * 0xFF);
-						color[ 1 ] = (picoByte_t)(vm->vmap->val[ vm->index ][ 1 ] * surface->color.rgb[ 1 ] * surface->diffuse.val * 0xFF);
-						color[ 2 ] = (picoByte_t)(vm->vmap->val[ vm->index ][ 2 ] * surface->color.rgb[ 2 ] * surface->diffuse.val * 0xFF);
-						color[ 3 ] = (picoByte_t)(vm->vmap->val[ vm->index ][ 3 ] * 0xFF);
-					}
-				}
-
-				/* override with polygon data */
-				for( k = 0, vm = v->vm; k < v->nvmaps; k++, vm++ )
-				{
-					if (vm->vmap->type == LWID_('T','X','U','V'))
-					{
-						/* set st coords */
-						st[ 0 ] = vm->vmap->val[ vm->index ][ 0 ];
-						st[ 1 ] = 1.f - vm->vmap->val[ vm->index ][ 1 ];
-					}
-					else if (vm->vmap->type == LWID_('R','G','B','A'))
-					{
-						/* set rgba */
-						color[ 0 ] = (picoByte_t)(vm->vmap->val[ vm->index ][ 0 ] * surface->color.rgb[ 0 ] * surface->diffuse.val * 0xFF);
-						color[ 1 ] = (picoByte_t)(vm->vmap->val[ vm->index ][ 1 ] * surface->color.rgb[ 1 ] * surface->diffuse.val * 0xFF);
-						color[ 2 ] = (picoByte_t)(vm->vmap->val[ vm->index ][ 2 ] * surface->color.rgb[ 2 ] * surface->diffuse.val * 0xFF);
-						color[ 3 ] = (picoByte_t)(vm->vmap->val[ vm->index ][ 3 ] * 0xFF);
-					}
-				}
-
-				/* find vertex in this surface and if we can't find it there create it */
-				vertexCombinationHash = PicoFindVertexCombinationInHashTable( hashTable, xyz, normal, st, color );
-
-				if (vertexCombinationHash)
-				{
-					/* found an existing one */
-					PicoSetSurfaceIndex( picoSurface, (surfacePolyCount * 3 + j ), vertexCombinationHash->index );
-				}
-				else
-				{
-					/* it is a new one */
-					vertexCombinationHash = PicoAddVertexCombinationToHashTable( hashTable, xyz, normal, st, color, (picoIndex_t) numverts );
-
-					if (vertexCombinationHash == NULL)
-					{
-						_pico_printf( PICO_ERROR, "Unable to allocate hash bucket entry table" );
-						PicoFreeVertexCombinationHashTable( hashTable );
-						PicoFreeModel( picoModel );
-						lwFreeObject( obj );
-						return NULL;
-					}
-
-					/* add the vertex to this surface */
-					PicoSetSurfaceXYZ( picoSurface, numverts, xyz );
-
-					/* set dummy normal */
-					PicoSetSurfaceNormal( picoSurface, numverts, normal );
-
-					/* set color */
-					PicoSetSurfaceColor( picoSurface, 0, numverts, color );
-
-					/* set st coords */
-					PicoSetSurfaceST( picoSurface, 0, numverts, st );
-
-					/* set index */
-					PicoSetSurfaceIndex( picoSurface, (surfacePolyCount * 3 + j ), (picoIndex_t) numverts );
-
-					numverts++;
-				}
-			}
-		}
-
-		/* free the hashtable */
-		PicoFreeVertexCombinationHashTable( hashTable );
-
-		/* get next surface */		
-		surface = surface->next;
-	}
-
-#ifdef DEBUG_PM_LWO
-	load_start = convert_finish = clock();
-#endif
-
-	lwFreeObject( obj );
-
-#ifdef DEBUG_PM_LWO
-	load_finish = clock();
-	load_elapsed += (double)(load_finish - load_start) / CLOCKS_PER_SEC;
-	convert_elapsed = (double)(convert_finish - convert_start) / CLOCKS_PER_SEC;
-	_pico_printf( PICO_NORMAL, "Loaded model in in %-.2f second(s) (loading: %-.2fs converting: %-.2fs)\n", load_elapsed + convert_elapsed, load_elapsed, convert_elapsed  );
-#endif
-
-	/* return the new pico model */
-	return picoModel;
-}
-
-/* pico file format module definition */
-const picoModule_t picoModuleLWO =
-{
-	"1.0",						/* module version string */
-	"LightWave Object",			/* module display name */
-	"Arnout van Meer",			/* author's name */
-	"2003 Arnout van Meer, 2000 Ernie Wright",		/* module copyright */
-	{
-		"lwo", NULL, NULL, NULL	/* default extensions to use */
-	},
-	_lwo_canload,				/* validation routine */
-	_lwo_load,					/* load routine */
-	 NULL,						/* save validation routine */
-	 NULL						/* save routine */
-};
+/* -----------------------------------------------------------------------------
+
+PicoModel Library 
+
+Copyright (c) 2002, Randy Reddig & seaw0lf
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+Redistributions of source code must retain the above copyright notice, this list
+of conditions and the following disclaimer.
+
+Redistributions in binary form must reproduce the above copyright notice, this
+list of conditions and the following disclaimer in the documentation and/or
+other materials provided with the distribution.
+
+Neither the names of the copyright holders nor the names of its contributors may
+be used to endorse or promote products derived from this software without
+specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+----------------------------------------------------------------------------- */
+
+/* marker */
+#define PM_LWO_C
+
+/* dependencies */
+#include "picointernal.h"
+#include "lwo/lwo2.h"
+
+/* uncomment when debugging this module */
+/*#define DEBUG_PM_LWO*/
+
+#ifdef DEBUG_PM_LWO
+#include "time.h"
+#endif
+
+/* helper functions */
+static const char *lwo_lwIDToStr( unsigned int lwID )
+{
+	static char lwIDStr[5];
+
+	if (!lwID)
+	{
+		return "n/a";
+	}
+
+	lwIDStr[ 0 ] = (char)((lwID) >> 24);
+	lwIDStr[ 1 ] = (char)((lwID) >> 16);
+	lwIDStr[ 2 ] = (char)((lwID) >> 8);
+	lwIDStr[ 3 ] = (char)((lwID));
+	lwIDStr[ 4 ] = '\0';
+
+	return lwIDStr;
+}
+
+/*
+_lwo_canload()
+validates a LightWave Object model file. btw, i use the
+preceding underscore cause it's a static func referenced
+by one structure only.
+*/
+static int _lwo_canload( PM_PARAMS_CANLOAD )
+{
+	picoMemStream_t *s;
+	unsigned int failID = 0;
+	int failpos = -1;
+	int ret;
+
+	/* create a new pico memorystream */
+	s = _pico_new_memstream( (picoByte_t *)buffer, bufSize );
+	if (s == NULL)
+	{
+		return PICO_PMV_ERROR_MEMORY;
+	}
+
+	ret = lwValidateObject( fileName, s, &failID, &failpos );
+
+	_pico_free_memstream( s );
+
+	return ret;
+}
+
+/*
+_lwo_load()
+loads a LightWave Object model file.
+*/
+static picoModel_t *_lwo_load( PM_PARAMS_LOAD )
+{
+	picoMemStream_t	*s;
+	unsigned int	failID = 0;
+	int				failpos = -1;
+	lwObject		*obj;
+	lwSurface		*surface;
+	lwLayer			*layer;
+	lwPoint			*pt;
+	lwPolygon		*pol;
+	lwPolVert		*v;
+	lwVMapPt		*vm;
+	char			name[ 256 ];
+	int				i, j, k, numverts;
+
+	picoModel_t		*picoModel;
+	picoSurface_t	*picoSurface;
+	picoShader_t	*picoShader;
+	picoVec3_t		xyz, normal;
+	picoVec2_t		st;
+	picoColor_t		color;
+
+	int				defaultSTAxis[ 2 ];
+	picoVec2_t		defaultXYZtoSTScale;
+
+	picoVertexCombinationHash_t **hashTable;
+	picoVertexCombinationHash_t	*vertexCombinationHash;
+
+	int surfacePolyCount;
+
+#ifdef DEBUG_PM_LWO
+	clock_t load_start, load_finish, convert_start, convert_finish;
+	double load_elapsed, convert_elapsed;
+
+	load_start = clock();
+#endif
+
+	/* do frame check */
+	if( frameNum < 0 || frameNum >= 1 )
+	{
+		_pico_printf( PICO_ERROR, "Invalid or out-of-range LWO frame specified" );
+		return NULL;
+	}
+
+	/* create a new pico memorystream */
+	s = _pico_new_memstream( (picoByte_t *)buffer, bufSize );
+	if (s == NULL)
+	{
+		return NULL;
+	}
+
+	obj = lwGetObject( fileName, s, &failID, &failpos );
+
+	_pico_free_memstream( s );
+
+	if( !obj ) {
+		_pico_printf( PICO_ERROR, "Couldn't load LWO file, failed on ID '%s', position %d", lwo_lwIDToStr( failID ), failpos );
+		return NULL;
+	}
+
+#ifdef DEBUG_PM_LWO
+	convert_start = load_finish = clock();
+	load_elapsed = (double)(load_finish - load_start) / CLOCKS_PER_SEC;
+#endif
+
+	/* -------------------------------------------------
+	pico model creation
+	------------------------------------------------- */
+	
+	/* create a new pico model */
+	picoModel = PicoNewModel();
+	if (picoModel == NULL)
+	{
+		_pico_printf( PICO_ERROR, "Unable to allocate a new model" );
+		return NULL;
+	}
+
+	/* do model setup */
+	PicoSetModelFrameNum( picoModel, frameNum );
+	PicoSetModelNumFrames( picoModel, 1 );
+	PicoSetModelName( picoModel, fileName );
+	PicoSetModelFileName( picoModel, fileName );
+
+	/* create all polygons from layer[ 0 ] that belong to this surface */
+	layer = &obj->layer[0];
+
+	/* warn the user that other layers are discarded */
+	if (obj->nlayers > 1)
+	{
+		_pico_printf( PICO_WARNING, "LWO loader discards any geometry data not in Layer 1 (%d layers found)", obj->nlayers );
+	}
+
+	/* initialize dummy normal */
+	normal[ 0 ] = normal[ 1 ] = normal[ 2 ] = 0.f;
+
+	/* setup default st map */
+	st[ 0 ] = st[ 1 ] = 0.f;	/* st[0] holds max, st[1] holds max par one */
+	defaultSTAxis[ 0 ] = 0;
+	defaultSTAxis[ 1 ] = 1;
+	for( i = 0; i < 3; i++ )
+	{
+		float min = layer->bbox[ i ];
+		float max = layer->bbox[ i + 3 ];
+		float size = max - min;
+		
+		if (size > st[ 0 ])
+		{
+			defaultSTAxis[ 1 ] = defaultSTAxis[ 0 ];
+			defaultSTAxis[ 0 ] = i;
+
+			st[ 1 ] = st[ 0 ];
+			st[ 0 ] = size;
+		}
+		else if (size > st[ 1 ])
+		{
+			defaultSTAxis[ 1 ] = i;
+			st[ 1 ] = size;
+		}
+	}
+	defaultXYZtoSTScale[ 0 ] = 4.f / st[ 0 ];
+	defaultXYZtoSTScale[ 1 ] = 4.f / st[ 1 ];
+
+	/* LWO surfaces become pico surfaces */
+	surface = obj->surf;
+	while (surface)
+	{
+		/* allocate new pico surface */
+		picoSurface = PicoNewSurface( picoModel );
+		if (picoSurface == NULL)
+		{
+			_pico_printf( PICO_ERROR, "Unable to allocate a new model surface" );
+			PicoFreeModel( picoModel );
+			lwFreeObject( obj );
+			return NULL;
+		}
+
+		/* LWO model surfaces are all triangle meshes */
+		PicoSetSurfaceType( picoSurface, PICO_TRIANGLES );
+
+		/* set surface name */
+		PicoSetSurfaceName( picoSurface, surface->name );
+
+		/* create new pico shader */
+		picoShader = PicoNewShader( picoModel );
+		if (picoShader == NULL)
+		{
+			_pico_printf( PICO_ERROR, "Unable to allocate a new model shader" );
+			PicoFreeModel( picoModel );
+			lwFreeObject( obj );
+			return NULL;
+		}
+
+		/* detox and set shader name */
+		strncpy( name, surface->name, sizeof(name) );
+		_pico_first_token( name );
+		_pico_setfext( name, "" );
+		_pico_unixify( name );
+		PicoSetShaderName( picoShader, name );
+
+		/* associate current surface with newly created shader */
+		PicoSetSurfaceShader( picoSurface, picoShader );
+
+		/* copy indices and vertex data */
+		numverts = 0;
+
+		hashTable = PicoNewVertexCombinationHashTable();
+
+		if (hashTable == NULL)
+		{
+			_pico_printf( PICO_ERROR, "Unable to allocate hash table" );
+			PicoFreeModel( picoModel );
+			lwFreeObject( obj );
+			return NULL;
+		}
+
+		/* Local polygon index for this surface. We don't want to use i in the loop
+		 * since that is the global poly index for the entire layer */
+		surfacePolyCount = 0;
+
+		for( i = 0, pol = layer->polygon.pol; i < layer->polygon.count; i++, pol++ )
+		{
+			/* does this polygon belong to this surface? */
+			if (pol->surf != surface)
+				continue;
+
+			/* we only support polygons of the FACE type */
+			if (pol->type != ID_FACE)
+			{
+				_pico_printf( PICO_WARNING, "LWO loader discarded a polygon because it's type != FACE (%s)", lwo_lwIDToStr( pol->type ) );
+				continue;
+			}
+
+			/* NOTE: LWO has support for non-convex polygons, do we want to store them as well? */
+			if (pol->nverts != 3)
+			{
+				_pico_printf( PICO_WARNING, "LWO loader discarded a polygon because it has != 3 verts (%d)", pol->nverts );
+				continue;
+			}
+
+			/* We haven't discarded this polygon, so bump the surface polycount */
+			surfacePolyCount++;
+
+			for( j = 0, v = pol->v; j < 3; j++, v++ )
+			{
+				pt = &layer->point.pt[ v->index ];
+
+				/* setup data */
+				xyz[ 0 ] = pt->pos[ 0 ];
+				xyz[ 1 ] = pt->pos[ 2 ];
+				xyz[ 2 ] = pt->pos[ 1 ];
+
+/* doom3 lwo data doesn't seem to have smoothing-angle information */
+#if 0
+        if(surface->smooth <= 0)
+        {
+          /* use face normals */
+				  normal[ 0 ] = v->norm[ 0 ];
+				  normal[ 1 ] = v->norm[ 2 ];
+				  normal[ 2 ] = v->norm[ 1 ];
+        }
+        else
+#endif
+        {
+          /* smooth normals later */
+				  normal[ 0 ] = 0;
+				  normal[ 1 ] = 0;
+				  normal[ 2 ] = 0;
+        }
+
+				st[ 0 ] = xyz[ defaultSTAxis[ 0 ] ] * defaultXYZtoSTScale[ 0 ];
+				st[ 1 ] = xyz[ defaultSTAxis[ 1 ] ] * defaultXYZtoSTScale[ 1 ];
+
+				color[ 0 ] = (picoByte_t)(surface->color.rgb[ 0 ] * surface->diffuse.val * 0xFF);
+				color[ 1 ] = (picoByte_t)(surface->color.rgb[ 1 ] * surface->diffuse.val * 0xFF);
+				color[ 2 ] = (picoByte_t)(surface->color.rgb[ 2 ] * surface->diffuse.val * 0xFF);
+				color[ 3 ] = 0xFF;
+
+				/* set from points */
+				for( k = 0, vm = pt->vm; k < pt->nvmaps; k++, vm++ )
+				{
+					if (vm->vmap->type == LWID_('T','X','U','V'))
+					{
+						/* set st coords */
+						st[ 0 ] = vm->vmap->val[ vm->index ][ 0 ];
+						st[ 1 ] = 1.f - vm->vmap->val[ vm->index ][ 1 ];
+					}
+					else if (vm->vmap->type == LWID_('R','G','B','A'))
+					{
+						/* set rgba */
+						color[ 0 ] = (picoByte_t)(vm->vmap->val[ vm->index ][ 0 ] * surface->color.rgb[ 0 ] * surface->diffuse.val * 0xFF);
+						color[ 1 ] = (picoByte_t)(vm->vmap->val[ vm->index ][ 1 ] * surface->color.rgb[ 1 ] * surface->diffuse.val * 0xFF);
+						color[ 2 ] = (picoByte_t)(vm->vmap->val[ vm->index ][ 2 ] * surface->color.rgb[ 2 ] * surface->diffuse.val * 0xFF);
+						color[ 3 ] = (picoByte_t)(vm->vmap->val[ vm->index ][ 3 ] * 0xFF);
+					}
+				}
+
+				/* override with polygon data */
+				for( k = 0, vm = v->vm; k < v->nvmaps; k++, vm++ )
+				{
+					if (vm->vmap->type == LWID_('T','X','U','V'))
+					{
+						/* set st coords */
+						st[ 0 ] = vm->vmap->val[ vm->index ][ 0 ];
+						st[ 1 ] = 1.f - vm->vmap->val[ vm->index ][ 1 ];
+					}
+					else if (vm->vmap->type == LWID_('R','G','B','A'))
+					{
+						/* set rgba */
+						color[ 0 ] = (picoByte_t)(vm->vmap->val[ vm->index ][ 0 ] * surface->color.rgb[ 0 ] * surface->diffuse.val * 0xFF);
+						color[ 1 ] = (picoByte_t)(vm->vmap->val[ vm->index ][ 1 ] * surface->color.rgb[ 1 ] * surface->diffuse.val * 0xFF);
+						color[ 2 ] = (picoByte_t)(vm->vmap->val[ vm->index ][ 2 ] * surface->color.rgb[ 2 ] * surface->diffuse.val * 0xFF);
+						color[ 3 ] = (picoByte_t)(vm->vmap->val[ vm->index ][ 3 ] * 0xFF);
+					}
+				}
+
+				/* find vertex in this surface and if we can't find it there create it */
+				vertexCombinationHash = PicoFindVertexCombinationInHashTable( hashTable, xyz, normal, st, color );
+
+				if (vertexCombinationHash)
+				{
+					/* found an existing one */
+					PicoSetSurfaceIndex( picoSurface, (surfacePolyCount * 3 + j ), vertexCombinationHash->index );
+				}
+				else
+				{
+					/* it is a new one */
+					vertexCombinationHash = PicoAddVertexCombinationToHashTable( hashTable, xyz, normal, st, color, (picoIndex_t) numverts );
+
+					if (vertexCombinationHash == NULL)
+					{
+						_pico_printf( PICO_ERROR, "Unable to allocate hash bucket entry table" );
+						PicoFreeVertexCombinationHashTable( hashTable );
+						PicoFreeModel( picoModel );
+						lwFreeObject( obj );
+						return NULL;
+					}
+
+					/* add the vertex to this surface */
+					PicoSetSurfaceXYZ( picoSurface, numverts, xyz );
+
+					/* set dummy normal */
+					PicoSetSurfaceNormal( picoSurface, numverts, normal );
+
+					/* set color */
+					PicoSetSurfaceColor( picoSurface, 0, numverts, color );
+
+					/* set st coords */
+					PicoSetSurfaceST( picoSurface, 0, numverts, st );
+
+					/* set index */
+					PicoSetSurfaceIndex( picoSurface, (surfacePolyCount * 3 + j ), (picoIndex_t) numverts );
+
+					numverts++;
+				}
+			}
+		}
+
+		/* free the hashtable */
+		PicoFreeVertexCombinationHashTable( hashTable );
+
+		/* get next surface */		
+		surface = surface->next;
+	}
+
+#ifdef DEBUG_PM_LWO
+	load_start = convert_finish = clock();
+#endif
+
+	lwFreeObject( obj );
+
+#ifdef DEBUG_PM_LWO
+	load_finish = clock();
+	load_elapsed += (double)(load_finish - load_start) / CLOCKS_PER_SEC;
+	convert_elapsed = (double)(convert_finish - convert_start) / CLOCKS_PER_SEC;
+	_pico_printf( PICO_NORMAL, "Loaded model in in %-.2f second(s) (loading: %-.2fs converting: %-.2fs)\n", load_elapsed + convert_elapsed, load_elapsed, convert_elapsed  );
+#endif
+
+	/* return the new pico model */
+	return picoModel;
+}
+
+/* pico file format module definition */
+const picoModule_t picoModuleLWO =
+{
+	"1.0",						/* module version string */
+	"LightWave Object",			/* module display name */
+	"Arnout van Meer",			/* author's name */
+	"2003 Arnout van Meer, 2000 Ernie Wright",		/* module copyright */
+	{
+		"lwo", NULL, NULL, NULL	/* default extensions to use */
+	},
+	_lwo_canload,				/* validation routine */
+	_lwo_load,					/* load routine */
+	 NULL,						/* save validation routine */
+	 NULL						/* save routine */
+};
Index: plugins/archivezip/plugin.cpp
===================================================================
--- plugins/archivezip/plugin.cpp	(revision 3603)
+++ plugins/archivezip/plugin.cpp	(working copy)
@@ -29,6 +29,38 @@
 
 #include "ZipArchive.h"
 
+class ArchivePK3API :
+	public ArchiveLoader
+{
+public:
+	// greebo: Returns the opened file or NULL if failed.
+	virtual ArchivePtr openArchive(const std::string& name) {
+		return ZipArchivePtr(new ZipArchive(name));
+	}
+		
+	virtual const std::string& getExtension() {
+		static std::string _ext("PK3");
+		return _ext;
+	}
+  
+	// RegisterableModule implementation
+	virtual const std::string& getName() const {
+		static std::string _name("ArchivePK3");
+		return _name;
+	}
+
+	virtual const StringSet& getDependencies() const {
+		static StringSet _dependencies; // no dependencies
+		return _dependencies;
+	}
+
+	virtual void initialiseModule(const ApplicationContext& ctx) {
+		globalOutputStream() << "ArchivePK3::initialiseModule called\n";
+	}
+};
+typedef boost::shared_ptr<ArchivePK3API> ArchivePK3APIPtr;
+
+
 class ArchivePK4API :
 	public ArchiveLoader
 {
@@ -61,6 +93,7 @@
 typedef boost::shared_ptr<ArchivePK4API> ArchivePK4APIPtr;
 
 extern "C" void DARKRADIANT_DLLEXPORT RegisterModule(IModuleRegistry& registry) {
+	registry.registerModule(ArchivePK3APIPtr(new ArchivePK3API));
 	registry.registerModule(ArchivePK4APIPtr(new ArchivePK4API));
 	
 	// Initialise the streams
Index: plugins/image/image.cpp
===================================================================
--- plugins/image/image.cpp	(revision 3603)
+++ plugins/image/image.cpp	(working copy)
@@ -26,6 +26,7 @@
 
 #include "jpeg.h"
 #include "tga.h"
+#include "png.h"
 #include "bmp.h"
 #include "pcx.h"
 #include "dds.h"
@@ -33,6 +34,7 @@
 
 typedef boost::shared_ptr<TGALoader> TGALoaderPtr;
 typedef boost::shared_ptr<JPGLoader> JPGLoaderPtr;
+typedef boost::shared_ptr<PNGLoader> PNGLoaderPtr;
 typedef boost::shared_ptr<PCXLoader> PCXLoaderPtr;
 typedef boost::shared_ptr<BMPLoader> BMPLoaderPtr;
 typedef boost::shared_ptr<DDSLoader> DDSLoaderPtr;
@@ -41,6 +43,7 @@
 extern "C" void DARKRADIANT_DLLEXPORT RegisterModule(IModuleRegistry& registry) {
 	registry.registerModule(TGALoaderPtr(new TGALoader));
 	registry.registerModule(JPGLoaderPtr(new JPGLoader));
+	registry.registerModule(PNGLoaderPtr(new PNGLoader));
 	registry.registerModule(PCXLoaderPtr(new PCXLoader));
 	registry.registerModule(BMPLoaderPtr(new BMPLoader));
 	registry.registerModule(DDSLoaderPtr(new DDSLoader));
Index: plugins/image/png.cpp
===================================================================
--- plugins/image/png.cpp	(revision 0)
+++ plugins/image/png.cpp	(revision 0)
@@ -0,0 +1,169 @@
+/*
+Copyright (C) 1999-2006 Id Software, Inc. and contributors.
+For a list of contributors, see the accompanying CONTRIBUTORS file.
+
+This file is part of GtkRadiant.
+
+GtkRadiant is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+GtkRadiant is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GtkRadiant; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include "png.h"
+
+#include <png.h>
+//#include <setjmp.h>
+//#include <stdlib.h>
+//#include <stdio.h>
+//#include <string.h>
+#include "stream/textstream.h"
+
+#include "ifilesystem.h"
+
+#include "imagelib.h"
+
+typedef unsigned char byte;
+
+void user_warning_fn(png_structp png_ptr, png_const_charp warning_msg)
+{
+  globalErrorStream() << "libpng warning: " << warning_msg << "\n";
+}
+
+void user_error_fn(png_structp png_ptr, png_const_charp error_msg)
+{
+  globalErrorStream() << "libpng error: " << error_msg << "\n";
+  longjmp(png_ptr->jmpbuf, 0);
+}
+
+void user_read_data(png_structp png_ptr, png_bytep data, png_uint_32 length)
+{
+  png_bytep *p_p_fbuffer = (png_bytep*)png_get_io_ptr(png_ptr);
+  memcpy(data, *p_p_fbuffer, length);
+  *p_p_fbuffer += length;
+}
+
+static RGBAImagePtr LoadPNGBuff (unsigned char* fbuffer)
+{
+  png_byte** row_pointers;
+  png_bytep p_fbuffer;
+
+  p_fbuffer = fbuffer;
+	
+  // the reading glue
+  // http://www.libpng.org/pub/png/libpng-manual.html
+
+  png_structp png_ptr = png_create_read_struct
+    (PNG_LIBPNG_VER_STRING, (png_voidp)NULL,
+    user_error_fn, user_warning_fn);
+  if (!png_ptr)
+  {
+    globalErrorStream() << "libpng error: png_create_read_struct\n";
+    RGBAImagePtr();
+  }
+		
+  png_infop info_ptr = png_create_info_struct(png_ptr);
+  if (!info_ptr) {
+    png_destroy_read_struct(&png_ptr,
+      (png_infopp)NULL, (png_infopp)NULL);
+    globalErrorStream() << "libpng error: png_create_info_struct (info_ptr)\n";
+    RGBAImagePtr();
+  }
+	
+  png_infop end_info = png_create_info_struct(png_ptr);
+  if (!end_info) {
+    png_destroy_read_struct(&png_ptr, &info_ptr,
+      (png_infopp)NULL);
+    globalErrorStream() << "libpng error: png_create_info_struct (end_info)\n";
+    RGBAImagePtr();
+  }
+
+  // configure the read function
+  png_set_read_fn(png_ptr, (voidp)&p_fbuffer, (png_rw_ptr)&user_read_data);
+
+  if (setjmp(png_ptr->jmpbuf)) {
+    png_destroy_read_struct(&png_ptr, &info_ptr,
+      &end_info);
+    RGBAImagePtr();
+  }
+
+  png_read_info(png_ptr, info_ptr);
+
+  int bit_depth = png_get_bit_depth(png_ptr, info_ptr);
+  int color_type = png_get_color_type(png_ptr, info_ptr);
+
+  // we want to treat all images the same way
+  //   The following code transforms grayscale images of less than 8 to 8 bits, 
+  //   changes paletted images to RGB, and adds a full alpha channel if there is 
+  //   transparency information in a tRNS chunk.
+  if (color_type == PNG_COLOR_TYPE_PALETTE)
+   png_set_palette_to_rgb(png_ptr);
+
+  if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)
+    png_set_gray_1_2_4_to_8(png_ptr);
+
+  if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
+    png_set_tRNS_to_alpha(png_ptr);
+
+  if ( ! ( color_type & PNG_COLOR_MASK_ALPHA ) ) {
+    // Set the background color to draw transparent and alpha images over.
+    png_color_16 my_background, *image_background;
+
+    if (png_get_bKGD(png_ptr, info_ptr, &image_background))
+      png_set_background(png_ptr, image_background, 
+      PNG_BACKGROUND_GAMMA_FILE, 1, 1.0);
+    else
+      png_set_background(png_ptr, &my_background,
+      PNG_BACKGROUND_GAMMA_SCREEN, 0, 1.0);
+
+    // Add alpha byte after each RGB triplet
+    png_set_filler(png_ptr, 0xff, PNG_FILLER_AFTER);
+  }
+
+  // read the sucker in one chunk
+  png_read_update_info(png_ptr, info_ptr);
+
+  color_type = png_get_color_type(png_ptr, info_ptr);
+  bit_depth = png_get_bit_depth(png_ptr, info_ptr);
+
+  int width = png_get_image_width(png_ptr, info_ptr);
+  int height = png_get_image_height(png_ptr, info_ptr);
+
+  // allocate the pixel buffer, and the row pointers
+  RGBAImagePtr image(new RGBAImage(width, height));
+
+  row_pointers = (png_byte**) malloc((height) * sizeof(png_byte*));
+
+  int i;
+  for(i = 0; i < (height); i++)
+    row_pointers[i] = (png_byte*)(image->getRGBAPixels()) + i * 4 * (width);
+
+  // actual read
+  png_read_image(png_ptr, row_pointers);
+
+  /* read rest of file, and get additional chunks in info_ptr - REQUIRED */
+  png_read_end(png_ptr, info_ptr);
+
+  /* free up the memory structure */
+  png_destroy_read_struct(&png_ptr, &info_ptr, png_infopp_NULL);
+
+  free(row_pointers);
+
+  return image;
+}
+
+ImagePtr LoadPNG(ArchiveFile& file)
+{
+  ScopedArchiveBuffer buffer(file);
+  return LoadPNGBuff(buffer.buffer);//, static_cast<int>(buffer.length));
+}
+
Index: plugins/image/png.h
===================================================================
--- plugins/image/png.h	(revision 0)
+++ plugins/image/png.h	(revision 0)
@@ -0,0 +1,77 @@
+/*
+Copyright (C) 1999-2006 Id Software, Inc. and contributors.
+For a list of contributors, see the accompanying CONTRIBUTORS file.
+
+This file is part of GtkRadiant.
+
+GtkRadiant is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+GtkRadiant is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GtkRadiant; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#if !defined (INCLUDED_PNG_H)
+#define INCLUDED_PNG_H
+
+#include "ifilesystem.h"
+#include "iimage.h"
+#include "imagelib.h" // for RGBAImagePtr
+#include <iostream>
+
+ImagePtr LoadPNG(ArchiveFile& file);
+
+/* Tr3B: A PNGLoader is capable of loading Portable Network Graphic (PNG) files.
+ *  
+ * Use load() to actually retrieve an Image* object with the loaded image.
+ * 
+ * Shouldn't be used to load textures directly, use the 
+ * GlobalShaderSystem() module instead.  
+ * 
+ * Complies with the ImageLoader interface defined in "iimage.h" 
+ */
+class PNGLoader :
+	public ImageLoader
+{
+public:
+	/* greebo: This loads the file and returns the pointer to 
+	 * the allocated Image object (or NULL, if the load failed). 
+	 */
+	ImagePtr load(ArchiveFile& file) const {
+		// Pass the call to the according load function
+		return LoadPNG(file);
+	}
+	
+	/* greebo: Gets the file extension of the supported image file type (e.g. "jpg") 
+	 */
+	std::string getExtension() const {
+		return "png";
+	}
+
+	// RegisterableModule implementation
+	virtual const std::string& getName() const {
+		static std::string _name("ImageLoaderPNG");
+		return _name;
+	}
+	
+	virtual const StringSet& getDependencies() const {
+		static StringSet _dependencies; // no dependencies
+  		return _dependencies;
+	}
+	
+	virtual void initialiseModule(const ApplicationContext& ctx) {
+		globalOutputStream() << "ImageLoaderPNG::initialiseModule called.\n";
+	}
+};
+
+#endif
+
+
Index: plugins/mapdoom3/Doom3MapFormat.cpp
===================================================================
--- plugins/mapdoom3/Doom3MapFormat.cpp	(revision 3603)
+++ plugins/mapdoom3/Doom3MapFormat.cpp	(working copy)
@@ -23,111 +23,111 @@
 
 namespace map {
 
-	namespace {
-		const std::string RKEY_PRECISION = "game/mapFormat/floatPrecision";
+	namespace {
+		const std::string RKEY_PRECISION = "game/mapFormat/floatPrecision";
 	}
 
-// RegisterableModule implementation
-const std::string& Doom3MapFormat::getName() const {
-	static std::string _name("Doom3MapLoader");
-	return _name;
-}
-
-const StringSet& Doom3MapFormat::getDependencies() const {
-	static StringSet _dependencies;
-
-	if (_dependencies.empty()) {
-		_dependencies.insert(MODULE_FILETYPES);
-		_dependencies.insert(MODULE_ECLASSMANAGER);
-		_dependencies.insert(MODULE_LAYERSYSTEM);
-		_dependencies.insert(MODULE_BRUSHCREATOR);
-		_dependencies.insert(MODULE_PATCH + DEF2);
-		_dependencies.insert(MODULE_PATCH + DEF3);
-		_dependencies.insert(MODULE_XMLREGISTRY);
-	}
-
-	return _dependencies;
-}
-
-void Doom3MapFormat::initialiseModule(const ApplicationContext& ctx) {
-	globalOutputStream() << "MapDoom3API::initialiseModule called.\n";
-	
-	GlobalFiletypes().addType(
-		"map", getName(), FileTypePattern("Doom 3 map", "*.map"));
-	GlobalFiletypes().addType(
-		"map", getName(), FileTypePattern("Doom 3 region", "*.reg"));
-	GlobalFiletypes().addType(
-		"map", getName(), FileTypePattern("Doom 3 prefab", "*.pfb"));
-	
-	// Add the filepatterns for the prefab (different order)
-	GlobalFiletypes().addType(
-		"prefab", getName(), FileTypePattern("Doom 3 prefab", "*.pfb"));
-	GlobalFiletypes().addType(
-		"prefab", getName(), FileTypePattern("Doom 3 map", "*.map"));
-	GlobalFiletypes().addType(
-		"prefab", getName(), FileTypePattern("Doom 3 region", "*.reg"));
-}
-
-scene::INodePtr Doom3MapFormat::parsePrimitive(parser::DefTokeniser& tokeniser) const {
-    std::string primitive = tokeniser.nextToken();
-    
-    if (primitive == "patchDef3") {
-        return GlobalPatchCreator(DEF3).createPatch();
-    }
-    else if (primitive == "patchDef2") {
-        return GlobalPatchCreator(DEF2).createPatch();
-    }
-    else if(primitive == "brushDef3") {
-    	return GlobalBrushCreator().createBrush();
-    }
-    else {
-        return scene::INodePtr();
-    }
-}
-
-void Doom3MapFormat::readGraph(const MapImportInfo& importInfo) const {
-	assert(importInfo.root != NULL);
-
-	// Read the infofile
-	InfoFile infoFile(importInfo.infoStream);
-
-	try {
-		// Start parsing, this will throw if any errors occur
-		infoFile.parse();
-	}
-	catch (parser::ParseException e) {
-        globalErrorStream() << "[mapdoom3] Unable to parse info file: " << e.what() << "\n";
-    }
-
-	// Construct a MapImporter that will do the map parsing
-	NodeImporter importer(importInfo, infoFile, *this);
-	importer.parse();
-
-	// Create the layers according to the data found in the map information file
-	const InfoFile::LayerNameMap& layers = infoFile.getLayerNames();
-
-	for (InfoFile::LayerNameMap::const_iterator i = layers.begin(); 
-		 i != layers.end(); i++)
-	{
-		// Create the named layer with the saved ID
-		GlobalLayerSystem().createLayer(i->second, i->first);
-	}
-	
-	// Now that the graph is in place, assign the layers
-	AssignLayerMappingWalker walker(infoFile);
-	importInfo.root->traverse(walker);
-}
-
-void Doom3MapFormat::writeGraph(const MapExportInfo& exportInfo) const {
-	int precision = GlobalRegistry().getInt(RKEY_PRECISION);
-	exportInfo.mapStream.precision(precision);
-
-	// Write the version tag first
-    exportInfo.mapStream << VERSION << " " << MAPVERSION << std::endl;
-
-	// Instantiate a NodeExporter class and call the traverse function
-	NodeExporter exporter(exportInfo.mapStream, exportInfo.infoStream);
-	exportInfo.traverse(exportInfo.root, exporter);
+// RegisterableModule implementation
+const std::string& Doom3MapFormat::getName() const {
+	static std::string _name("Doom3MapLoader");
+	return _name;
 }
 
+const StringSet& Doom3MapFormat::getDependencies() const {
+	static StringSet _dependencies;
+
+	if (_dependencies.empty()) {
+		_dependencies.insert(MODULE_FILETYPES);
+		_dependencies.insert(MODULE_ECLASSMANAGER);
+		_dependencies.insert(MODULE_LAYERSYSTEM);
+		_dependencies.insert(MODULE_BRUSHCREATOR);
+		_dependencies.insert(MODULE_PATCH + DEF2);
+		_dependencies.insert(MODULE_PATCH + DEF3);
+		_dependencies.insert(MODULE_XMLREGISTRY);
+	}
+
+	return _dependencies;
+}
+
+void Doom3MapFormat::initialiseModule(const ApplicationContext& ctx) {
+	globalOutputStream() << "MapDoom3API::initialiseModule called.\n";
+	
+	GlobalFiletypes().addType(
+		"map", getName(), FileTypePattern("Doom 3 map", "*.map"));
+	GlobalFiletypes().addType(
+		"map", getName(), FileTypePattern("Doom 3 region", "*.reg"));
+	GlobalFiletypes().addType(
+		"map", getName(), FileTypePattern("Doom 3 prefab", "*.pfb"));
+	
+	// Add the filepatterns for the prefab (different order)
+	GlobalFiletypes().addType(
+		"prefab", getName(), FileTypePattern("Doom 3 prefab", "*.pfb"));
+	GlobalFiletypes().addType(
+		"prefab", getName(), FileTypePattern("Doom 3 map", "*.map"));
+	GlobalFiletypes().addType(
+		"prefab", getName(), FileTypePattern("Doom 3 region", "*.reg"));
+}
+
+scene::INodePtr Doom3MapFormat::parsePrimitive(parser::DefTokeniser& tokeniser) const {
+    std::string primitive = tokeniser.nextToken();
+    
+    if (primitive == "patchDef3") {
+        return GlobalPatchCreator(DEF3).createPatch();
+    }
+    else if (primitive == "patchDef2") {
+        return GlobalPatchCreator(DEF2).createPatch();
+    }
+    else if(primitive == "brushDef3") {
+    	return GlobalBrushCreator().createBrush();
+    }
+    else {
+        return scene::INodePtr();
+    }
+}
+
+void Doom3MapFormat::readGraph(const MapImportInfo& importInfo) const {
+	assert(importInfo.root != NULL);
+
+	// Read the infofile
+	InfoFile infoFile(importInfo.infoStream);
+
+	try {
+		// Start parsing, this will throw if any errors occur
+		infoFile.parse();
+	}
+	catch (parser::ParseException e) {
+        globalErrorStream() << "[mapdoom3] Unable to parse info file: " << e.what() << "\n";
+    }
+
+	// Construct a MapImporter that will do the map parsing
+	NodeImporter importer(importInfo, infoFile, *this);
+	importer.parse();
+
+	// Create the layers according to the data found in the map information file
+	const InfoFile::LayerNameMap& layers = infoFile.getLayerNames();
+
+	for (InfoFile::LayerNameMap::const_iterator i = layers.begin(); 
+		 i != layers.end(); i++)
+	{
+		// Create the named layer with the saved ID
+		GlobalLayerSystem().createLayer(i->second, i->first);
+	}
+	
+	// Now that the graph is in place, assign the layers
+	AssignLayerMappingWalker walker(infoFile);
+	importInfo.root->traverse(walker);
+}
+
+void Doom3MapFormat::writeGraph(const MapExportInfo& exportInfo) const {
+	int precision = GlobalRegistry().getInt(RKEY_PRECISION);
+	exportInfo.mapStream.precision(precision);
+
+	// Write the version tag first
+    exportInfo.mapStream << VERSION << " " << MAPVERSION << std::endl;
+
+	// Instantiate a NodeExporter class and call the traverse function
+	NodeExporter exporter(exportInfo.mapStream, exportInfo.infoStream);
+	exportInfo.traverse(exportInfo.root, exporter);
+}
+
 } // namespace map
Index: plugins/mapdoom3/InfoFile.cpp
===================================================================
--- plugins/mapdoom3/InfoFile.cpp	(revision 3603)
+++ plugins/mapdoom3/InfoFile.cpp	(working copy)
@@ -10,167 +10,167 @@
 #include <boost/algorithm/string/classification.hpp>
 #include <boost/lexical_cast.hpp>
 
-namespace map {
-
-// Pass the input stream to the constructor
-InfoFile::InfoFile(std::istream& infoStream) :
-	_tok(infoStream),
-	_isValid(true)
-{
-	_standardLayerList.insert(0);
-}
-
-const InfoFile::LayerNameMap& InfoFile::getLayerNames() const {
-	return _layerNames;
-}
-
-std::size_t InfoFile::getLayerMappingCount() const {
-	return _layerMappings.size();
-}
-
-const scene::LayerList& InfoFile::getNextLayerMapping() {
-	// Check if we have a valid infofile
-	if (!_isValid) {
-		return _standardLayerList;
-	}
-
-	// Check if the node index is out of bounds
-	if (_layerMappingIterator == _layerMappings.end()) {
-		return _standardLayerList;
-	}
-
-	// Return the current list and increase the iterator afterwards
-	return *(_layerMappingIterator++);
-}
-
-void InfoFile::parse() {
-	// parse the header
-	try {
-		std::vector<std::string> parts;
-		boost::algorithm::split(parts, HEADER_SEQUENCE, boost::algorithm::is_any_of(" "));
-
-		// Parse the string "DarkRadiant Map Information File Version"
-		for (std::size_t i = 0; i < parts.size(); i++) {
-			_tok.assertNextToken(parts[i]);
-		}
-
-		float version = boost::lexical_cast<float>(_tok.nextToken());
-
-		if (version != MAP_INFO_VERSION) {
-			_isValid = false;
-			throw parser::ParseException("Map Info File Version invalid");
-		}
-	}
-	catch (parser::ParseException e) {
-        globalErrorStream() 
-            << "[mapdoom3] Unable to parse info file header: " 
-            << e.what() << "\n";
-		_isValid = false;
-        return;
-    }
-    catch (boost::bad_lexical_cast e) {
-        globalErrorStream() 
-            << "[mapdoom3] Unable to parse info file version: " 
-            << e.what() << "\n";
-		_isValid = false;
-        return;
-    }
-
-	// The opening brace of the master block
-	_tok.assertNextToken("{");
-	
-	parseInfoFileBody();
-
-	// Set the layer mapping iterator to the beginning
-	_layerMappingIterator = _layerMappings.begin();
-}
-
-void InfoFile::parseInfoFileBody() {
-	while (_tok.hasMoreTokens()) {
-		std::string token = _tok.nextToken();
-
-		if (token == LAYERS) {
-			parseLayerNames();
-			continue;
-		}
-
-		if (token == NODE_TO_LAYER_MAPPING) {
-			parseNodeToLayerMapping();
-			continue;
-		}
-
-		if (token == "}") {
-			break;
-		}
-	}
-}
-
-void InfoFile::parseLayerNames() {
-	// The opening brace
-	_tok.assertNextToken("{");
-	
-	while (_tok.hasMoreTokens()) {
-		std::string token = _tok.nextToken();
-
-		if (token == LAYER) {
-			// Get the ID
-			std::string layerIDStr = _tok.nextToken();
-			int layerID = strToInt(layerIDStr);
-
-			_tok.assertNextToken("{");
-
-			// Assemble the name
-			std::string name;
-
-			token = _tok.nextToken();
-			while (token != "}") {
-				name += token;
-				token = _tok.nextToken();
-			}
-
-			globalOutputStream() << "[InfoFile]: Parsed layer #" 
-				<< layerID << " with name " << name.c_str() << "\n";
-
-			_layerNames.insert(LayerNameMap::value_type(layerID, name));
-
-			continue;
-		}
-
-		if (token == "}") {
-			break;
-		}
-	}
-}
-
-void InfoFile::parseNodeToLayerMapping() {
-	// The opening brace
-	_tok.assertNextToken("{");
-
-	while (_tok.hasMoreTokens()) {
-		std::string token = _tok.nextToken();
-
-		if (token == NODE) {
-			_tok.assertNextToken("{");
-
-			// Create a new LayerList
-			_layerMappings.push_back(scene::LayerList());
-
-			while (_tok.hasMoreTokens()) {
-				std::string nodeToken = _tok.nextToken();
-
-				if (nodeToken == "}") {
-					break;
-				}
-
-				// Add the ID to the list
-				_layerMappings.back().insert(strToInt(nodeToken));
-			}
-		}
-
-		if (token == "}") {
-			break;
-		}
-	}
-}
-
-} // namespace map
+namespace map {
+
+// Pass the input stream to the constructor
+InfoFile::InfoFile(std::istream& infoStream) :
+	_tok(infoStream),
+	_isValid(true)
+{
+	_standardLayerList.insert(0);
+}
+
+const InfoFile::LayerNameMap& InfoFile::getLayerNames() const {
+	return _layerNames;
+}
+
+std::size_t InfoFile::getLayerMappingCount() const {
+	return _layerMappings.size();
+}
+
+const scene::LayerList& InfoFile::getNextLayerMapping() {
+	// Check if we have a valid infofile
+	if (!_isValid) {
+		return _standardLayerList;
+	}
+
+	// Check if the node index is out of bounds
+	if (_layerMappingIterator == _layerMappings.end()) {
+		return _standardLayerList;
+	}
+
+	// Return the current list and increase the iterator afterwards
+	return *(_layerMappingIterator++);
+}
+
+void InfoFile::parse() {
+	// parse the header
+	try {
+		std::vector<std::string> parts;
+		boost::algorithm::split(parts, HEADER_SEQUENCE, boost::algorithm::is_any_of(" "));
+
+		// Parse the string "DarkRadiant Map Information File Version"
+		for (std::size_t i = 0; i < parts.size(); i++) {
+			_tok.assertNextToken(parts[i]);
+		}
+
+		float version = boost::lexical_cast<float>(_tok.nextToken());
+
+		if (version != MAP_INFO_VERSION) {
+			_isValid = false;
+			throw parser::ParseException("Map Info File Version invalid");
+		}
+	}
+	catch (parser::ParseException e) {
+        globalErrorStream() 
+            << "[mapdoom3] Unable to parse info file header: " 
+            << e.what() << "\n";
+		_isValid = false;
+        return;
+    }
+    catch (boost::bad_lexical_cast e) {
+        globalErrorStream() 
+            << "[mapdoom3] Unable to parse info file version: " 
+            << e.what() << "\n";
+		_isValid = false;
+        return;
+    }
+
+	// The opening brace of the master block
+	_tok.assertNextToken("{");
+	
+	parseInfoFileBody();
+
+	// Set the layer mapping iterator to the beginning
+	_layerMappingIterator = _layerMappings.begin();
+}
+
+void InfoFile::parseInfoFileBody() {
+	while (_tok.hasMoreTokens()) {
+		std::string token = _tok.nextToken();
+
+		if (token == LAYERS) {
+			parseLayerNames();
+			continue;
+		}
+
+		if (token == NODE_TO_LAYER_MAPPING) {
+			parseNodeToLayerMapping();
+			continue;
+		}
+
+		if (token == "}") {
+			break;
+		}
+	}
+}
+
+void InfoFile::parseLayerNames() {
+	// The opening brace
+	_tok.assertNextToken("{");
+	
+	while (_tok.hasMoreTokens()) {
+		std::string token = _tok.nextToken();
+
+		if (token == LAYER) {
+			// Get the ID
+			std::string layerIDStr = _tok.nextToken();
+			int layerID = strToInt(layerIDStr);
+
+			_tok.assertNextToken("{");
+
+			// Assemble the name
+			std::string name;
+
+			token = _tok.nextToken();
+			while (token != "}") {
+				name += token;
+				token = _tok.nextToken();
+			}
+
+			globalOutputStream() << "[InfoFile]: Parsed layer #" 
+				<< layerID << " with name " << name.c_str() << "\n";
+
+			_layerNames.insert(LayerNameMap::value_type(layerID, name));
+
+			continue;
+		}
+
+		if (token == "}") {
+			break;
+		}
+	}
+}
+
+void InfoFile::parseNodeToLayerMapping() {
+	// The opening brace
+	_tok.assertNextToken("{");
+
+	while (_tok.hasMoreTokens()) {
+		std::string token = _tok.nextToken();
+
+		if (token == NODE) {
+			_tok.assertNextToken("{");
+
+			// Create a new LayerList
+			_layerMappings.push_back(scene::LayerList());
+
+			while (_tok.hasMoreTokens()) {
+				std::string nodeToken = _tok.nextToken();
+
+				if (nodeToken == "}") {
+					break;
+				}
+
+				// Add the ID to the list
+				_layerMappings.back().insert(strToInt(nodeToken));
+			}
+		}
+
+		if (token == "}") {
+			break;
+		}
+	}
+}
+
+} // namespace map
Index: plugins/mapdoom3/NodeImporter.cpp
===================================================================
--- plugins/mapdoom3/NodeImporter.cpp	(revision 3603)
+++ plugins/mapdoom3/NodeImporter.cpp	(working copy)
@@ -22,8 +22,8 @@
 	namespace {
 		const std::string RKEY_MAP_LOAD_STATUS_INTERLEAVE = "user/ui/map/loadStatusInterleave";
 
-		inline MapImporterPtr Node_getMapImporter(scene::INodePtr node) {
-			return boost::dynamic_pointer_cast<MapImporter>(node);
+		inline MapImporterPtr Node_getMapImporter(scene::INodePtr node) {
+			return boost::dynamic_pointer_cast<MapImporter>(node);
 		}
 	}
 
@@ -50,67 +50,67 @@
 		return;
 	}
 
-	// Read each entity in the map, until EOF is reached
-	while (_tok.hasMoreTokens()) {
-		// Update the dialog text. This will throw an exception if the cancel
-		// button is clicked, which we must catch and handle.
-		if (_entityCount % _loadStatusInterleave == 0) {
-			try {
-				_dialog.setText("Loading entity " + sizetToStr(_entityCount));
-			}
-			catch (gtkutil::ModalProgressDialog::OperationAbortedException e) {
-				gtkutil::errorDialog("Map loading cancelled", 
-									 GlobalRadiant().getMainWindow());
-				return;			
-			}
-		}
-
-		// Create an entity node by parsing from the stream. If there is an
-		// exception, display it and return
-		try {
-			parseEntity();
-		}
-		catch (std::runtime_error e) {
-			gtkutil::errorDialog(
-				"Failed on entity " + sizetToStr(_entityCount) + "\n\n" + e.what(), 
-				GlobalRadiant().getMainWindow()
-			);
-			return;			
-		}
-
-		_entityCount++;
+	// Read each entity in the map, until EOF is reached
+	while (_tok.hasMoreTokens()) {
+		// Update the dialog text. This will throw an exception if the cancel
+		// button is clicked, which we must catch and handle.
+		if (_entityCount % _loadStatusInterleave == 0) {
+			try {
+				_dialog.setText("Loading entity " + sizetToStr(_entityCount));
+			}
+			catch (gtkutil::ModalProgressDialog::OperationAbortedException e) {
+				gtkutil::errorDialog("Map loading cancelled", 
+									 GlobalRadiant().getMainWindow());
+				return;			
+			}
+		}
+
+		// Create an entity node by parsing from the stream. If there is an
+		// exception, display it and return
+		try {
+			parseEntity();
+		}
+		catch (std::runtime_error e) {
+			gtkutil::errorDialog(
+				"Failed on entity " + sizetToStr(_entityCount) + "\n\n" + e.what(), 
+				GlobalRadiant().getMainWindow()
+			);
+			return;			
+		}
+
+		_entityCount++;
 	}
 }
 
 bool NodeImporter::parseMapVersion() {
-	// Parse the map version
-    float version = 0;
-
-    try {
-        _tok.assertNextToken(VERSION);
-        version = boost::lexical_cast<float>(_tok.nextToken());
-    }
-    catch (parser::ParseException e) {
-        globalErrorStream() 
-            << "[mapdoom3] Unable to parse map version: " 
-            << e.what() << "\n";
-        return false;
-    }
-    catch (boost::bad_lexical_cast e) {
-        globalErrorStream() 
-            << "[mapdoom3] Unable to parse map version: " 
-            << e.what() << "\n";
-        return false;
-    }
-
-    // Check we have the correct version for this module
-    if (version != MAPVERSION) {
-        globalErrorStream() 
-            << "Incorrect map version: required " << MAPVERSION 
-            << ", found " << version << "\n";
-        return false;
+	// Parse the map version
+    float version = 0;
+
+    try {
+        _tok.assertNextToken(VERSION);
+        version = boost::lexical_cast<float>(_tok.nextToken());
     }
+    catch (parser::ParseException e) {
+        globalErrorStream() 
+            << "[mapdoom3] Unable to parse map version: " 
+            << e.what() << "\n";
+        return false;
+    }
+    catch (boost::bad_lexical_cast e) {
+        globalErrorStream() 
+            << "[mapdoom3] Unable to parse map version: " 
+            << e.what() << "\n";
+        return false;
+    }
 
+    // Check we have the correct version for this module
+    if (version != MAPVERSION) {
+        globalErrorStream() 
+            << "Incorrect map version: required " << MAPVERSION 
+            << ", found " << version << "\n";
+        return false;
+    }
+
 	return true;
 }
 
@@ -118,177 +118,177 @@
 	// Check if the entitycount is matching the interleave
 	bool updateDialog = (_entityCount % _loadStatusInterleave == 0);
 
-    // Update the dialog
-    if (updateDialog && (_primitiveCount % _loadStatusInterleave == 0)) {
-        _dialog.setText(
-            _dlgEntityText + "\nPrimitive " + sizetToStr(_primitiveCount)
-        );
-    }
-
-    _primitiveCount++;
-    
-    // Try to parse the primitive, throwing exception if failed
-    scene::INodePtr primitive(_parser.parsePrimitive(_tok));
-
-    if (!primitive || !Node_getMapImporter(primitive)->importTokens(_tok)) {
-        throw std::runtime_error("Primitive #" + sizetToStr(_primitiveCount) 
-                                 + ": parse error\n");
-    }
-    
-    // Now add the primitive as a child of the entity
-    if (Node_getEntity(parentEntity)->isContainer()) {
-        parentEntity->addChildNode(primitive);
+    // Update the dialog
+    if (updateDialog && (_primitiveCount % _loadStatusInterleave == 0)) {
+        _dialog.setText(
+            _dlgEntityText + "\nPrimitive " + sizetToStr(_primitiveCount)
+        );
     }
+
+    _primitiveCount++;
+    
+    // Try to parse the primitive, throwing exception if failed
+    scene::INodePtr primitive(_parser.parsePrimitive(_tok));
+
+    if (!primitive || !Node_getMapImporter(primitive)->importTokens(_tok)) {
+        throw std::runtime_error("Primitive #" + sizetToStr(_primitiveCount) 
+                                 + ": parse error\n");
+    }
+    
+    // Now add the primitive as a child of the entity
+    if (Node_getEntity(parentEntity)->isContainer()) {
+        parentEntity->addChildNode(primitive);
+    }
 }
-
-scene::INodePtr NodeImporter::createEntity(const EntityKeyValues& keyValues) {
-    // Get the classname from the EntityKeyValues
-    EntityKeyValues::const_iterator found = keyValues.find("classname");
-
-    if (found == keyValues.end()) {
-		throw std::runtime_error("NodeImporter::createEntity(): could not find classname.");
-    }
-    
-    // Otherwise create the entity and add all of the properties
-    std::string className = found->second;
-	IEntityClassPtr classPtr = GlobalEntityClassManager().findClass(className);
-
-	if (classPtr == NULL) {
-		globalErrorStream() << "[mapdoom3]: Could not find entity class: " 
-			                << className.c_str() << "\n";
-
-		// greebo: EntityClass not found, insert a brush-based one
-		classPtr = GlobalEntityClassManager().findOrInsert(className, true);
-	}
-    
-	// Create the actual entity node
-    scene::INodePtr entity(GlobalEntityCreator().createEntity(classPtr));
-
-	Entity* ent = Node_getEntity(entity);
-	assert(ent != NULL); // entity cast must not fail
-
-    for (EntityKeyValues::const_iterator i = keyValues.begin(); 
-         i != keyValues.end(); 
-         ++i)
-    {
-        ent->setKeyValue(i->first, i->second);
-    }
-
-    return entity;
+
+scene::INodePtr NodeImporter::createEntity(const EntityKeyValues& keyValues) {
+    // Get the classname from the EntityKeyValues
+    EntityKeyValues::const_iterator found = keyValues.find("classname");
+
+    if (found == keyValues.end()) {
+		throw std::runtime_error("NodeImporter::createEntity(): could not find classname.");
+    }
+    
+    // Otherwise create the entity and add all of the properties
+    std::string className = found->second;
+	IEntityClassPtr classPtr = GlobalEntityClassManager().findClass(className);
+
+	if (classPtr == NULL) {
+		globalErrorStream() << "[mapdoom3]: Could not find entity class: " 
+			                << className.c_str() << "\n";
+
+		// greebo: EntityClass not found, insert a brush-based one
+		classPtr = GlobalEntityClassManager().findOrInsert(className, true);
+	}
+    
+	// Create the actual entity node
+    scene::INodePtr entity(GlobalEntityCreator().createEntity(classPtr));
+
+	Entity* ent = Node_getEntity(entity);
+	assert(ent != NULL); // entity cast must not fail
+
+    for (EntityKeyValues::const_iterator i = keyValues.begin(); 
+         i != keyValues.end(); 
+         ++i)
+    {
+        ent->setKeyValue(i->first, i->second);
+    }
+
+    return entity;
 }
 
 void NodeImporter::parseEntity() {
-	// Set up the progress dialog text
-	_dlgEntityText = "Loading entity " + sizetToStr(_entityCount);
-	
-    // Map of keyvalues for this entity
-    EntityKeyValues keyValues;
-
-    // The actual entity. This is initially null, and will be created when
-    // primitives start or the end of the entity is reached
+	// Set up the progress dialog text
+	_dlgEntityText = "Loading entity " + sizetToStr(_entityCount);
+	
+    // Map of keyvalues for this entity
+    EntityKeyValues keyValues;
+
+    // The actual entity. This is initially null, and will be created when
+    // primitives start or the end of the entity is reached
     scene::INodePtr entity;
 
-	// Start parsing, first token must be an open brace
-	_tok.assertNextToken("{");
-
-	std::string token = _tok.nextToken();
-
-	// Reset the primitive counter, we're starting a new entity
-	_primitiveCount = 0;
-	
-	while (true) {
-	    // Token must be either a key, a "{" to indicate the start of a 
-	    // primitive, or a "}" to indicate the end of the entity
-
-	    if (token == "{") { // PRIMITIVE
-			// Create the entity right now, if not yet done
-			if (entity == NULL) {
-				entity = createEntity(keyValues);
-			}
-
-			// Parse the primitive block, and pass the parent entity
-			parsePrimitive(entity);
-	    }
-	    else if (token == "}") { // END OF ENTITY
-            // Create the entity if necessary and return it
-	        if (entity == NULL) {
-	            entity = createEntity(keyValues);
-	        }
-			break;
-	    }
-	    else { // KEY
-	        std::string value = _tok.nextToken();
-
-	        // Sanity check (invalid number of tokens will get us out of sync)
-	        if (value == "{" || value == "}") {
-	            throw std::runtime_error(
-	                "Parsed invalid value '" + value + "' for key '" + token + "'"
-	            );
-	        }
-	        
-	        // Otherwise add the keyvalue pair to our map
-	        keyValues.insert(EntityKeyValues::value_type(token, value));
-	    }
-	    
-	    // Get the next token
-	    token = _tok.nextToken();
+	// Start parsing, first token must be an open brace
+	_tok.assertNextToken("{");
+
+	std::string token = _tok.nextToken();
+
+	// Reset the primitive counter, we're starting a new entity
+	_primitiveCount = 0;
+	
+	while (true) {
+	    // Token must be either a key, a "{" to indicate the start of a 
+	    // primitive, or a "}" to indicate the end of the entity
+
+	    if (token == "{") { // PRIMITIVE
+			// Create the entity right now, if not yet done
+			if (entity == NULL) {
+				entity = createEntity(keyValues);
+			}
+
+			// Parse the primitive block, and pass the parent entity
+			parsePrimitive(entity);
+	    }
+	    else if (token == "}") { // END OF ENTITY
+            // Create the entity if necessary and return it
+	        if (entity == NULL) {
+	            entity = createEntity(keyValues);
+	        }
+			break;
+	    }
+	    else { // KEY
+	        std::string value = _tok.nextToken();
+
+	        // Sanity check (invalid number of tokens will get us out of sync)
+	        if (value == "{" || value == "}") {
+	            throw std::runtime_error(
+	                "Parsed invalid value '" + value + "' for key '" + token + "'"
+	            );
+	        }
+	        
+	        // Otherwise add the keyvalue pair to our map
+	        keyValues.insert(EntityKeyValues::value_type(token, value));
+	    }
+	    
+	    // Get the next token
+	    token = _tok.nextToken();
 	}
 
-	// Insert the entity
+	// Insert the entity
 	insertEntity(entity);
 }
 
-bool NodeImporter::checkEntityClass(const scene::INodePtr& entity) {
-	// Obtain list of entityclasses to skip
-	static xml::NodeList skipLst = 
-		GlobalRegistry().findXPath("debug/mapdoom3//discardEntityClass");
-
-	// Obtain the entity class of this node
-	IEntityClassConstPtr entityClass = 
-			Node_getEntity(entity)->getEntityClass();
-
-	// Skip this entity class if it is in the list
-	for (xml::NodeList::const_iterator i = skipLst.begin();
-		 i != skipLst.end();
-		 ++i)
-	{
-		if (i->getAttributeValue("value") == entityClass->getName()) {
-			std::cout << "DEBUG: discarding entity class " 
-					  << entityClass->getName() << std::endl;
-			return false;
-		}
-	}
-
-	return true;
-}
-
-bool NodeImporter::checkEntityNum() {
-	// Entity range XPath
-	static xml::NodeList entityRange = 
-					GlobalRegistry().findXPath("debug/mapdoom3/entityRange");
-	static xml::NodeList::iterator i = entityRange.begin();
-	
-	// Test the entity number is in the range
-	if (i != entityRange.end()) {
-		static std::size_t lower = strToSizet(i->getAttributeValue("start"));
-		static std::size_t upper = strToSizet(i->getAttributeValue("end"));
-	
-		if (_entityCount < lower || _entityCount > upper) {
-			std::cout << "DEBUG: Discarding entity " << _entityCount << ", out of range"
-					  << std::endl;
-			return false;
-		}
-	}
-	return true;
+bool NodeImporter::checkEntityClass(const scene::INodePtr& entity) {
+	// Obtain list of entityclasses to skip
+	static xml::NodeList skipLst = 
+		GlobalRegistry().findXPath("debug/mapdoom3//discardEntityClass");
+
+	// Obtain the entity class of this node
+	IEntityClassConstPtr entityClass = 
+			Node_getEntity(entity)->getEntityClass();
+
+	// Skip this entity class if it is in the list
+	for (xml::NodeList::const_iterator i = skipLst.begin();
+		 i != skipLst.end();
+		 ++i)
+	{
+		if (i->getAttributeValue("value") == entityClass->getName()) {
+			std::cout << "DEBUG: discarding entity class " 
+					  << entityClass->getName() << std::endl;
+			return false;
+		}
+	}
+
+	return true;
 }
 
+bool NodeImporter::checkEntityNum() {
+	// Entity range XPath
+	static xml::NodeList entityRange = 
+					GlobalRegistry().findXPath("debug/mapdoom3/entityRange");
+	static xml::NodeList::iterator i = entityRange.begin();
+	
+	// Test the entity number is in the range
+	if (i != entityRange.end()) {
+		static std::size_t lower = strToSizet(i->getAttributeValue("start"));
+		static std::size_t upper = strToSizet(i->getAttributeValue("end"));
+	
+		if (_entityCount < lower || _entityCount > upper) {
+			std::cout << "DEBUG: Discarding entity " << _entityCount << ", out of range"
+					  << std::endl;
+			return false;
+		}
+	}
+	return true;
+}
+
 void NodeImporter::insertEntity(const scene::INodePtr& entity) {
-	// Abort if any of the tests fail
-	if (_debug && (!checkEntityClass(entity) || !checkEntityNum())) {
-		return;
-	}
-	
-	// Insert the node into the given root
+	// Abort if any of the tests fail
+	if (_debug && (!checkEntityClass(entity) || !checkEntityNum())) {
+		return;
+	}
+	
+	// Insert the node into the given root
 	_root->addChildNode(entity);
 }
 
Index: plugins/model/PicoModelLoader.cpp
===================================================================
--- plugins/model/PicoModelLoader.cpp	(revision 3603)
+++ plugins/model/PicoModelLoader.cpp	(working copy)
@@ -17,128 +17,128 @@
 
 namespace model {
 
-namespace {
-	// name may be absolute or relative
-	inline std::string rootPath(const std::string& name) {
-		return GlobalFileSystem().findRoot(
-			path_is_absolute(name.c_str()) ? name : GlobalFileSystem().findFile(name)
-		);
-	}
-
-	size_t picoInputStreamReam(void* inputStream, unsigned char* buffer, size_t length) {
-		return reinterpret_cast<InputStream*>(inputStream)->read(buffer, length);
-	}
+namespace {
+	// name may be absolute or relative
+	inline std::string rootPath(const std::string& name) {
+		return GlobalFileSystem().findRoot(
+			path_is_absolute(name.c_str()) ? name : GlobalFileSystem().findFile(name)
+		);
+	}
+
+	size_t picoInputStreamReam(void* inputStream, unsigned char* buffer, size_t length) {
+		return reinterpret_cast<InputStream*>(inputStream)->read(buffer, length);
+	}
 } // namespace
 
-PicoModelLoader::PicoModelLoader(const picoModule_t* module, const std::string& extension) : 
-	_module(module),
-	_extension(extension),
-	_moduleName("ModelLoader" + extension) // e.g. ModelLoaderASE
-{}
-
-// Returns a new ModelNode for the given model name
-scene::INodePtr PicoModelLoader::loadModel(const std::string& modelName) {
-	// Initialise the paths, this is all needed for realisation
-	std::string path = rootPath(modelName);
-	std::string name = os::getRelativePath(modelName, path);
-
-	if (path.empty()) {
-		// Empty path => empty model
-		return scene::INodePtr();
-	}
-
-	// Try to load the model from the given VFS path
-	IModelPtr model = GlobalModelCache().getModel(name);
-
-	if (model == NULL) {
-		globalErrorStream() << "PicoModelLoader: Could not load model << " << modelName.c_str() << "\n";
-		return scene::INodePtr();
-	}
-
-	// The cached model should be an MD5Model, otherwise we're in the wrong movie
-	RenderablePicoModelPtr picoModel = 
-		boost::dynamic_pointer_cast<RenderablePicoModel>(model);
-
-	if (picoModel != NULL) {
-		// Load was successful, construct a modelnode using this resource
-		PicoModelNodePtr modelNode(new PicoModelNode(picoModel));
-		modelNode->setSelf(modelNode);
-
-		return modelNode;
-	}
-	else {
-		globalErrorStream() << "PicoModelLoader: Cached model is not a PicoModel?\n";
-	}
-
-	return scene::INodePtr();
-}
-
-// Load the given model from the VFS path
-IModelPtr PicoModelLoader::loadModelFromPath(const std::string& name) {
-	// Open an ArchiveFile to load
-	ArchiveFilePtr file = GlobalFileSystem().openFile(name);
-
-	if (file == NULL) {
-		globalErrorStream() << "Failed to load model " << name.c_str() << "\n";
-		return IModelPtr();
-	}
-
-	// Determine the file extension (ASE or LWO) to pass down to the PicoModel
-	std::string fName = file->getName();
-	boost::algorithm::to_lower(fName);
-	std::string fExt = fName.substr(fName.size() - 3, 3);
-
-	picoModel_t* model = PicoModuleLoadModelStream(
-		_module, 
-		&file->getInputStream(), 
-		picoInputStreamReam, 
-		file->size(), 
-		0
-	);
-	
-	// greebo: Check if the model load was successful
-	if (model == NULL || model->numSurfaces == 0) {
-		// Model is either NULL or has no surfaces, this must've failed
-		return IModelPtr();
-	}
-
-	RenderablePicoModelPtr modelObj(
-		new RenderablePicoModel(model, fExt)
-	);
-	// Set the filename
-	modelObj->setFilename(os::getFilename(file->getName()));
-	modelObj->setModelPath(name);
-	
-	PicoFreeModel(model);
-	return modelObj;
-}
-
-// RegisterableModule implementation
-const std::string& PicoModelLoader::getName() const {
-	return _moduleName; // e.g. ModelLoaderASE
-}
-
-const StringSet& PicoModelLoader::getDependencies() const {
-	static StringSet _dependencies;
-
-	if (_dependencies.empty()) {
-		_dependencies.insert(MODULE_VIRTUALFILESYSTEM);
-		_dependencies.insert(MODULE_SHADERCACHE);
-		_dependencies.insert(MODULE_FILETYPES);
-	}
-
-	return _dependencies;
-}
-
-void PicoModelLoader::initialiseModule(const ApplicationContext& ctx) {
-	globalOutputStream() << "PicoModelLoader: " << getName().c_str() << " initialised.\n"; 
-	std::string filter("*." + boost::to_lower_copy(_extension));
-	
-	// Register the model file extension in the FileTypRegistry
-	GlobalFiletypes().addType(
-		"model", getName(), 
-    	FileTypePattern(_module->displayName, filter.c_str())
-    );
+PicoModelLoader::PicoModelLoader(const picoModule_t* module, const std::string& extension) : 
+	_module(module),
+	_extension(extension),
+	_moduleName("ModelLoader" + extension) // e.g. ModelLoaderASE
+{}
+
+// Returns a new ModelNode for the given model name
+scene::INodePtr PicoModelLoader::loadModel(const std::string& modelName) {
+	// Initialise the paths, this is all needed for realisation
+	std::string path = rootPath(modelName);
+	std::string name = os::getRelativePath(modelName, path);
+
+	if (path.empty()) {
+		// Empty path => empty model
+		return scene::INodePtr();
+	}
+
+	// Try to load the model from the given VFS path
+	IModelPtr model = GlobalModelCache().getModel(name);
+
+	if (model == NULL) {
+		globalErrorStream() << "PicoModelLoader: Could not load model << " << modelName.c_str() << "\n";
+		return scene::INodePtr();
+	}
+
+	// The cached model should be an MD5Model, otherwise we're in the wrong movie
+	RenderablePicoModelPtr picoModel = 
+		boost::dynamic_pointer_cast<RenderablePicoModel>(model);
+
+	if (picoModel != NULL) {
+		// Load was successful, construct a modelnode using this resource
+		PicoModelNodePtr modelNode(new PicoModelNode(picoModel));
+		modelNode->setSelf(modelNode);
+
+		return modelNode;
+	}
+	else {
+		globalErrorStream() << "PicoModelLoader: Cached model is not a PicoModel?\n";
+	}
+
+	return scene::INodePtr();
 }
 
+// Load the given model from the VFS path
+IModelPtr PicoModelLoader::loadModelFromPath(const std::string& name) {
+	// Open an ArchiveFile to load
+	ArchiveFilePtr file = GlobalFileSystem().openFile(name);
+
+	if (file == NULL) {
+		globalErrorStream() << "Failed to load model " << name.c_str() << "\n";
+		return IModelPtr();
+	}
+
+	// Determine the file extension (ASE or LWO) to pass down to the PicoModel
+	std::string fName = file->getName();
+	boost::algorithm::to_lower(fName);
+	std::string fExt = fName.substr(fName.size() - 3, 3);
+
+	picoModel_t* model = PicoModuleLoadModelStream(
+		_module, 
+		&file->getInputStream(), 
+		picoInputStreamReam, 
+		file->size(), 
+		0
+	);
+	
+	// greebo: Check if the model load was successful
+	if (model == NULL || model->numSurfaces == 0) {
+		// Model is either NULL or has no surfaces, this must've failed
+		return IModelPtr();
+	}
+
+	RenderablePicoModelPtr modelObj(
+		new RenderablePicoModel(model, fExt)
+	);
+	// Set the filename
+	modelObj->setFilename(os::getFilename(file->getName()));
+	modelObj->setModelPath(name);
+	
+	PicoFreeModel(model);
+	return modelObj;
+}
+
+// RegisterableModule implementation
+const std::string& PicoModelLoader::getName() const {
+	return _moduleName; // e.g. ModelLoaderASE
+}
+
+const StringSet& PicoModelLoader::getDependencies() const {
+	static StringSet _dependencies;
+
+	if (_dependencies.empty()) {
+		_dependencies.insert(MODULE_VIRTUALFILESYSTEM);
+		_dependencies.insert(MODULE_SHADERCACHE);
+		_dependencies.insert(MODULE_FILETYPES);
+	}
+
+	return _dependencies;
+}
+
+void PicoModelLoader::initialiseModule(const ApplicationContext& ctx) {
+	globalOutputStream() << "PicoModelLoader: " << getName().c_str() << " initialised.\n"; 
+	std::string filter("*." + boost::to_lower_copy(_extension));
+	
+	// Register the model file extension in the FileTypRegistry
+	GlobalFiletypes().addType(
+		"model", getName(), 
+    	FileTypePattern(_module->displayName, filter.c_str())
+    );
+}
+
 } // namespace model
Index: plugins/model/PicoModelLoader.h
===================================================================
--- plugins/model/PicoModelLoader.h	(revision 3603)
+++ plugins/model/PicoModelLoader.h	(working copy)
@@ -7,30 +7,30 @@
 
 namespace model {
 
-class PicoModelLoader : 
-	public ModelLoader
-{
-	const picoModule_t* _module;
-	
-	// Supported file extension in UPPERCASE (ASE, LWO, whatever)
-	std::string _extension;
-	
-	// The resulting name of the module (ModelLoaderASE, for instance)
-	std::string _moduleName;
-public:
-	PicoModelLoader(const picoModule_t* module, const std::string& extension);
-
-	// Returns a new ModelNode for the given model name
-	virtual scene::INodePtr loadModel(const std::string& modelName);
-  
-  	// Load the given model from the VFS path
-	IModelPtr loadModelFromPath(const std::string& name);
-
-	// RegisterableModule implementation
-  	virtual const std::string& getName() const;
-  	virtual const StringSet& getDependencies() const;
-  	virtual void initialiseModule(const ApplicationContext& ctx);
-};
+class PicoModelLoader : 
+	public ModelLoader
+{
+	const picoModule_t* _module;
+	
+	// Supported file extension in UPPERCASE (ASE, LWO, whatever)
+	std::string _extension;
+	
+	// The resulting name of the module (ModelLoaderASE, for instance)
+	std::string _moduleName;
+public:
+	PicoModelLoader(const picoModule_t* module, const std::string& extension);
+
+	// Returns a new ModelNode for the given model name
+	virtual scene::INodePtr loadModel(const std::string& modelName);
+  
+  	// Load the given model from the VFS path
+	IModelPtr loadModelFromPath(const std::string& name);
+
+	// RegisterableModule implementation
+  	virtual const std::string& getName() const;
+  	virtual const StringSet& getDependencies() const;
+  	virtual void initialiseModule(const ApplicationContext& ctx);
+};
 typedef boost::shared_ptr<PicoModelLoader> PicoModelLoaderPtr;
 
 } // namespace model
Index: plugins/model/PicoModelNode.cpp
===================================================================
--- plugins/model/PicoModelNode.cpp	(revision 3603)
+++ plugins/model/PicoModelNode.cpp	(working copy)
@@ -8,170 +8,170 @@
 
 namespace model {
 
-PicoModelNode::PicoModelNode(const RenderablePicoModelPtr& picoModel) :  
-	_picoModel(picoModel),
-	_name(picoModel->getFilename()),
-	_lightList(GlobalShaderCache().attach(*this))
-{
-	Node::setTransformChangedCallback(LightsChangedCaller(*this));
-
-	// Update the skin
-	skinChanged("");
-}
-
-PicoModelNode::~PicoModelNode() {
-	GlobalShaderCache().detach(*this);
-}
-
-const IModel& PicoModelNode::getIModel() const {
-	return *_picoModel;
-}
-
-const AABB& PicoModelNode::localAABB() const {
-	return _picoModel->localAABB();
-}
-
-VolumeIntersectionValue PicoModelNode::intersectVolume(
-	const VolumeTest& test, const Matrix4& localToWorld) const
-{
-	return _picoModel->intersectVolume(test, localToWorld);
-}
-
+PicoModelNode::PicoModelNode(const RenderablePicoModelPtr& picoModel) :  
+	_picoModel(picoModel),
+	_name(picoModel->getFilename()),
+	_lightList(GlobalShaderCache().attach(*this))
+{
+	Node::setTransformChangedCallback(LightsChangedCaller(*this));
+
+	// Update the skin
+	skinChanged("");
+}
+
+PicoModelNode::~PicoModelNode() {
+	GlobalShaderCache().detach(*this);
+}
+
+const IModel& PicoModelNode::getIModel() const {
+	return *_picoModel;
+}
+
+const AABB& PicoModelNode::localAABB() const {
+	return _picoModel->localAABB();
+}
+
+VolumeIntersectionValue PicoModelNode::intersectVolume(
+	const VolumeTest& test, const Matrix4& localToWorld) const
+{
+	return _picoModel->intersectVolume(test, localToWorld);
+}
+
 void PicoModelNode::instantiate(const scene::Path& path) {
 	Node::instantiate(path);
 }
 
-void PicoModelNode::uninstantiate(const scene::Path& path) {
-	Node::uninstantiate(path);
-}
-
-// SelectionTestable implementation
-void PicoModelNode::testSelect(Selector& selector, SelectionTest& test) {
-	_picoModel->testSelect(selector, test, localToWorld());
-}
-
-std::string PicoModelNode::name() const {
-  	return _picoModel->getFilename();
-}
-  
-const RenderablePicoModelPtr& PicoModelNode::getModel() const {
-	return _picoModel;
-}
-
-void PicoModelNode::setModel(const RenderablePicoModelPtr& model) {
-	_picoModel = model;
-}
-
-// LightCullable test function
-bool PicoModelNode::testLight(const RendererLight& light) const {
-	return light.testAABB(worldAABB());
-}
-	
-// Add a light to this model instance
-void PicoModelNode::insertLight(const RendererLight& light) {
-	// Calculate transform from the superclass
-	const Matrix4& l2w = localToWorld();
-	
-	// If the light's AABB intersects the oriented AABB of this model instance,
-	// add the light to our light list
-	if (light.testAABB(aabb_for_oriented_aabb(_picoModel->localAABB(),
-											  l2w)))
-	{
-		_lights.addLight(light);
-	}
-}
-	
-// Clear all lights from this model instance
-void PicoModelNode::clearLights() {
-	_lights.clear();
+void PicoModelNode::uninstantiate(const scene::Path& path) {
+	Node::uninstantiate(path);
 }
 
-void PicoModelNode::renderSolid(Renderer& renderer, const VolumeTest& volume) const {
-	_lightList.evaluateLights();
-
-	submitRenderables(renderer, volume, localToWorld());
-}
-
-void PicoModelNode::renderWireframe(Renderer& renderer, const VolumeTest& volume) const {
-	renderSolid(renderer, volume);
+// SelectionTestable implementation
+void PicoModelNode::testSelect(Selector& selector, SelectionTest& test) {
+	_picoModel->testSelect(selector, test, localToWorld());
 }
 
-// Renderable submission
-void PicoModelNode::submitRenderables(Renderer& renderer, 
-									  const VolumeTest& volume, 
-									  const Matrix4& localToWorld) const
-{
-	// Test the model's intersection volume, if it intersects pass on the 
-	// render call
-	if (_picoModel->intersectVolume(volume, localToWorld) != c_volumeOutside) {
-		// Submit the lights
-		renderer.setLights(_lights);
-	
-		// If the surface cache is populated, then use this instead of the
-		// original model in order to get the skinned textures
-		if (!_mappedSurfs.empty()) {
-			for (MappedSurfaces::const_iterator i = _mappedSurfs.begin();
-				 i != _mappedSurfs.end();
-				 ++i)
-			{
-				// Submit the surface and shader to the renderer, checking first
-				// to make sure the texture is not filtered
-				IShaderPtr surfaceShader = i->second->getIShader();
-				if (surfaceShader->isVisible()) { 
-					renderer.SetState(i->second, Renderer::eFullMaterials);
-					renderer.addRenderable(*i->first, localToWorld);
-				}
-			}			
-		}
-		else {
-			// Submit the model's geometry
-			_picoModel->submitRenderables(renderer, localToWorld);
-		}
-	}
+std::string PicoModelNode::name() const {
+  	return _picoModel->getFilename();
 }
+  
+const RenderablePicoModelPtr& PicoModelNode::getModel() const {
+	return _picoModel;
+}
 
-// Skin changed notify
-void PicoModelNode::skinChanged(const std::string& newSkinName) {
-
-	// Clear all the surface mappings before doing anything
-	_mappedSurfs.clear();
-
-	// The new skin name is stored locally
-	_skin = newSkinName;
-
-	// greebo: Acquire the ModelSkin reference from the SkinCache
-	// Note: This always returns a valid reference
-	ModelSkin& skin = GlobalModelSkinCache().capture(_skin);
-
-	// Otherwise get the list of RenderablePicoSurfaces from the model and
-	// determine a texture remapping for each one
-	const SurfaceList& surfs = _picoModel->getSurfaces();
-	for (SurfaceList::const_iterator i = surfs.begin();
-		 i != surfs.end();
-		 ++i)
-	{
-		// Get the surface's material and test the skin for a remap
-		std::string material = (*i)->getActiveMaterial();
-		std::string mapped = skin.getRemap(material);
-		if (mapped.empty())
-			mapped = material; // use original material for remap
-		
-		// Add the surface and the mapped shader to our surface cache
-		_mappedSurfs.push_back(
-			std::make_pair(
-				*i,
-				GlobalShaderCache().capture(mapped)
-			)
-		);
-	}
-	
-	// Refresh the scene
-	GlobalSceneGraph().sceneChanged();
-}
-
-// Returns the name of the currently active skin
-std::string PicoModelNode::getSkin() const {
-	return _skin;
+void PicoModelNode::setModel(const RenderablePicoModelPtr& model) {
+	_picoModel = model;
 }
 
+// LightCullable test function
+bool PicoModelNode::testLight(const RendererLight& light) const {
+	return light.testAABB(worldAABB());
+}
+	
+// Add a light to this model instance
+void PicoModelNode::insertLight(const RendererLight& light) {
+	// Calculate transform from the superclass
+	const Matrix4& l2w = localToWorld();
+	
+	// If the light's AABB intersects the oriented AABB of this model instance,
+	// add the light to our light list
+	if (light.testAABB(aabb_for_oriented_aabb(_picoModel->localAABB(),
+											  l2w)))
+	{
+		_lights.addLight(light);
+	}
+}
+	
+// Clear all lights from this model instance
+void PicoModelNode::clearLights() {
+	_lights.clear();
+}
+
+void PicoModelNode::renderSolid(Renderer& renderer, const VolumeTest& volume) const {
+	_lightList.evaluateLights();
+
+	submitRenderables(renderer, volume, localToWorld());
+}
+
+void PicoModelNode::renderWireframe(Renderer& renderer, const VolumeTest& volume) const {
+	renderSolid(renderer, volume);
+}
+
+// Renderable submission
+void PicoModelNode::submitRenderables(Renderer& renderer, 
+									  const VolumeTest& volume, 
+									  const Matrix4& localToWorld) const
+{
+	// Test the model's intersection volume, if it intersects pass on the 
+	// render call
+	if (_picoModel->intersectVolume(volume, localToWorld) != c_volumeOutside) {
+		// Submit the lights
+		renderer.setLights(_lights);
+	
+		// If the surface cache is populated, then use this instead of the
+		// original model in order to get the skinned textures
+		if (!_mappedSurfs.empty()) {
+			for (MappedSurfaces::const_iterator i = _mappedSurfs.begin();
+				 i != _mappedSurfs.end();
+				 ++i)
+			{
+				// Submit the surface and shader to the renderer, checking first
+				// to make sure the texture is not filtered
+				IShaderPtr surfaceShader = i->second->getIShader();
+				if (surfaceShader->isVisible()) { 
+					renderer.SetState(i->second, Renderer::eFullMaterials);
+					renderer.addRenderable(*i->first, localToWorld);
+				}
+			}			
+		}
+		else {
+			// Submit the model's geometry
+			_picoModel->submitRenderables(renderer, localToWorld);
+		}
+	}
+}
+
+// Skin changed notify
+void PicoModelNode::skinChanged(const std::string& newSkinName) {
+
+	// Clear all the surface mappings before doing anything
+	_mappedSurfs.clear();
+
+	// The new skin name is stored locally
+	_skin = newSkinName;
+
+	// greebo: Acquire the ModelSkin reference from the SkinCache
+	// Note: This always returns a valid reference
+	ModelSkin& skin = GlobalModelSkinCache().capture(_skin);
+
+	// Otherwise get the list of RenderablePicoSurfaces from the model and
+	// determine a texture remapping for each one
+	const SurfaceList& surfs = _picoModel->getSurfaces();
+	for (SurfaceList::const_iterator i = surfs.begin();
+		 i != surfs.end();
+		 ++i)
+	{
+		// Get the surface's material and test the skin for a remap
+		std::string material = (*i)->getActiveMaterial();
+		std::string mapped = skin.getRemap(material);
+		if (mapped.empty())
+			mapped = material; // use original material for remap
+		
+		// Add the surface and the mapped shader to our surface cache
+		_mappedSurfs.push_back(
+			std::make_pair(
+				*i,
+				GlobalShaderCache().capture(mapped)
+			)
+		);
+	}
+	
+	// Refresh the scene
+	GlobalSceneGraph().sceneChanged();
+}
+
+// Returns the name of the currently active skin
+std::string PicoModelNode::getSkin() const {
+	return _skin;
+}
+
 } // namespace model
Index: plugins/model/PicoModelNode.h
===================================================================
--- plugins/model/PicoModelNode.h	(revision 3603)
+++ plugins/model/PicoModelNode.h	(working copy)
@@ -12,97 +12,97 @@
 
 namespace model {
 
-class PicoModelNode : 
-	public scene::Node, 
-	public ModelNode,
-	public Nameable,
-	public SelectionTestable,
-	public LightCullable,
-	public Renderable,
-	public Cullable,
-	public Bounded,
-	public SkinnedModel
-{
-	// The actual model
-	RenderablePicoModelPtr _picoModel;
-
-	std::string _name;
-
-	// Vector of RendererLight references which illuminate this instance, set
-	// with addLight() and clearLights()
-	VectorLightList _lights;
-
-	// The light list from the shader cache when we attach
-	const LightList& _lightList;
-
-	// Cache of RenderablePicoSurfaces along with their shaders. This is 
-	// necessary to allow each Instance to have its own skin.
-	typedef std::pair< boost::shared_ptr<RenderablePicoSurface>,
-					   ShaderPtr> MappedSurface;
-	typedef std::vector<MappedSurface> MappedSurfaces;
-	MappedSurfaces _mappedSurfs;
-
-	// The name of this model's skin
-	std::string _skin;
-
-public:
-	/** Construct a PicoModelNode with a reference to the loaded picoModel.
-	 */
-	PicoModelNode(const RenderablePicoModelPtr& picoModel);
-
-	virtual ~PicoModelNode();
-
-	// ModelNode implementation
-	virtual const IModel& getIModel() const;
-
-	// SkinnedModel implementation
-	// Skin changed notify
-	void skinChanged(const std::string& newSkinName);
-	// Returns the name of the currently active skin
-	std::string getSkin() const;
-
-	// Bounded implementation
-	virtual const AABB& localAABB() const;
-
-	// Lights changed function
-	void lightsChanged() {
-		_lightList.lightsChanged();
-	}
-	typedef MemberCaller<PicoModelNode, &PicoModelNode::lightsChanged> LightsChangedCaller;
-
+class PicoModelNode : 
+	public scene::Node, 
+	public ModelNode,
+	public Nameable,
+	public SelectionTestable,
+	public LightCullable,
+	public Renderable,
+	public Cullable,
+	public Bounded,
+	public SkinnedModel
+{
+	// The actual model
+	RenderablePicoModelPtr _picoModel;
+
+	std::string _name;
+
+	// Vector of RendererLight references which illuminate this instance, set
+	// with addLight() and clearLights()
+	VectorLightList _lights;
+
+	// The light list from the shader cache when we attach
+	const LightList& _lightList;
+
+	// Cache of RenderablePicoSurfaces along with their shaders. This is 
+	// necessary to allow each Instance to have its own skin.
+	typedef std::pair< boost::shared_ptr<RenderablePicoSurface>,
+					   ShaderPtr> MappedSurface;
+	typedef std::vector<MappedSurface> MappedSurfaces;
+	MappedSurfaces _mappedSurfs;
+
+	// The name of this model's skin
+	std::string _skin;
+
+public:
+	/** Construct a PicoModelNode with a reference to the loaded picoModel.
+	 */
+	PicoModelNode(const RenderablePicoModelPtr& picoModel);
+
+	virtual ~PicoModelNode();
+
+	// ModelNode implementation
+	virtual const IModel& getIModel() const;
+
+	// SkinnedModel implementation
+	// Skin changed notify
+	void skinChanged(const std::string& newSkinName);
+	// Returns the name of the currently active skin
+	std::string getSkin() const;
+
+	// Bounded implementation
+	virtual const AABB& localAABB() const;
+
+	// Lights changed function
+	void lightsChanged() {
+		_lightList.lightsChanged();
+	}
+	typedef MemberCaller<PicoModelNode, &PicoModelNode::lightsChanged> LightsChangedCaller;
+
 	// scene::Instantiable implementation
 	virtual void instantiate(const scene::Path& path);
-	virtual void uninstantiate(const scene::Path& path);
-
-	// SelectionTestable implementation
-	void testSelect(Selector& selector, SelectionTest& test);
-
-	// Cullable implementation
-	virtual VolumeIntersectionValue intersectVolume(
-		const VolumeTest& test, const Matrix4& localToWorld) const;
-
-	virtual std::string name() const;
-  
-	const RenderablePicoModelPtr& getModel() const;
-	void setModel(const RenderablePicoModelPtr& model);
-
-	// LightCullable test function
-	bool testLight(const RendererLight& light) const;
-	// Add a light to this model instance
-	void insertLight(const RendererLight& light);
-	// Clear all lights from this model instance
-	void clearLights();
-
-	// Renderable implementation	
-  	void renderSolid(Renderer& renderer, const VolumeTest& volume) const;
-	void renderWireframe(Renderer& renderer, const VolumeTest& volume) const;
-
-private:
-	// Instance render function 
-	void submitRenderables(Renderer& renderer, 
-						   const VolumeTest& volume, 
-						   const Matrix4& localToWorld) const;
-};
+	virtual void uninstantiate(const scene::Path& path);
+
+	// SelectionTestable implementation
+	void testSelect(Selector& selector, SelectionTest& test);
+
+	// Cullable implementation
+	virtual VolumeIntersectionValue intersectVolume(
+		const VolumeTest& test, const Matrix4& localToWorld) const;
+
+	virtual std::string name() const;
+  
+	const RenderablePicoModelPtr& getModel() const;
+	void setModel(const RenderablePicoModelPtr& model);
+
+	// LightCullable test function
+	bool testLight(const RendererLight& light) const;
+	// Add a light to this model instance
+	void insertLight(const RendererLight& light);
+	// Clear all lights from this model instance
+	void clearLights();
+
+	// Renderable implementation	
+  	void renderSolid(Renderer& renderer, const VolumeTest& volume) const;
+	void renderWireframe(Renderer& renderer, const VolumeTest& volume) const;
+
+private:
+	// Instance render function 
+	void submitRenderables(Renderer& renderer, 
+						   const VolumeTest& volume, 
+						   const Matrix4& localToWorld) const;
+};
 typedef boost::shared_ptr<PicoModelNode> PicoModelNodePtr;
 
 } // namespace model
Index: plugins/shaders/textures/GLTextureManager.cpp
===================================================================
--- plugins/shaders/textures/GLTextureManager.cpp	(revision 3603)
+++ plugins/shaders/textures/GLTextureManager.cpp	(working copy)
@@ -12,6 +12,7 @@
 	const int MAX_TEXTURE_QUALITY = 3;
 	
 	const std::string SHADER_NOT_FOUND = "notex.bmp";
+	const std::string SHADER_IMAGE_MISSING = "shadernotex.bmp";
 }
 
 namespace shaders {
@@ -99,11 +100,11 @@
 
 	// Construct the texture if necessary
 	if (!_shaderNotFound) {
-		_shaderNotFound = loadStandardTexture(SHADER_NOT_FOUND);
+		_shaderNotFound = loadStandardTexture(SHADER_IMAGE_MISSING);
 	}
 
 	// Return the texture
-	return _shaderNotFound;				  
+	return _shaderNotFound;
 }
 
 TexturePtr GLTextureManager::loadStandardTexture(const std::string& filename) {
Index: plugins/vfspk3/Doom3FileSystem.cpp
===================================================================
--- plugins/vfspk3/Doom3FileSystem.cpp	(revision 3603)
+++ plugins/vfspk3/Doom3FileSystem.cpp	(working copy)
@@ -110,7 +110,7 @@
 	globalOutputStream() << "[vfs] searched directory: " << path.c_str() << "\n";
 	
 	// Get the ArchiveLoader and try to load each file
-	ArchiveLoader& archiveModule = GlobalArchive("PK4");  
+	ArchiveLoader& archiveModule = GlobalArchive("PK3");  
 	
 	// add the entries to the vfs
 	for (SortedFilenames::iterator i = filenameList.begin(); i != filenameList.end(); ++i) {
@@ -285,7 +285,7 @@
 	static StringSet _dependencies;
 
 	if (_dependencies.empty()) {
-		_dependencies.insert("ArchivePK4");
+		_dependencies.insert("ArchivePK3");
 		_dependencies.insert(MODULE_GAMEMANAGER);
 	}
 
Index: radiant/brush/BrushNode.cpp
===================================================================
--- radiant/brush/BrushNode.cpp	(revision 3603)
+++ radiant/brush/BrushNode.cpp	(working copy)
@@ -1,97 +1,97 @@
-#include "BrushNode.h"
-
-#include "ifilter.h"
+#include "BrushNode.h"
+
+#include "ifilter.h"
 #include "iradiant.h"
-#include "icounter.h"
-#include "math/frustum.h"
-
-// Constructor
-BrushNode::BrushNode() :
-	BrushTokenImporter(m_brush),
-	BrushTokenExporter(m_brush),
-	TransformModifier(Brush::TransformChangedCaller(m_brush), ApplyTransformCaller(*this)),
-	m_brush(*this, EvaluateTransformCaller(*this), Node::BoundsChangedCaller(*this)),
-	_selectable(SelectedChangedCaller(*this)),
+#include "icounter.h"
+#include "math/frustum.h"
+
+// Constructor
+BrushNode::BrushNode() :
+	BrushTokenImporter(m_brush),
+	BrushTokenExporter(m_brush),
+	TransformModifier(Brush::TransformChangedCaller(m_brush), ApplyTransformCaller(*this)),
+	m_brush(*this, EvaluateTransformCaller(*this), Node::BoundsChangedCaller(*this)),
+	_selectable(SelectedChangedCaller(*this)),
 	m_render_selected(GL_POINTS),
 	m_render_faces_wireframe(m_faceCentroidPointsCulled, GL_POINTS),
-	m_viewChanged(false)
-{
-	m_brush.attach(*this); // BrushObserver
-	m_lightList = &GlobalShaderCache().attach(*this);
-
+	m_viewChanged(false)
+{
+	m_brush.attach(*this); // BrushObserver
+	m_lightList = &GlobalShaderCache().attach(*this);
+
 	m_brush.m_lightsChanged = LightsChangedCaller(*this);
 
-	Node::setTransformChangedCallback(LightsChangedCaller(*this));
-}
-
-// Copy Constructor
-BrushNode::BrushNode(const BrushNode& other) :
-	scene::Node(other),
-	scene::Cloneable(other),
-	Nameable(other),
-	Snappable(other),
-	TransformNode(other),
-	BrushDoom3(other),
-	BrushTokenImporter(m_brush),
-	BrushTokenExporter(m_brush),
-	IBrushNode(other),
-	Selectable(other),
-	BrushObserver(other),
-	SelectionTestable(other),
-	ComponentSelectionTestable(other),
-	ComponentEditable(other),
-	ComponentSnappable(other),
-	PlaneSelectable(other),
-	LightCullable(other),
-	Renderable(other),
-	Cullable(other),
-	Bounded(other),
-	TransformModifier(Brush::TransformChangedCaller(m_brush), ApplyTransformCaller(*this)),
-	m_brush(other.m_brush, *this, EvaluateTransformCaller(*this), Node::BoundsChangedCaller(*this)),
-	_selectable(SelectedChangedCaller(*this)),
+	Node::setTransformChangedCallback(LightsChangedCaller(*this));
+}
+
+// Copy Constructor
+BrushNode::BrushNode(const BrushNode& other) :
+	scene::Node(other),
+	scene::Cloneable(other),
+	Nameable(other),
+	Snappable(other),
+	TransformNode(other),
+	BrushDoom3(other),
+	BrushTokenImporter(m_brush),
+	BrushTokenExporter(m_brush),
+	IBrushNode(other),
+	Selectable(other),
+	BrushObserver(other),
+	SelectionTestable(other),
+	ComponentSelectionTestable(other),
+	ComponentEditable(other),
+	ComponentSnappable(other),
+	PlaneSelectable(other),
+	LightCullable(other),
+	Renderable(other),
+	Cullable(other),
+	Bounded(other),
+	TransformModifier(Brush::TransformChangedCaller(m_brush), ApplyTransformCaller(*this)),
+	m_brush(other.m_brush, *this, EvaluateTransformCaller(*this), Node::BoundsChangedCaller(*this)),
+	_selectable(SelectedChangedCaller(*this)),
 	m_render_selected(GL_POINTS),
 	m_render_faces_wireframe(m_faceCentroidPointsCulled, GL_POINTS),
-	m_viewChanged(false)
-{
-	m_brush.attach(*this); // BrushObserver
-	m_lightList = &GlobalShaderCache().attach(*this);
-}
-
-BrushNode::~BrushNode() {
-	GlobalShaderCache().detach(*this);
-	m_brush.detach(*this); // BrushObserver
-}
-
+	m_viewChanged(false)
+{
+	m_brush.attach(*this); // BrushObserver
+	m_lightList = &GlobalShaderCache().attach(*this);
+}
+
+BrushNode::~BrushNode() {
+	GlobalShaderCache().detach(*this);
+	m_brush.detach(*this); // BrushObserver
+}
+
 VolumeIntersectionValue BrushNode::intersectVolume(
 	const VolumeTest& test, const Matrix4& localToWorld) const
 {
 	return m_brush.intersectVolume(test, localToWorld);
-}
-
+}
+
 void BrushNode::lightsChanged() {
 	m_lightList->lightsChanged();
-}
-
+}
+
 const AABB& BrushNode::localAABB() const {
 	return m_brush.localAABB();
-}
-
-// Snappable implementation
-void BrushNode::snapto(float snap) {
-	m_brush.snapto(snap);
-}
-
+}
+
+// Snappable implementation
+void BrushNode::snapto(float snap) {
+	m_brush.snapto(snap);
+}
+
 void BrushNode::snapComponents(float snap) {
 	for (FaceInstances::iterator i = m_faceInstances.begin(); i != m_faceInstances.end(); ++i) {
 		i->snapComponents(snap);
 	}
-}
-
-// TransformNode implementation
-const Matrix4& BrushNode::localToParent() const {
-	return m_brush.localToParent();
-}
-
+}
+
+// TransformNode implementation
+const Matrix4& BrushNode::localToParent() const {
+	return m_brush.localToParent();
+}
+
 bool BrushNode::isSelected() const {
 	return _selectable.isSelected();
 }
@@ -130,8 +130,8 @@
 				break;
 		} // switch
 	}
-}
-
+}
+
 void BrushNode::testSelect(Selector& selector, SelectionTest& test) {
 	test.BeginMesh(localToWorld());
 
@@ -145,8 +145,8 @@
 	if (best.valid()) {
 		selector.addIntersection(best);
 	}
-}
-
+}
+
 bool BrushNode::isSelectedComponents() const {
 	for (FaceInstances::const_iterator i = m_faceInstances.begin(); i != m_faceInstances.end(); ++i) {
 		if (i->selectedComponents()) {
@@ -194,8 +194,8 @@
 		default:
 			break;
 	}
-}
-
+}
+
 const AABB& BrushNode::getSelectedComponentsBounds() const {
 	m_aabb_component = AABB();
 
@@ -204,8 +204,8 @@
 	}
 
 	return m_aabb_component;
-}
-
+}
+
 void BrushNode::selectPlanes(Selector& selector, SelectionTest& test, const PlaneCallback& selectedPlaneCallback) {
 	test.BeginMesh(localToWorld());
 
@@ -225,55 +225,55 @@
 	for (FaceInstances::iterator i = m_faceInstances.begin(); i != m_faceInstances.end(); ++i) {
 		i->selectReversedPlane(selector, selectedPlanes);
 	}
-}
-
+}
+
 void BrushNode::selectedChanged(const Selectable& selectable) {
 	GlobalSelectionSystem().onSelectedChanged(Node::getSelf(), selectable);
 
 	// TODO? instance->selectedChanged();
-}
-
+}
+
 void BrushNode::selectedChangedComponent(const Selectable& selectable) {
 	GlobalSelectionSystem().onComponentSelection(Node::getSelf(), selectable);
-}
-
-// IBrushNode implementation
-Brush& BrushNode::getBrush() {
-	return m_brush;
-}
-
-void BrushNode::translateDoom3Brush(const Vector3& translation) {
-	m_brush.translateDoom3Brush(translation);
-}
-
-scene::INodePtr BrushNode::clone() const {
-	scene::INodePtr clone(new BrushNode(*this));
-	clone->setSelf(clone);
-	return clone;
-}
-
+}
+
+// IBrushNode implementation
+Brush& BrushNode::getBrush() {
+	return m_brush;
+}
+
+void BrushNode::translateDoom3Brush(const Vector3& translation) {
+	m_brush.translateDoom3Brush(translation);
+}
+
+scene::INodePtr BrushNode::clone() const {
+	scene::INodePtr clone(new BrushNode(*this));
+	clone->setSelf(clone);
+	return clone;
+}
+
 void BrushNode::instantiate(const scene::Path& path) {
 	m_brush.instanceAttach(path);
-	GlobalRadiant().getCounter(counterBrushes).increment();
-
+	GlobalRadiant().getCounter(counterBrushes).increment();
+
 	Node::instantiate(path);
 }
 
-void BrushNode::uninstantiate(const scene::Path& path) {
+void BrushNode::uninstantiate(const scene::Path& path) {
 	GlobalRadiant().getCounter(counterBrushes).decrement();
-	m_brush.instanceDetach(path);
-
-	Node::uninstantiate(path);
-}
-
+	m_brush.instanceDetach(path);
+
+	Node::uninstantiate(path);
+}
+
 void BrushNode::constructStatic() {
 	m_state_selpoint = GlobalShaderCache().capture("$SELPOINT");
 }
 
 void BrushNode::destroyStatic() {
 	m_state_selpoint = ShaderPtr(); 
-}
-
+}
+
 void BrushNode::clear() {
 	m_faceInstances.clear();
 }
@@ -317,8 +317,8 @@
 
 void BrushNode::DEBUG_verify() {
 	ASSERT_MESSAGE(m_faceInstances.size() == m_brush.DEBUG_size(), "FATAL: mismatch");
-}
-
+}
+
 bool BrushNode::testLight(const RendererLight& light) const {
 	return light.testAABB(worldAABB());
 }
@@ -334,8 +334,8 @@
 	for (FaceInstances::const_iterator i = m_faceInstances.begin(); i != m_faceInstances.end(); ++i) {
 		i->m_lights.clear();
 	}
-}
-
+}
+
 void BrushNode::renderComponents(Renderer& renderer, const VolumeTest& volume) const {
 	m_brush.evaluateBRep();
 
@@ -351,8 +351,8 @@
 	else {
 		m_brush.renderComponents(GlobalSelectionSystem().ComponentMode(), renderer, volume, l2w);
 	}
-}
-
+}
+
 void BrushNode::renderSolid(Renderer& renderer, const VolumeTest& volume) const {
 	m_brush.evaluateBRep();
 
@@ -377,8 +377,8 @@
 
 void BrushNode::viewChanged() const {
 	m_viewChanged = true;
-}
-
+}
+
 void BrushNode::evaluateViewDependent(const VolumeTest& volume, const Matrix4& localToWorld) const {
 	if (m_viewChanged) {
 		m_viewChanged = false;
@@ -398,8 +398,8 @@
 		m_brush.update_wireframe(m_render_wireframe, faces_visible);
 		m_brush.update_faces_wireframe(m_faceCentroidPointsCulled, faces_visible);
 	}
-}
-
+}
+
 void BrushNode::renderSolid(Renderer& renderer, const VolumeTest& volume, const Matrix4& localToWorld) const {
 	//renderCommon(renderer, volume);
 
@@ -423,8 +423,8 @@
 	}
 
 	renderComponentsSelected(renderer, volume, localToWorld);
-}
-
+}
+
 void BrushNode::update_selected() const {
 	m_render_selected.clear();
 
@@ -433,8 +433,8 @@
 			i->iterate_selected(m_render_selected);
 		}
 	}
-}
-
+}
+
 void BrushNode::renderComponentsSelected(Renderer& renderer, const VolumeTest& volume, const Matrix4& localToWorld) const {
 	m_brush.evaluateBRep();
 
@@ -445,8 +445,8 @@
 		renderer.SetState(BrushNode::m_state_selpoint, Renderer::eFullMaterials);
 		renderer.addRenderable(m_render_selected, localToWorld);
 	}
-}
-
+}
+
 void BrushNode::evaluateTransform() {
 	Matrix4 matrix(calculateTransform());
 	//globalOutputStream() << "matrix: " << matrix << "\n";
@@ -457,29 +457,29 @@
 	else {
 		transformComponents(matrix);
 	}
-}
-
+}
+
 void BrushNode::transformComponents(const Matrix4& matrix) {
 	for (FaceInstances::iterator i = m_faceInstances.begin(); i != m_faceInstances.end(); ++i) {
 		i->transformComponents(matrix);
 	}
-}
-
+}
+
 void BrushNode::applyTransform() {
 	m_brush.revertTransform();
 	evaluateTransform();
 	m_brush.freezeTransform();
-}
-
+}
+
 void BrushNode::setClipPlane(const Plane3& plane) {
 	m_clipPlane.setPlane(m_brush, plane);
-}
-
+}
+
 const BrushInstanceVisitor& BrushNode::forEachFaceInstance(const BrushInstanceVisitor& visitor) {
 	for (FaceInstances::iterator i = m_faceInstances.begin(); i != m_faceInstances.end(); ++i) {
 		visitor.visit(*i);
 	}
 	return visitor;
-}
-
-ShaderPtr BrushNode::m_state_selpoint;
+}
+
+ShaderPtr BrushNode::m_state_selpoint;
Index: radiant/layers/LayerSystem.h
===================================================================
--- radiant/layers/LayerSystem.h	(revision 3603)
+++ radiant/layers/LayerSystem.h	(working copy)
@@ -1,129 +1,129 @@
-#ifndef LAYERSYSTEM_H_
-#define LAYERSYSTEM_H_
-
-#include <vector>
-#include <map>
-#include "ilayer.h"
-#include "LayerCommandTarget.h"
-
-namespace scene {
-
-	namespace {
-		const std::string COMMAND_PREFIX_ADDTOLAYER("AddSelectionToLayer");
-		const std::string COMMAND_PREFIX_MOVETOLAYER("MoveSelectionToLayer");
-		const std::string COMMAND_PREFIX_SHOWLAYER("ShowLayer");
-		const std::string COMMAND_PREFIX_HIDELAYER("HideLayer");
-	}
-
-class LayerSystem :
-	public ILayerSystem
-{
-	// greebo: An array of booleans reflects the visibility status
-	// of all layers. Indexed by the layer id, it can be used to
-	// quickly check whether a layer is visible or not.
-	typedef std::vector<bool> LayerVisibilityList;
-	LayerVisibilityList _layerVisibility;
-
-	// The list of named layers, indexed by an integer ID
-	typedef std::map<int, std::string> LayerMap;
-	LayerMap _layers;
-
-	typedef std::vector<LayerCommandTargetPtr> CommandTargetList;
-	CommandTargetList _commandTargets;
-
-public:
-	/**
-	 * greebo: Creates a new layer with the given name.
-	 * 
-	 * @returns: the ID of the layer of -1 if the layer could not
-	 *           be created (e.g. due to a name conflict).
-	 */
-	int createLayer(const std::string& name);
-
-	/**
-	 * greebo: Overload: Creates a new layer with the given name and the given ID.
-	 * 
-	 * @returns: the ID of the layer of -1 if the layer could not
-	 *           be created (e.g. due to a name/ID conflict).
-	 */
-	int createLayer(const std::string& name, int layerID);
-
-	/**
-	 * greebo: Deletes the named layer. All nodes are removed
-	 *         from this layer before deletion.
-	 */
-	void deleteLayer(const std::string& name);
-
-	/**
-	 * greebo: Resets the layer system into its ground state. Deletes all
-	 *         layers except for layer #0 which is renamed to "Default".
-	 */
-	void reset();
-
-	/**
-	 * greebo: Visits each layer using the given visitor.
-	 */
-	void foreachLayer(Visitor& visitor);
-
-	// Returns the ID of the named layer, or -1 if name doesn't exist
-	int getLayerID(const std::string& name) const;
-	std::string getLayerName(int layerID) const;
-
-	// Returns the ID of the first visible layer or -1 if all are hidden.
-	virtual int getFirstVisibleLayer() const;
-
-	// Returns true if the given layer is visible
-	virtual bool layerIsVisible(const std::string& layerName);
-	virtual bool layerIsVisible(int layerID);
-
-	// Sets the visibility state of the given layer to <visible>
-	virtual void setLayerVisibility(const std::string& layerName, bool visible);
-	virtual void setLayerVisibility(int layerID, bool visible);
-
-	/**
-	 * greebo: Traverses the selection and adds each node to the given layer.
-	 */
-	void addSelectionToLayer(const std::string& layerName);
-	void addSelectionToLayer(int layerID);
-
-	/**
-	 * greebo: Moves all selected nodes to the given layer. This implicitly
-	 *         removes the nodes from all other layers.
-	 */
-	void moveSelectionToLayer(const std::string& layerName);
-	void moveSelectionToLayer(int layerID);
-
-	/**
-	 * greebo: Removes the selected nodes from the given layers.
-	 */
-	void removeSelectionFromLayer(const std::string& layerName);
-	void removeSelectionFromLayer(int layerID);
-
-	virtual bool updateNodeVisibility(const scene::INodePtr& node);
-
+#ifndef LAYERSYSTEM_H_
+#define LAYERSYSTEM_H_
+
+#include <vector>
+#include <map>
+#include "ilayer.h"
+#include "LayerCommandTarget.h"
+
+namespace scene {
+
+	namespace {
+		const std::string COMMAND_PREFIX_ADDTOLAYER("AddSelectionToLayer");
+		const std::string COMMAND_PREFIX_MOVETOLAYER("MoveSelectionToLayer");
+		const std::string COMMAND_PREFIX_SHOWLAYER("ShowLayer");
+		const std::string COMMAND_PREFIX_HIDELAYER("HideLayer");
+	}
+
+class LayerSystem :
+	public ILayerSystem
+{
+	// greebo: An array of booleans reflects the visibility status
+	// of all layers. Indexed by the layer id, it can be used to
+	// quickly check whether a layer is visible or not.
+	typedef std::vector<bool> LayerVisibilityList;
+	LayerVisibilityList _layerVisibility;
+
+	// The list of named layers, indexed by an integer ID
+	typedef std::map<int, std::string> LayerMap;
+	LayerMap _layers;
+
+	typedef std::vector<LayerCommandTargetPtr> CommandTargetList;
+	CommandTargetList _commandTargets;
+
+public:
+	/**
+	 * greebo: Creates a new layer with the given name.
+	 * 
+	 * @returns: the ID of the layer of -1 if the layer could not
+	 *           be created (e.g. due to a name conflict).
+	 */
+	int createLayer(const std::string& name);
+
+	/**
+	 * greebo: Overload: Creates a new layer with the given name and the given ID.
+	 * 
+	 * @returns: the ID of the layer of -1 if the layer could not
+	 *           be created (e.g. due to a name/ID conflict).
+	 */
+	int createLayer(const std::string& name, int layerID);
+
+	/**
+	 * greebo: Deletes the named layer. All nodes are removed
+	 *         from this layer before deletion.
+	 */
+	void deleteLayer(const std::string& name);
+
+	/**
+	 * greebo: Resets the layer system into its ground state. Deletes all
+	 *         layers except for layer #0 which is renamed to "Default".
+	 */
+	void reset();
+
+	/**
+	 * greebo: Visits each layer using the given visitor.
+	 */
+	void foreachLayer(Visitor& visitor);
+
+	// Returns the ID of the named layer, or -1 if name doesn't exist
+	int getLayerID(const std::string& name) const;
+	std::string getLayerName(int layerID) const;
+
+	// Returns the ID of the first visible layer or -1 if all are hidden.
+	virtual int getFirstVisibleLayer() const;
+
+	// Returns true if the given layer is visible
+	virtual bool layerIsVisible(const std::string& layerName);
+	virtual bool layerIsVisible(int layerID);
+
+	// Sets the visibility state of the given layer to <visible>
+	virtual void setLayerVisibility(const std::string& layerName, bool visible);
+	virtual void setLayerVisibility(int layerID, bool visible);
+
+	/**
+	 * greebo: Traverses the selection and adds each node to the given layer.
+	 */
+	void addSelectionToLayer(const std::string& layerName);
+	void addSelectionToLayer(int layerID);
+
+	/**
+	 * greebo: Moves all selected nodes to the given layer. This implicitly
+	 *         removes the nodes from all other layers.
+	 */
+	void moveSelectionToLayer(const std::string& layerName);
+	void moveSelectionToLayer(int layerID);
+
+	/**
+	 * greebo: Removes the selected nodes from the given layers.
+	 */
+	void removeSelectionFromLayer(const std::string& layerName);
+	void removeSelectionFromLayer(int layerID);
+
+	virtual bool updateNodeVisibility(const scene::INodePtr& node);
+
 	// RegisterableModule implementation
 	virtual const std::string& getName() const;
 	virtual const StringSet& getDependencies() const;
 	virtual void initialiseModule(const ApplicationContext& ctx);
-	virtual void shutdownModule();
-
-private:
-	// Internal event, updates the scenegraph
-	void onLayerVisibilityChanged();
-
-	// Updates the visibility state of the entire scenegraph
-	void updateSceneGraphVisibility();
-
-	// Returns the highest used layer Id
-	int getHighestLayerID() const;
-
-	// Returns the lowest unused layer ID
-	int getLowestUnusedLayerID();
-};
-
-// Internal accessor, only accessible within this binary
-LayerSystem& getLayerSystem();
-
-} // namespace scene
-
-#endif /* LAYERSYSTEM_H_ */
+	virtual void shutdownModule();
+
+private:
+	// Internal event, updates the scenegraph
+	void onLayerVisibilityChanged();
+
+	// Updates the visibility state of the entire scenegraph
+	void updateSceneGraphVisibility();
+
+	// Returns the highest used layer Id
+	int getHighestLayerID() const;
+
+	// Returns the lowest unused layer ID
+	int getLowestUnusedLayerID();
+};
+
+// Internal accessor, only accessible within this binary
+LayerSystem& getLayerSystem();
+
+} // namespace scene
+
+#endif /* LAYERSYSTEM_H_ */
Index: radiant/referencecache/NullModel.cpp
===================================================================
--- radiant/referencecache/NullModel.cpp	(revision 3603)
+++ radiant/referencecache/NullModel.cpp	(working copy)
@@ -5,97 +5,97 @@
 
 namespace model {
 
-NullModel::NullModel() : 
-	_aabbLocal(Vector3(0, 0, 0), Vector3(8, 8, 8)), 
-	_aabbSolid(_aabbLocal), 
-	_aabbWire(_aabbLocal)
-{
-	_state = GlobalShaderCache().capture("");
-}
-
-NullModel::~NullModel() {
-	_state = ShaderPtr();
-}
-
-VolumeIntersectionValue NullModel::intersectVolume(
-	const VolumeTest& volume, const Matrix4& localToWorld) const
-{
-	return volume.TestAABB(_aabbLocal, localToWorld);
-}
-
-const AABB& NullModel::localAABB() const {
-	return _aabbLocal;
-}
-
-void NullModel::renderSolid(Renderer& renderer, 
-	const VolumeTest& volume, const Matrix4& localToWorld) const
-{
-	renderer.SetState(_state, Renderer::eFullMaterials);
-	renderer.addRenderable(_aabbSolid, localToWorld);
-}
-
-void NullModel::renderWireframe(Renderer& renderer, 
-	const VolumeTest& volume, const Matrix4& localToWorld) const
-{
-	renderer.SetState(_state, Renderer::eWireframeOnly);
-	renderer.addRenderable(_aabbWire, localToWorld);
-}
-
-void NullModel::testSelect(Selector& selector, SelectionTest& test, const Matrix4& localToWorld) {
-	test.BeginMesh(localToWorld);
-
-	SelectionIntersection best;
-	aabb_testselect(_aabbLocal, test, best);
-
-	if(best.valid()) {
-		selector.addIntersection(best);
-	}
-}
-
-std::string NullModel::getFilename() const {
-	return _filename;
-}
-
-void NullModel::setFilename(const std::string& filename) {
-	_filename = filename;
-}
-
-std::string NullModel::getModelPath() const {
-	return _modelPath;
-}
-
-void NullModel::setModelPath(const std::string& modelPath) {
-	_modelPath = modelPath;
-}
-
-void NullModel::applySkin(const ModelSkin& skin) {
-	// do nothing
-}
-
-int NullModel::getSurfaceCount() const {
-	return 0;
-}
-
-int NullModel::getVertexCount() const {
-	return 0;
-}
-
-int NullModel::getPolyCount() const {
-	return 0;
-}
-
-const std::vector<std::string>& NullModel::getActiveMaterials() const {
-	static std::vector<std::string> _dummyMaterials;
-	return _dummyMaterials;
-}
-
-void NullModel::render(RenderStateFlags state) const {
-	if (state & RENDER_TEXTURE) {
-		aabb_draw_solid(_aabbLocal, state);
-	}
-	else {
-		aabb_draw_wire(_aabbLocal);
-	}
-}
+NullModel::NullModel() : 
+	_aabbLocal(Vector3(0, 0, 0), Vector3(8, 8, 8)), 
+	_aabbSolid(_aabbLocal), 
+	_aabbWire(_aabbLocal)
+{
+	_state = GlobalShaderCache().capture("");
+}
 
+NullModel::~NullModel() {
+	_state = ShaderPtr();
+}
+
+VolumeIntersectionValue NullModel::intersectVolume(
+	const VolumeTest& volume, const Matrix4& localToWorld) const
+{
+	return volume.TestAABB(_aabbLocal, localToWorld);
+}
+
+const AABB& NullModel::localAABB() const {
+	return _aabbLocal;
+}
+
+void NullModel::renderSolid(Renderer& renderer, 
+	const VolumeTest& volume, const Matrix4& localToWorld) const
+{
+	renderer.SetState(_state, Renderer::eFullMaterials);
+	renderer.addRenderable(_aabbSolid, localToWorld);
+}
+
+void NullModel::renderWireframe(Renderer& renderer, 
+	const VolumeTest& volume, const Matrix4& localToWorld) const
+{
+	renderer.SetState(_state, Renderer::eWireframeOnly);
+	renderer.addRenderable(_aabbWire, localToWorld);
+}
+
+void NullModel::testSelect(Selector& selector, SelectionTest& test, const Matrix4& localToWorld) {
+	test.BeginMesh(localToWorld);
+
+	SelectionIntersection best;
+	aabb_testselect(_aabbLocal, test, best);
+
+	if(best.valid()) {
+		selector.addIntersection(best);
+	}
+}
+
+std::string NullModel::getFilename() const {
+	return _filename;
+}
+
+void NullModel::setFilename(const std::string& filename) {
+	_filename = filename;
+}
+
+std::string NullModel::getModelPath() const {
+	return _modelPath;
+}
+
+void NullModel::setModelPath(const std::string& modelPath) {
+	_modelPath = modelPath;
+}
+
+void NullModel::applySkin(const ModelSkin& skin) {
+	// do nothing
+}
+
+int NullModel::getSurfaceCount() const {
+	return 0;
+}
+
+int NullModel::getVertexCount() const {
+	return 0;
+}
+
+int NullModel::getPolyCount() const {
+	return 0;
+}
+
+const std::vector<std::string>& NullModel::getActiveMaterials() const {
+	static std::vector<std::string> _dummyMaterials;
+	return _dummyMaterials;
+}
+
+void NullModel::render(RenderStateFlags state) const {
+	if (state & RENDER_TEXTURE) {
+		aabb_draw_solid(_aabbLocal, state);
+	}
+	else {
+		aabb_draw_wire(_aabbLocal);
+	}
+}
+
 } // namespace model
Index: radiant/referencecache/NullModel.h
===================================================================
--- radiant/referencecache/NullModel.h	(revision 3603)
+++ radiant/referencecache/NullModel.h	(working copy)
@@ -8,47 +8,47 @@
 
 namespace model {
 
-class NullModel :
-	public IModel,
-	public Cullable
-{
-	ShaderPtr _state;
-	AABB _aabbLocal;
-	RenderableSolidAABB _aabbSolid;
-	RenderableWireframeAABB _aabbWire;
-
-	std::string _filename;
-	std::string _modelPath;
-public:
-	NullModel();
-	virtual ~NullModel();
-
-	VolumeIntersectionValue intersectVolume(const VolumeTest& volume, const Matrix4& localToWorld) const;
-	
-	const AABB& localAABB() const;
-
-	void renderSolid(Renderer& renderer, const VolumeTest& volume, const Matrix4& localToWorld) const;
-	void renderWireframe(Renderer& renderer, const VolumeTest& volume, const Matrix4& localToWorld) const;
-
-	void testSelect(Selector& selector, SelectionTest& test, const Matrix4& localToWorld);
-
-	// IModel implementation
-	virtual std::string getFilename() const;
-	void setFilename(const std::string& filename);
-
-	virtual std::string getModelPath() const;
-	void setModelPath(const std::string& modelPath);
-
-	virtual void applySkin(const ModelSkin& skin);
-
-	virtual int getSurfaceCount() const;
-	virtual int getVertexCount() const;
-	virtual int getPolyCount() const;
-	
-	virtual const std::vector<std::string>& getActiveMaterials() const;
-
-	// OpenGLRenderable implementation
-	void render(RenderStateFlags state) const;
+class NullModel :
+	public IModel,
+	public Cullable
+{
+	ShaderPtr _state;
+	AABB _aabbLocal;
+	RenderableSolidAABB _aabbSolid;
+	RenderableWireframeAABB _aabbWire;
+
+	std::string _filename;
+	std::string _modelPath;
+public:
+	NullModel();
+	virtual ~NullModel();
+
+	VolumeIntersectionValue intersectVolume(const VolumeTest& volume, const Matrix4& localToWorld) const;
+	
+	const AABB& localAABB() const;
+
+	void renderSolid(Renderer& renderer, const VolumeTest& volume, const Matrix4& localToWorld) const;
+	void renderWireframe(Renderer& renderer, const VolumeTest& volume, const Matrix4& localToWorld) const;
+
+	void testSelect(Selector& selector, SelectionTest& test, const Matrix4& localToWorld);
+
+	// IModel implementation
+	virtual std::string getFilename() const;
+	void setFilename(const std::string& filename);
+
+	virtual std::string getModelPath() const;
+	void setModelPath(const std::string& modelPath);
+
+	virtual void applySkin(const ModelSkin& skin);
+
+	virtual int getSurfaceCount() const;
+	virtual int getVertexCount() const;
+	virtual int getPolyCount() const;
+	
+	virtual const std::vector<std::string>& getActiveMaterials() const;
+
+	// OpenGLRenderable implementation
+	void render(RenderStateFlags state) const;
 };
 typedef boost::shared_ptr<NullModel> NullModelPtr;
 
Index: radiant/ui/common/TexturePreviewCombo.cpp
===================================================================
--- radiant/ui/common/TexturePreviewCombo.cpp	(revision 3603)
+++ radiant/ui/common/TexturePreviewCombo.cpp	(working copy)
@@ -1,149 +1,149 @@
-#include "TexturePreviewCombo.h"
-
-#include "gtkutil/GLWidgetSentry.h"
-#include "gtkutil/ScrolledFrame.h"
-#include "gtkutil/StockIconMenuItem.h"
-#include "gtkutil/TextColumn.h"
-
-#include "ishaders.h"
-#include "texturelib.h"
-
-#include "ShaderSelector.h"
-
-#include <gtk/gtk.h>
-#include <GL/glew.h>
-#include <boost/bind.hpp>
-
-namespace ui
-{
-
-// Constructor. Create GTK widgets.
-
-TexturePreviewCombo::TexturePreviewCombo()
-: _widget(gtk_hbox_new(FALSE, 0)),
-  _glWidget(false),
-  _texName(""),
-  _infoStore(gtk_list_store_new(2, G_TYPE_STRING, G_TYPE_STRING)),
-  _infoView(gtk_tree_view_new_with_model(GTK_TREE_MODEL(_infoStore))),
-  _contextMenu(_infoView)
-{
-	// Set up the GL preview widget
-	GtkWidget* glWidget = _glWidget; // cast to GtkWidget
-	gtk_widget_set_size_request(glWidget, 128, 128);
-	g_signal_connect(G_OBJECT(glWidget), "expose-event", G_CALLBACK(_onExpose), this);
-	GtkWidget* glFrame = gtk_frame_new(NULL);
-	gtk_container_add(GTK_CONTAINER(glFrame), glWidget);
-	gtk_box_pack_start(GTK_BOX(_widget), glFrame, FALSE, FALSE, 0);
-	
-	// Set up the info table
-	gtk_tree_view_set_headers_visible(GTK_TREE_VIEW(_infoView), FALSE);
-	
+#include "TexturePreviewCombo.h"
+
+#include "gtkutil/GLWidgetSentry.h"
+#include "gtkutil/ScrolledFrame.h"
+#include "gtkutil/StockIconMenuItem.h"
+#include "gtkutil/TextColumn.h"
+
+#include "ishaders.h"
+#include "texturelib.h"
+
+#include "ShaderSelector.h"
+
+#include <gtk/gtk.h>
+#include <GL/glew.h>
+#include <boost/bind.hpp>
+
+namespace ui
+{
+
+// Constructor. Create GTK widgets.
+
+TexturePreviewCombo::TexturePreviewCombo()
+: _widget(gtk_hbox_new(FALSE, 0)),
+  _glWidget(false),
+  _texName(""),
+  _infoStore(gtk_list_store_new(2, G_TYPE_STRING, G_TYPE_STRING)),
+  _infoView(gtk_tree_view_new_with_model(GTK_TREE_MODEL(_infoStore))),
+  _contextMenu(_infoView)
+{
+	// Set up the GL preview widget
+	GtkWidget* glWidget = _glWidget; // cast to GtkWidget
+	gtk_widget_set_size_request(glWidget, 128, 128);
+	g_signal_connect(G_OBJECT(glWidget), "expose-event", G_CALLBACK(_onExpose), this);
+	GtkWidget* glFrame = gtk_frame_new(NULL);
+	gtk_container_add(GTK_CONTAINER(glFrame), glWidget);
+	gtk_box_pack_start(GTK_BOX(_widget), glFrame, FALSE, FALSE, 0);
+	
+	// Set up the info table
+	gtk_tree_view_set_headers_visible(GTK_TREE_VIEW(_infoView), FALSE);
+	
 	gtk_tree_view_append_column(GTK_TREE_VIEW(_infoView),
 								gtkutil::TextColumn("Attribute", 0));
 	
 	gtk_tree_view_append_column(GTK_TREE_VIEW(_infoView),
-								gtkutil::TextColumn("Value", 1));
-
-	// Pack into main widget
-	gtk_box_pack_start(
-		GTK_BOX(_widget), gtkutil::ScrolledFrame(_infoView), TRUE, TRUE, 0
-	);
-	
-	// Construct the context menu
-	_contextMenu.addItem(
-		gtkutil::StockIconMenuItem(GTK_STOCK_COPY, "Copy shader name"),
-		boost::bind(&TexturePreviewCombo::_onCopyTexName, this)
-	);	
-}
-
-// Update the selected texture
-
-void TexturePreviewCombo::setTexture(const std::string& tex) {
-	_texName = tex;
-	refreshInfoTable();
-	gtk_widget_queue_draw(_glWidget);
-}
-
-// Refresh the info table
-
-void TexturePreviewCombo::refreshInfoTable() {
-	// Prepare the list
-	gtk_list_store_clear(_infoStore);
-
-	// Other properties require a valid shader name	
-	if (_texName.empty())
-		return;
-
-	IShaderPtr shader = GlobalShaderSystem().getShaderForName(_texName);
-	ShaderSelector::displayShaderInfo(shader, _infoStore);
-}
-
-// Popup menu callbacks
-
-void TexturePreviewCombo::_onCopyTexName() {
-	// Store texture on the clipboard
-	GtkClipboard* clipboard = gtk_clipboard_get(GDK_SELECTION_CLIPBOARD);
-	gtk_clipboard_set_text(clipboard, _texName.c_str(), static_cast<int>(_texName.size()));
-}
-
-// GTK CALLBACKS
-
-void TexturePreviewCombo::_onExpose(GtkWidget* widget, GdkEventExpose* ev, TexturePreviewCombo* self) {
-	// Grab the GLWidget with sentry
-	gtkutil::GLWidgetSentry sentry(widget);
-	
-	// Get the viewport size from the GL widget
-	GtkRequisition req;
-	gtk_widget_size_request(widget, &req);
-	glViewport(0, 0, req.width, req.height);
-
-	// Initialise
-	glClearColor(0.3f, 0.3f, 0.3f, 0);
-	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-	glDisable(GL_DEPTH_TEST);
-	glMatrixMode(GL_PROJECTION);
-	glLoadIdentity();
-	glOrtho(0, req.width, 0, req.height, -100, 100);
-	glEnable (GL_TEXTURE_2D);
-
-	// If no texture is loaded, leave window blank
-	if (self->_texName == "")
-		return;
-
-	// Get a reference to the selected shader
-	IShaderPtr shader = GlobalShaderSystem().getShaderForName(self->_texName);
-
-	// This is an "ordinary" texture, take the editor image
-	TexturePtr tex = shader->getTexture();
-	if (tex != NULL) {
-		glBindTexture (GL_TEXTURE_2D, tex->texture_number);
-		
-		// Calculate the correct aspect ratio for preview
-		float aspect = float(tex->width) / float(tex->height);
-		float hfWidth, hfHeight;
-		if (aspect > 1.0) {
-			hfWidth = 0.5*req.width;
-			hfHeight = 0.5*req.height / aspect;
-		}
-		else {
-			hfHeight = 0.5*req.width;
-			hfWidth = 0.5*req.height * aspect;
-		}
-		
-		// Draw a quad to put the texture on
-		glPolygonMode (GL_FRONT_AND_BACK, GL_FILL);
-		glColor3f(1, 1, 1);
-		glBegin(GL_QUADS);
-		glTexCoord2i(0, 1); 
-		glVertex2f(0.5*req.width - hfWidth, 0.5*req.height - hfHeight);
-		glTexCoord2i(1, 1); 
-		glVertex2f(0.5*req.width + hfWidth, 0.5*req.height - hfHeight);
-		glTexCoord2i(1, 0); 
-		glVertex2f(0.5*req.width + hfWidth, 0.5*req.height + hfHeight);
-		glTexCoord2i(0, 0);	
-		glVertex2f(0.5*req.width - hfWidth, 0.5*req.height + hfHeight);
-		glEnd();
-	}
-}
-
-}
+								gtkutil::TextColumn("Value", 1));
+
+	// Pack into main widget
+	gtk_box_pack_start(
+		GTK_BOX(_widget), gtkutil::ScrolledFrame(_infoView), TRUE, TRUE, 0
+	);
+	
+	// Construct the context menu
+	_contextMenu.addItem(
+		gtkutil::StockIconMenuItem(GTK_STOCK_COPY, "Copy shader name"),
+		boost::bind(&TexturePreviewCombo::_onCopyTexName, this)
+	);	
+}
+
+// Update the selected texture
+
+void TexturePreviewCombo::setTexture(const std::string& tex) {
+	_texName = tex;
+	refreshInfoTable();
+	gtk_widget_queue_draw(_glWidget);
+}
+
+// Refresh the info table
+
+void TexturePreviewCombo::refreshInfoTable() {
+	// Prepare the list
+	gtk_list_store_clear(_infoStore);
+
+	// Other properties require a valid shader name	
+	if (_texName.empty())
+		return;
+
+	IShaderPtr shader = GlobalShaderSystem().getShaderForName(_texName);
+	ShaderSelector::displayShaderInfo(shader, _infoStore);
+}
+
+// Popup menu callbacks
+
+void TexturePreviewCombo::_onCopyTexName() {
+	// Store texture on the clipboard
+	GtkClipboard* clipboard = gtk_clipboard_get(GDK_SELECTION_CLIPBOARD);
+	gtk_clipboard_set_text(clipboard, _texName.c_str(), static_cast<int>(_texName.size()));
+}
+
+// GTK CALLBACKS
+
+void TexturePreviewCombo::_onExpose(GtkWidget* widget, GdkEventExpose* ev, TexturePreviewCombo* self) {
+	// Grab the GLWidget with sentry
+	gtkutil::GLWidgetSentry sentry(widget);
+	
+	// Get the viewport size from the GL widget
+	GtkRequisition req;
+	gtk_widget_size_request(widget, &req);
+	glViewport(0, 0, req.width, req.height);
+
+	// Initialise
+	glClearColor(0.3f, 0.3f, 0.3f, 0);
+	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+	glDisable(GL_DEPTH_TEST);
+	glMatrixMode(GL_PROJECTION);
+	glLoadIdentity();
+	glOrtho(0, req.width, 0, req.height, -100, 100);
+	glEnable (GL_TEXTURE_2D);
+
+	// If no texture is loaded, leave window blank
+	if (self->_texName == "")
+		return;
+
+	// Get a reference to the selected shader
+	IShaderPtr shader = GlobalShaderSystem().getShaderForName(self->_texName);
+
+	// This is an "ordinary" texture, take the editor image
+	TexturePtr tex = shader->getTexture();
+	if (tex != NULL) {
+		glBindTexture (GL_TEXTURE_2D, tex->texture_number);
+		
+		// Calculate the correct aspect ratio for preview
+		float aspect = float(tex->width) / float(tex->height);
+		float hfWidth, hfHeight;
+		if (aspect > 1.0) {
+			hfWidth = 0.5*req.width;
+			hfHeight = 0.5*req.height / aspect;
+		}
+		else {
+			hfHeight = 0.5*req.width;
+			hfWidth = 0.5*req.height * aspect;
+		}
+		
+		// Draw a quad to put the texture on
+		glPolygonMode (GL_FRONT_AND_BACK, GL_FILL);
+		glColor3f(1, 1, 1);
+		glBegin(GL_QUADS);
+		glTexCoord2i(0, 1); 
+		glVertex2f(0.5*req.width - hfWidth, 0.5*req.height - hfHeight);
+		glTexCoord2i(1, 1); 
+		glVertex2f(0.5*req.width + hfWidth, 0.5*req.height - hfHeight);
+		glTexCoord2i(1, 0); 
+		glVertex2f(0.5*req.width + hfWidth, 0.5*req.height + hfHeight);
+		glTexCoord2i(0, 0);	
+		glVertex2f(0.5*req.width - hfWidth, 0.5*req.height + hfHeight);
+		glEnd();
+	}
+}
+
+}
Index: tools/vcprojects/archivezip.vcproj
===================================================================
--- tools/vcprojects/archivezip.vcproj	(revision 3603)
+++ tools/vcprojects/archivezip.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="archivezip"
 	ProjectGUID="{A7E0FE03-E9BB-4478-9752-250BBD406C2D}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/DarkRadiant.sln
===================================================================
--- tools/vcprojects/DarkRadiant.sln	(revision 3603)
+++ tools/vcprojects/DarkRadiant.sln	(working copy)
@@ -1,16 +1,16 @@
-Microsoft Visual Studio Solution File, Format Version 9.00
-# Visual C++ Express 2005
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual C++ Express 2008
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mathlib", "mathlib.vcproj", "{3C9FB5AA-7118-476E-B33D-D3AC1C8412BB}"
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DarkRadiant", "DarkRadiant.vcproj", "{8E70385C-223A-4DD1-9B99-28FF2331A2B5}"
 	ProjectSection(ProjectDependencies) = postProject
 		{4286E605-5358-462F-AC57-44FCC697585B} = {4286E605-5358-462F-AC57-44FCC697585B}
 		{F7408B46-E4A9-470C-9731-9A1564247385} = {F7408B46-E4A9-470C-9731-9A1564247385}
+		{D42098ED-E192-4DC1-BA1C-80812AB194B4} = {D42098ED-E192-4DC1-BA1C-80812AB194B4}
+		{8050CFB1-20CC-40FD-8D74-0901C9CA2BE8} = {8050CFB1-20CC-40FD-8D74-0901C9CA2BE8}
+		{3C9FB5AA-7118-476E-B33D-D3AC1C8412BB} = {3C9FB5AA-7118-476E-B33D-D3AC1C8412BB}
+		{B6D4B38A-0C39-42CD-8193-75979E1F4D68} = {B6D4B38A-0C39-42CD-8193-75979E1F4D68}
 		{A15EFB56-927F-411D-A57B-0328321456A2} = {A15EFB56-927F-411D-A57B-0328321456A2}
-		{B6D4B38A-0C39-42CD-8193-75979E1F4D68} = {B6D4B38A-0C39-42CD-8193-75979E1F4D68}
-		{3C9FB5AA-7118-476E-B33D-D3AC1C8412BB} = {3C9FB5AA-7118-476E-B33D-D3AC1C8412BB}
-		{8050CFB1-20CC-40FD-8D74-0901C9CA2BE8} = {8050CFB1-20CC-40FD-8D74-0901C9CA2BE8}
-		{D42098ED-E192-4DC1-BA1C-80812AB194B4} = {D42098ED-E192-4DC1-BA1C-80812AB194B4}
 	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "archivezip", "archivezip.vcproj", "{A7E0FE03-E9BB-4478-9752-250BBD406C2D}"
@@ -71,8 +71,8 @@
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "sound", "sound.vcproj", "{1482AAB4-40B6-44C0-9FD8-AF80C18A5E7F}"
 	ProjectSection(ProjectDependencies) = postProject
+		{B6D4B38A-0C39-42CD-8193-75979E1F4D68} = {B6D4B38A-0C39-42CD-8193-75979E1F4D68}
 		{A15EFB56-927F-411D-A57B-0328321456A2} = {A15EFB56-927F-411D-A57B-0328321456A2}
-		{B6D4B38A-0C39-42CD-8193-75979E1F4D68} = {B6D4B38A-0C39-42CD-8193-75979E1F4D68}
 	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "uimanager", "uimanager.vcproj", "{97E454CC-E8B0-4274-AEAE-5157F420C984}"
Index: tools/vcprojects/DarkRadiant.vcproj
===================================================================
--- tools/vcprojects/DarkRadiant.vcproj	(revision 3603)
+++ tools/vcprojects/DarkRadiant.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="DarkRadiant"
 	ProjectGUID="{8E70385C-223A-4DD1-9B99-28FF2331A2B5}"
 	RootNamespace="GtkRadiant"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -86,8 +87,10 @@
 				GenerateMapFile="false"
 				SubSystem="1"
 				EntryPointSymbol="mainCRTStartup"
-				TargetMachine="1"
+				RandomizedBaseAddress="1"
 				FixedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -108,9 +111,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine="$(SolutionDir)/post_build_event.bat"
 			/>
@@ -185,8 +185,10 @@
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
 				EntryPointSymbol="mainCRTStartup"
-				TargetMachine="1"
+				RandomizedBaseAddress="1"
 				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -207,9 +209,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine="$(SolutionDir)/post_build_event.bat"
 			/>
Index: tools/vcprojects/ddslib.vcproj
===================================================================
--- tools/vcprojects/ddslib.vcproj	(revision 3603)
+++ tools/vcprojects/ddslib.vcproj	(working copy)
@@ -1,10 +1,11 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="ddslib"
 	ProjectGUID="{D42098ED-E192-4DC1-BA1C-80812AB194B4}"
 	RootNamespace="jpeglib"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
Index: tools/vcprojects/dm.d3hook.vcproj
===================================================================
--- tools/vcprojects/dm.d3hook.vcproj	(revision 3603)
+++ tools/vcprojects/dm.d3hook.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="dm.d3hook"
 	ProjectGUID="{916F8AE5-D7FC-44E1-908D-B54100C6F4AD}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/dm.difficulty.vcproj
===================================================================
--- tools/vcprojects/dm.difficulty.vcproj	(revision 3603)
+++ tools/vcprojects/dm.difficulty.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="dm.difficulty"
 	ProjectGUID="{68B95079-09DF-48F7-BAD9-81C33118BEFD}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/dm.objectives.vcproj
===================================================================
--- tools/vcprojects/dm.objectives.vcproj	(revision 3603)
+++ tools/vcprojects/dm.objectives.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="dm.objectives"
 	ProjectGUID="{05E9A613-2108-4843-A567-16B432DAC272}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/dm.stimresponse.vcproj
===================================================================
--- tools/vcprojects/dm.stimresponse.vcproj	(revision 3603)
+++ tools/vcprojects/dm.stimresponse.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="dm.stimresponse"
 	ProjectGUID="{EE9A3B61-58E0-4AA4-8942-6CFCBFAACC3F}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/eclassmgr.vcproj
===================================================================
--- tools/vcprojects/eclassmgr.vcproj	(revision 3603)
+++ tools/vcprojects/eclassmgr.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="eclassmgr"
 	ProjectGUID="{4CF3ED90-BE1A-45D1-9DC7-7CC6884A9754}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/eclasstree.vcproj
===================================================================
--- tools/vcprojects/eclasstree.vcproj	(revision 3603)
+++ tools/vcprojects/eclasstree.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="eclasstree"
 	ProjectGUID="{3B1A6CA3-D76E-4020-860D-1BED3DF7A3BE}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/entity.vcproj
===================================================================
--- tools/vcprojects/entity.vcproj	(revision 3603)
+++ tools/vcprojects/entity.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="entity"
 	ProjectGUID="{DC28A0B7-51AB-4F4A-A428-0765CA2CE6AB}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/entitylist.vcproj
===================================================================
--- tools/vcprojects/entitylist.vcproj	(revision 3603)
+++ tools/vcprojects/entitylist.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="entitylist"
 	ProjectGUID="{A35C6082-EE2D-4DEB-944B-61CFEB19C5B1}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/eventmanager.vcproj
===================================================================
--- tools/vcprojects/eventmanager.vcproj	(revision 3603)
+++ tools/vcprojects/eventmanager.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="eventmanager"
 	ProjectGUID="{0EB2B264-13C5-47E8-B99A-A46C8C2E108F}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/filetypes.vcproj
===================================================================
--- tools/vcprojects/filetypes.vcproj	(revision 3603)
+++ tools/vcprojects/filetypes.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="filetypes"
 	ProjectGUID="{A0E26F34-9447-4B04-9069-A6517F065759}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -81,6 +82,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -103,9 +106,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -177,9 +177,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -200,9 +202,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/filters.vcproj
===================================================================
--- tools/vcprojects/filters.vcproj	(revision 3603)
+++ tools/vcprojects/filters.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="filters"
 	ProjectGUID="{52681EA4-8879-4542-A394-4CFDD17FE275}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/grid.vcproj
===================================================================
--- tools/vcprojects/grid.vcproj	(revision 3603)
+++ tools/vcprojects/grid.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="grid"
 	ProjectGUID="{859C6FA8-FA3A-47D4-A64C-9B3D4282FCA8}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -81,6 +82,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -103,9 +106,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -178,9 +178,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -201,9 +203,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/gtkutillib.vcproj
===================================================================
--- tools/vcprojects/gtkutillib.vcproj	(revision 3603)
+++ tools/vcprojects/gtkutillib.vcproj	(working copy)
@@ -1,10 +1,11 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="gtkutillib"
 	ProjectGUID="{B6D4B38A-0C39-42CD-8193-75979E1F4D68}"
 	RootNamespace="gtkutillib"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
Index: tools/vcprojects/image.vcproj
===================================================================
--- tools/vcprojects/image.vcproj	(revision 3603)
+++ tools/vcprojects/image.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="image"
 	ProjectGUID="{002AEFE8-2CA3-43CA-84CA-CF74FF9F1E8E}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -73,7 +74,7 @@
 			<Tool
 				Name="VCLinkerTool"
 				AdditionalOptions="/NODEFAULTLIB:LIBCMT"
-				AdditionalDependencies="ddslib.lib jpeglib.lib xmlutillib.lib libxml2.lib glib-2.0.lib gtk-win32-2.0.lib gdk-win32-2.0.lib gobject-2.0.lib gdk_pixbuf-2.0.lib"
+				AdditionalDependencies="ddslib.lib jpeglib.lib xmlutillib.lib libxml2.lib glib-2.0.lib gtk-win32-2.0.lib gdk-win32-2.0.lib gobject-2.0.lib gdk_pixbuf-2.0.lib png.lib"
 				OutputFile="$(OutDir)/$(ProjectName).dll"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
@@ -83,6 +84,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -105,9 +108,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -168,7 +168,7 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="ddslib.lib jpeglib.lib xmlutillib.lib libxml2.lib glib-2.0.lib gtk-win32-2.0.lib gdk-win32-2.0.lib gobject-2.0.lib gdk_pixbuf-2.0.lib"
+				AdditionalDependencies="ddslib.lib jpeglib.lib xmlutillib.lib libxml2.lib glib-2.0.lib gtk-win32-2.0.lib gdk-win32-2.0.lib gobject-2.0.lib gdk_pixbuf-2.0.lib png.lib"
 				OutputFile="$(OutDir)/$(ProjectName).dll"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
@@ -180,9 +180,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -203,9 +205,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -268,6 +267,14 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\plugins\image\png.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\plugins\image\png.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\plugins\image\tga.cpp"
 				>
 			</File>
Index: tools/vcprojects/jpeglib.vcproj
===================================================================
--- tools/vcprojects/jpeglib.vcproj	(revision 3603)
+++ tools/vcprojects/jpeglib.vcproj	(working copy)
@@ -1,10 +1,11 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="jpeglib"
 	ProjectGUID="{4286E605-5358-462F-AC57-44FCC697585B}"
 	RootNamespace="jpeglib"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
Index: tools/vcprojects/libvorbis/libvorbis.vcproj
===================================================================
--- tools/vcprojects/libvorbis/libvorbis.vcproj	(revision 3603)
+++ tools/vcprojects/libvorbis/libvorbis.vcproj	(working copy)
@@ -1,10 +1,11 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="libvorbis"
 	ProjectGUID="{3BBB3A48-F1A9-4660-93C1-D141CB07E2DE}"
 	RootNamespace="libvorbis"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
Index: tools/vcprojects/libxml2/libxml2.vcproj
===================================================================
--- tools/vcprojects/libxml2/libxml2.vcproj	(revision 3603)
+++ tools/vcprojects/libxml2/libxml2.vcproj	(working copy)
@@ -1,9 +1,10 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="libxml2"
 	ProjectGUID="{6780EE95-8768-4138-A89B-47D3504A6E5D}"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
Index: tools/vcprojects/mapdoom3.vcproj
===================================================================
--- tools/vcprojects/mapdoom3.vcproj	(revision 3603)
+++ tools/vcprojects/mapdoom3.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="mapdoom3"
 	ProjectGUID="{3425D3E8-F025-448A-94C8-7EBA6F7A52E5}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/mathlib.vcproj
===================================================================
--- tools/vcprojects/mathlib.vcproj	(revision 3603)
+++ tools/vcprojects/mathlib.vcproj	(working copy)
@@ -1,9 +1,10 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="mathlib"
 	ProjectGUID="{3C9FB5AA-7118-476E-B33D-D3AC1C8412BB}"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
Index: tools/vcprojects/md5model.vcproj
===================================================================
--- tools/vcprojects/md5model.vcproj	(revision 3603)
+++ tools/vcprojects/md5model.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="md5model"
 	ProjectGUID="{D39D8067-7DE5-4BC2-8471-CFE99B00B042}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -83,6 +84,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -105,9 +108,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -181,9 +181,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -204,9 +206,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/model.vcproj
===================================================================
--- tools/vcprojects/model.vcproj	(revision 3603)
+++ tools/vcprojects/model.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="model"
 	ProjectGUID="{AFC3BF28-FC48-44C6-A0AA-695865EB4C70}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -83,6 +84,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -105,9 +108,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -181,9 +181,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -204,9 +206,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/particles.vcproj
===================================================================
--- tools/vcprojects/particles.vcproj	(revision 3603)
+++ tools/vcprojects/particles.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="particles"
 	ProjectGUID="{4361B40C-C042-40E4-8CD1-5A24EA120E9B}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/picomodellib.vcproj
===================================================================
--- tools/vcprojects/picomodellib.vcproj	(revision 3603)
+++ tools/vcprojects/picomodellib.vcproj	(working copy)
@@ -1,10 +1,11 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="picomodellib"
 	ProjectGUID="{8050CFB1-20CC-40FD-8D74-0901C9CA2BE8}"
 	RootNamespace="picomodellib"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
Index: tools/vcprojects/scenegraph.vcproj
===================================================================
--- tools/vcprojects/scenegraph.vcproj	(revision 3603)
+++ tools/vcprojects/scenegraph.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="scenegraph"
 	ProjectGUID="{89043465-96F4-4E90-A351-18ECEBD7E6F2}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -81,6 +82,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -103,9 +106,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -177,9 +177,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -200,9 +202,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/scenelib.vcproj
===================================================================
--- tools/vcprojects/scenelib.vcproj	(revision 3603)
+++ tools/vcprojects/scenelib.vcproj	(working copy)
@@ -1,9 +1,10 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="scenelib"
 	ProjectGUID="{F7408B46-E4A9-470C-9731-9A1564247385}"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
Index: tools/vcprojects/shaders.vcproj
===================================================================
--- tools/vcprojects/shaders.vcproj	(revision 3603)
+++ tools/vcprojects/shaders.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="shaders"
 	ProjectGUID="{D93EE174-6724-4F9A-B58D-11EE7EC92674}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/skins.vcproj
===================================================================
--- tools/vcprojects/skins.vcproj	(revision 3603)
+++ tools/vcprojects/skins.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="skins"
 	ProjectGUID="{CF4FE910-F038-4E19-A1E1-E11B584873F0}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/sound.vcproj
===================================================================
--- tools/vcprojects/sound.vcproj	(revision 3603)
+++ tools/vcprojects/sound.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="sound"
 	ProjectGUID="{1482AAB4-40B6-44C0-9FD8-AF80C18A5E7F}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -83,6 +84,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -105,9 +108,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -181,9 +181,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -204,9 +206,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/uimanager.vcproj
===================================================================
--- tools/vcprojects/uimanager.vcproj	(revision 3603)
+++ tools/vcprojects/uimanager.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="uimanager"
 	ProjectGUID="{97E454CC-E8B0-4274-AEAE-5157F420C984}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/undo.vcproj
===================================================================
--- tools/vcprojects/undo.vcproj	(revision 3603)
+++ tools/vcprojects/undo.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="undo"
 	ProjectGUID="{4BCE007A-3FD5-404B-9624-727736437EB0}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/vfspk3.vcproj
===================================================================
--- tools/vcprojects/vfspk3.vcproj	(revision 3603)
+++ tools/vcprojects/vfspk3.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="vfspk3"
 	ProjectGUID="{D933EF8B-2C21-46E7-B720-0621C090AE6E}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/xmlregistry.vcproj
===================================================================
--- tools/vcprojects/xmlregistry.vcproj	(revision 3603)
+++ tools/vcprojects/xmlregistry.vcproj	(working copy)
@@ -1,11 +1,12 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="xmlregistry"
 	ProjectGUID="{AC08880C-1150-4579-8870-A8C47C8E5B61}"
 	RootNamespace="archivezip"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -82,6 +83,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="$(OutDir)/$(ProjectName).pdb"
 				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
 			/>
@@ -104,9 +107,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
@@ -179,9 +179,11 @@
 				SubSystem="2"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="0"
+				DataExecutionPrevention="0"
 				ImportLibrary=""
 				TargetMachine="1"
-				FixedBaseAddress="0"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -202,9 +204,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 				CommandLine=""
 			/>
Index: tools/vcprojects/xmlutillib.vcproj
===================================================================
--- tools/vcprojects/xmlutillib.vcproj	(revision 3603)
+++ tools/vcprojects/xmlutillib.vcproj	(working copy)
@@ -1,10 +1,11 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="9.00"
 	Name="xmlutillib"
 	ProjectGUID="{A15EFB56-927F-411D-A57B-0328321456A2}"
 	RootNamespace="xmlutillib"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
